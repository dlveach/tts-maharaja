--[[///////////////////////////////////////////////////////////////////////////////////////////////
Maharaja player action dial

  --TODO:
    - IN WORK review all Global calls, design has iterated and some may need cleanup, unused etc.
        --mostly done, refactored a lot into setState()
    - implement "extra action" pointer and support

///////////////////////////////////////////////////////////////////////////////////////////////////]]


g_buttons = {"track","coins","character","palace-house","palace","quarry","move","2houses","house",}
g_pointer_rot_offsets = {184,142,104,64,28,-15,-55,-95,-135}
g_pointer = {
  name = "pointer-1",
  url = "http://cloud-3.steamusercontent.com/ugc/2019340792116360259/E5713D1160D784E5B340DCF8D114569C9E560938/",
  position = Vector(0.01,0.1,-0.05),
  rotation = Vector(90, 180, 0),
  scale = Vector(2,2,1),
}
g_extra_pointer = {
  name = "pointer-extra",
  url = "http://cloud-3.steamusercontent.com/ugc/2019341512250290332/123CEA34583ED4E97E4616055B24ED7AC7D2A982/",
  position = Vector(0.01,0.1,-0.05),
  rotation = Vector(90, 180, 0),
  scale = Vector(2,2,1),
}
g_back_decal = {
  name = "dial_back",
  url = "http://cloud-3.steamusercontent.com/ugc/2019340792119743844/FBF1CD3789663DD96F5C9D218ED931973551A259/",
  position = Vector(0.08,-0.06,-0.03),
  rotation = Vector(270,0,0),
  scale = Vector(5.1,5.1,1),
}
g_player_colors = {"Yellow","Red","Green","Blue","Purple"}

 g_actions = {
 	["track"] = {
    {id="track",label="Modify the Governor Track",},
  },
 	["coins"] = {
    {id="gold",label="Get 2 Gold from the bank",},
  },
 	["character"] = {
    {id="exchange",label="Exchange your Character",},
  },
 	["palace-house"] = {
    {id="palace",label="Build a Palace (City)",},
    {id="house",label="Build a House (City/Village)",},
  },
 	["palace"] = {
    {id="palace",label="Build a Palace (City)",},
  },
 	["quarry"] = {
    {id="quarry",label="Quarry 2 Houses into the pool",},
  },
 	["move"] = {
    {id="move",label="Move a House City/Village",},
  },
 	["2houses"] = {
    {id="city_house",label="Build a House (City)",},
    {id="house",label="Build a House (City/Village)",},
  },
 	["house"] = {
    {id="house",label="Build a House (City/Village)",},
  },
  ["free"] = {
    {id="free-build-move",label="Free Build/Move House (City/Village)",},
  },
}

env = {}

--[[ *****************************
TTS Load function
********************************]]
function onLoad(save_state)
  GD = {}
  GD.color = self.getName()
  gid = GD.color.."_dial"
  env = Global.getTable("env")
  assert(env, "*** ERROR: no env from Global")
  if save_state ~= "" then
    if env.test.trace then log(gid..": onLoad(): Loading from saved state") end
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
    updateUI() --handles most of the UI restore
    --restore dial button panel state
    self.UI.setAttribute("player_actions_panel","active",not(GD.state.flipped))
    --restore back button panel state
    if GD.state.stage == "actions_locked" or GD.state.stage == "actions_selected" then
      self.UI.setAttribute("back_button_panel","active",false)
    end
    self.UI.setAttribute("back_button_panel","visibility",GD.color)
    --restore button visiblity
    for _,btn in ipairs(g_buttons) do
      self.UI.setAttribute(btn.."_panel","visibility",GD.color)
    end
  else
    if env.test.trace then log(gid..": onLoad(): Loading from fresh state") end
    GD.state = {}
    GD.state.actions = {}
    GD.state.click = 0
    GD.state.stage = "select_actions"
    GD.state.flipped = self.is_face_down
    --setup visibility string
    GD.hide_from_players = {}
    for _,pcol in ipairs(g_player_colors) do
      if pcol ~= GD.color then
        table.insert(GD.hide_from_players, pcol)
      end
    end
    --setup dial decals
    self.setDecals({})
    local p = simpleDeepCopy(g_pointer)
    p.name = "pointer-1"
    self.addDecal(p)
    p.name = "pointer-2"
    self.addDecal(p)
    self.addDecal(g_back_decal)
    --setup button visiblity
    for _,btn in ipairs(g_buttons) do
      self.UI.setAttribute(btn.."_panel","visibility",GD.color)
    end
    self.UI.setAttribute("back_button_panel","visibility",GD.color)
    if not(env.test.in_dev) then
      -- resetPlayerButtons()
      --TODO: anything?
    end
    updateUI()
  end
end

--[[ *****************************
TTS save function
********************************]]
function onSave()
  local saved_data = ""
  if env and not(env.test.force_fresh_save) then
    saved_data = JSON.encode(GD)
  end
  return saved_data
end

--[[ *****************************
Update action UI panel based on current state.
********************************]]
function updateUI()
  if env.test.trace then log(gid..": updateUI()") end
  for i=1,7 do
    self.UI.setAttribute("row_action_"..tostring(i),"active",false)
  end
  for i,entry in ipairs(GD.state.actions) do
    if entry.type == "selected" or entry.type == "extra" then
      self.UI.setAttribute("action_text_"..tostring(i),"text",entry.label)
      self.UI.setAttribute("action_text_"..tostring(i), "color", "rgb(1,1,0)")
      self.UI.setAttribute("row_action_"..tostring(i),"active",true)
      self.UI.setAttribute("status_text_"..tostring(i),"text",entry.status)
      if entry.status == "Done" then
        self.UI.setAttribute("action_text_"..tostring(i), "color", "Gray")
      elseif entry.status =="Incomplete" then
        self.UI.setAttribute("action_text_"..tostring(i), "color", "Gray")
        self.UI.setAttribute("status_text_"..tostring(i), "color", "Red")
      end
    elseif entry.type == "free" then
      self.UI.setAttribute("action_text_7","text",entry.label)
      self.UI.setAttribute("action_text_7", "color", "rgb(1,1,0)")
      self.UI.setAttribute("row_action_7","active",true)
      self.UI.setAttribute("status_text_7","text",entry.status)
      if entry.status == "Done" then
        self.UI.setAttribute("action_text_7", "color", "Gray")
      -- elseif entry.status =="Incomplete" then  --TODO: free actions never incomlete???
      --   self.UI.setAttribute("action_text_7", "color", "Gray")
      --   self.UI.setAttribute("status_text_7", "color", "Red")
      end
    else
      log("***WARN: unknown action entry type: "..tostring(entry.type))
    end
  end
end

--[[ *****************************
Clear action data and reset pointers to default.
********************************]]
function resetActions()
  if env.test.trace then log(gid..": resetActions()") end
  local decals = self.getDecals()
  local rot = self.getRotation()
    assert(decals[1] ~= nil and decals[1].name == "pointer-1", gid..": ERROR: setPointerRotation(): Invalid pointer 1 decal")
  assert(decals[2] ~= nil and decals[2].name == "pointer-2", gid..": ERROR: setPointerRotation(): Invalid pointer 2 decal")
  decals[1].rotation.z = rot.z + 180
  decals[2].rotation.z = rot.z + 180
  self.setDecals(decals)
  GD.state.actions = {}
end

--[[ *****************************
Set this dial's state.  Called from Global.
--TODO: document
********************************]]
function setState(params)
  if env.test.trace then log(gid..": setState()") end
  if env.test.debug then log(params) end
  if params.state == "select_actions" then
    GD.state.stage = "select_actions"
    if params.reset then resetActions() end
    enableDialButtons()
    hideMe()
    if GD.state.flipped then flipMe() end
  elseif params.state == "actions_selected" then
    if not(GD.state.flipped) then flipMe() end
    self.UI.setAttribute("back_button_panel","active",(params.modify ~= nil and params.modify))
    GD.state.stage = "actions_selected"
  elseif params.state == "actions_locked" then
    self.UI.setAttribute("back_button_panel","active",false)
    if not(GD.state.flipped) then flipMe() end
    GD.state.stage = "actions_locked"
    showMe()
  elseif params.state =="extra_action" then
    GD.state.stage = "extra_action"
    enableDialButtons()

    --TODO: what about during a player turn?

    if GD.state.flipped then flipMe() end
  elseif params.state == "player_turn" then
    GD.state.stage = "player_turn"
    log("flipped state = "..tostring(GD.state.flipped))
    self.UI.setAttribute("back_button_panel","active",false)
    self.UI.setAttribute("player_actions_panel","visibility","")
    disableDialButtons()
    showMe()
    if GD.state.flipped then flipMe() end
  elseif params.state == "game_start" then
    if not(GD.state.flipped) then flipMe() end
    disableDialButtons()
		showMe()
  elseif params.state == "free_action" then
    local entry = {
      type = "free",
      action_id = g_actions["free"][1].id,
      label = g_actions["free"][1].label,
      status = ""
    }
    table.insert(GD.state.actions, entry)
    updateUI()
  elseif params.state == "complete_action" then
    local action_id = params.action_id
    for _,action in ipairs(GD.state.actions) do
      if action.action_id == params.action_id and action.status ~= "Done" then
        action.status = "Done"
        updateUI()
        break
      end
    end
  elseif params.state == "undo_action" then
    local action_id = params.action_id
    for _,action in ipairs(GD.state.actions) do
      if action.action_id == params.action_id and action.status == "Done" then
        action.status = ""
        updateUI()
        break
      end
    end
  elseif params.state == "fail_action" then
    local action_id = params.action_id
    for _,action in ipairs(GD.state.actions) do
      if action.action_id == params.action_id and action.status ~= "Incomplete" then
        action.status = "Incomplete"
        updateUI()
        break
      end
    end
  else
    log(gid..": ERROR: setState() unknown state: "..tostring(params.state))
  end
end

--[[ *****************************
Enable dial buttons.
********************************]]
function enableDialButtons()
  if env.test.trace then log(gid..": enableDialButtons()") end
  for _,action in ipairs(g_buttons) do
    self.UI.setAttribute(action.."_panel","active","true")
  end
end

--[[ *****************************
Disable dial buttons.
********************************]]
function disableDialButtons()
  if env.test.trace then log(gid..": disableDialButtons()") end
  for _,action in ipairs(g_buttons) do
    self.UI.setAttribute(action.."_panel","active","false")
  end
end

--[[ *****************************
Handler for modify button click (back of dial).
Flip face up and set state back to action selection.
Clears actions in player data (Global)
********************************]]
function modifyClick(player, btn, id)
  if env.test.trace then log(gid..": modifyClick(): id="..tostring(id)) end
  if player.color ~= GD.color then return end
  hideMe()
  enableDialButtons()
  flipMe()
  --call Global to clear player data & disable Done
  local p = {command="clear", player_color=player.color,}
  Global.call("updatePlayerActionSelection",p)
  GD.state.stage = "select_actions"
end

--[[ *****************************
Handler for dial button clicks.
Player is selecting actions on dial.
********************************]]
function dialClick(player, btn, id)
  if env.test.trace then log(gid..": dialClick(): id="..tostring(id)) end
  local mnemonic = Split(id,'_')[1]
  local dial_index = indexOf(g_buttons,mnemonic)
  assert(dial_index > 0, gid..": ERROR: dialClick() no button dial_index found for action")
  local actions = g_actions[mnemonic]
  assert(actions, gid..": ERROR: dialClick() no action(s) for mnemonic "..tostring(mnemonic))
  local id = ""

  if GD.state.stage =="extra_action" then
    --TODO: handle this
    log(gid..": TODO: dialClick() handle extra action click")

  elseif GD.state.stage == "select_actions" then
    if GD.state.click == 1 or GD.state.click == 0 then
      id = "pointer-1"
      GD.state.click = 2
    elseif GD.state.click == 2 then
      id = "pointer-2"
      GD.state.click = 1
      done = true
    else
      log(gid..": ERROR: dialClick() invalid click state")
      return
    end
    --remove existing "pointer-n" actions if any exist
    for i=#GD.state.actions,1,-1 do
      if GD.state.actions[i].dial_pointer == id then
        table.remove(GD.state.actions, i)
      end
    end
    for _,action in ipairs(actions) do
      local entry = {
        type = "selected",
        dial_pointer = id,
        action_id = action.id,
        label = action.label,
        status = ""
      }
      table.insert(GD.state.actions, entry)
      Global.call("updatePlayerActionSelection",{command="update",player_color=GD.color,actions=GD.state.actions})
    end
    setPointerRotation(id, dial_index)
    updateUI()
    if toboolean(self.UI.getAttribute("player_actions_panel","active")) == false then
      self.UI.setAttribute("player_actions_panel","active",true)
    end
  end
end

--[[ *****************************
Set Pointer rotation.
index: into module global list of rotation values.
********************************]]
function setPointerRotation(id, index)
  if env.test.trace then log(gid..":setPointerRotation() index = "..tostring(index)) end
  local decals = self.getDecals()
  local rot = self.getRotation()
  local offset = g_pointer_rot_offsets[index]
  assert(decals[1] ~= nil and decals[1].name == "pointer-1", gid..": ERROR: setPointerRotation(): Invalid pointer 1 decal")
  assert(decals[2] ~= nil and decals[2].name == "pointer-2", gid..": ERROR: setPointerRotation(): Invalid pointer 2 decal")
  if id == decals[1].name then
    decals[1].rotation.z = rot.z + offset
  elseif id == decals[2].name then
    decals[2].rotation.z = rot.z + offset
  else
    log(gid..": ERROR: setPointerRotation(): Decal id "..tostring(id).." not found")
    return
  end
  self.setDecals(decals)
end

--[[ *****************************
Hide this dial from other players.
Only visible to owning player.
********************************]]
function hideMe()
  if env.test.trace then log(gid..":hideMe()") end
  self.setInvisibleTo(GD.hide_from_players)
  self.UI.setAttribute("player_actions_panel", "visibility", GD.color)
end

--[[ *****************************
Show this dial to all players.
********************************]]
function showMe()
  if env.test.trace then log(gid..":showMe()") end
  self.setInvisibleTo({})
  self.UI.setAttribute("player_actions_panel", "visibility", "")
end

--[[ *****************************
Flip this dial.
Hide/Show actions UI panel active based on state.
********************************]]
function flipMe()
  if env.test.trace then log(gid..":flipMe()") end
  if not(GD.state.flipped) then
    --turn display off before flipping to avoid weird UI movement
    self.UI.setAttribute("player_actions_panel","active",false)
  end
  GD.state.flipped = not(GD.state.flipped)
  self.setLock(false)
  self.flip()
  Wait.condition(function()
    self.setLock(true)
    self.UI.setAttribute("player_actions_panel","active",not(GD.state.flipped))
  end, function() return self.resting end, 3)
end

--[[ *****************************
Log state data for debugging
  params: optional array of parameters
  params.child_path - child levels to append to 'GD'
        Use '|' to separate levels
        Example: '|state|actions'
              or 'state|actions'
  Defaults to log all of GD if no params.
  Limitations: only works with string keys, not numeric indexes
********************************]]
function dumpData(params)
  log("dumpData(): State data for "..self.getGUID()..": "..GD.color)
  if params then
    log(params)
    assert(params.child_path ~= nil,"ERROR: dumpData() missing 'params.child_path'")
    local children = Split(params.child_path,'|')
    local result = simpleDeepCopy(GD)
    for _,child in ipairs(children) do
      if child ~= "" then result = result[child] end
    end
    log(result)
  else
    log(GD)
  end
end

require("tts-lib/utils")
