-- #include tts-maharaja/Global
--[[///////////////////////////////////////////////////////////////////////////////////////////////

	Maharaja
		TODO: credits

  --TODO:
    - lots of stuff

///////////////////////////////////////////////////////////////////////////////////////////////////]]

env = {}
env.test = {}
env.test.trace = true
env.test.debug = true
env.test.in_dev = true
env.test.force_fresh_save = true
env.test.save_positions = true
env.test.auto_switch = true
-- env.test.players = {"Blue","Red","Yellow","Purple","Green",}
-- env.test.players = {"Yellow","Red","Blue","Purple",}
-- env.test.players = {"Yellow","Purple",}
-- env.test.players = {"Green","Red",}
env.test.players = {"Green","Red","Blue"}
-- env.test.players = {"Red","Green","Purple",}

env.game = {}
env.game.fill_delay = 2
env.game.use_help = true

GD = {}

--[[ *****************************
TTS Game Load
********************************]]
function onLoad(save_state)
	if env.test.trace then log("onLoad()") end
	if env.test.force_fresh_save then saved_data = "" end
	if not(env.test.in_dev) then
		getObjectFromGUID(C.board_guid).interactable = false
		getObjectFromGUID(C.palace_object_guid).setInvisibleTo(Color.list)
		getObjectFromGUID(C.house_object_guid).setInvisibleTo(Color.list)
		for _,g in pairs(C.action_dials) do
			getObjectFromGUID(g).setInvisibleTo(Color.list)
		end
	end
	if (saved_data ~= "") then
    log("onLoad(): load with saved data")
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
    restoreGameState()
  else
		log("onLoad(): load with fresh state")
		GD.state = {}
		GD.state.global_UI = {}
		GD.state.board_UI = {}
		GD.game = {}
		GD.undo = {}
		for _,g in pairs(C.player_pawns) do
			getObjectFromGUID(g).setLock(true)
		end
	end
end

--[[ *****************************
Save game state
********************************]]
function onSave()
	local saved_data = JSON.encode(GD)
  if env.test.force_fresh_save then
    saved_data = ""
  end
  return saved_data
end

--[[ *****************************
Restore the game state.
TODO: implement
********************************]]
function restoreGameState()
	if env.test.trace then log("restoreGameState()") end
	log("TODO: restoreGameState()")
end

--[[ ******************************
Wrapper function for global UI attributes.
Saves attribute update to be replayed on restore.
TODO: convert calls to use
*********************************]]
function UI_setAttribute(id, field, value)
  if env.test.trace2 then log("UI_setAttribute()") end
  assert(type(id) == "string", "UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "UI_setAttribute(): field must be a string")
  assert(value or value==false, "UI_setAttribute(): value missing")
  GD.states.global_UI[id.."|"..field] = value
  UI.setAttribute(id, field, value)
end

--[[ ******************************
Wrapper function for saving board UI attributes.
Saves attribute update to be replayed on restore.
TODO: convert calls to use
*********************************]]
function board_UI_setAttribute(id, field, value)
	if env.test.trace2 then log("board_UI_setAttribute()") end
	assert(type(id) == "string", "board_UI_setAttribute(): id must be a string")
	assert(type(field) == "string", "board_UI_setAttribute(): field must be a string")
	assert(value or value==false, "board_UI_setAttribute(): value missing")
	GD.states.board_UI[id.."|"..field] = value
	return getObjectFromGUID(C.board_guid).UI.setAttribute(id, field, value)
end

--[[ *****************************
Setup: A player clicked start game.
TODO: implement UI
********************************]]
function startGameBtn(player, btn, id)
	if env.test.trace then log("startGameBtn()") end
	startGame()
end

--[[ *****************************
Setup: initialize the game
********************************]]
function startGame()
	if env.test.trace then log("startGame()") end
	GD.game.stage = "setup"
	GD.game.auction_characters = false --TODO: get this from start dialog
	setupNetwork()
	if not(setupPlayers()) then
		--TODO: anything?
		return
	end
	--TODO: more game start stuff???
end

--[[ *****************************
Setup: initialize network data
********************************]]
function setupNetwork()
	if env.test.trace then log("setupNetwork()") end
	GD.network = simpleDeepCopy(NETWORK)
	for i,node in ipairs(GD.network) do
		node.center = CENTERS[i]
		if node.type == "city" then
			node.houses = {}
			for _,pcol in pairs(C.table_colors) do
				node.houses[pcol] = {}
			end
			node.palaces = {}
			node.architects = {}
		elseif node.type == "village" then
			node.houses = {}
		end
	end
end

--[[ *****************************
Setup: initialize game for seated players
********************************]]
function setupPlayers()
	if env.test.trace then log("setupPlayers()") end

	local seated = getSeatedPlayers()
	if env.test.players ~= nil then
		seated = simpleDeepCopy(env.test.players)
	end
	GD.game.player_count = #seated
	if GD.game.player_count < 2 then
		broadcastToAll("2 or more players needed")
		return false
	end
	GD.game.player_order = {}
	for _,pcol in ipairs(C.table_colors) do
		if contains(seated,pcol) then table.insert(GD.game.player_order,pcol) end
	end
	GD.game.players = {}
	for _,pcol in ipairs(GD.game.player_order) do
		GD.game.players[pcol] = simpleDeepCopy(C.player_data)
		getObjectFromGUID(C.player_pawns[pcol]).setLock(true)
		--initialize player pool
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		for i=1,12 do
			local pos = player_board.positionToWorld(C.player_board_pool_locations[i])
			table.insert(GD.game.players[pcol].pool, i, {g=nil,p=pos})
		end
	end
	GD.game.current_player = math.random(#GD.game.player_order)
	GD.game.current_player_color = GD.game.player_order[GD.game.current_player]
	broadcastToAll("Starting player will be "..GD.game.current_player_color)
	startLuaCoroutine(Global, "coroFillPlayerBoards")
	return true
end

--[[ *****************************
Setup: fill player boards with palaces and houses,
remove unused player objects and place unused palaces
Run as a coro with pauses between spawning objects.
********************************]]
function coroFillPlayerBoards()
	if env.test.trace then log("coroFillPlayerBoards(): START") end
	--private function to pause (yield) coro for a number of frames
	local pauseMe = function(frames)
		frames = frames or env.game.fill_delay
		local count = 0
		while count < frames do
			count = count + 1
			coroutine.yield(0)
		end
	end
	local house = getObjectFromGUID(C.house_object_guid)
	assert(house, "ERROR: coroFillPlayerBoards(): no house object")
	local palace = getObjectFromGUID(C.palace_object_guid)
	assert(palace, "ERROR: coroFillPlayerBoards(): no palace object")

	--remove unused player area objects
	local board = getObjectFromGUID(C.board_guid)
	local rot = board.getRotation()
	copy({palace})
	for _,pcol in ipairs(C.table_colors) do
		if GD.game.players[pcol] == nil then
			getObjectFromGUID(C.player_boards[pcol]).destruct()
			getObjectFromGUID(C.action_dials[pcol]).destruct()
			getObjectFromGUID(C.player_aids[pcol]).destruct()
			getObjectFromGUID(C.player_pawns[pcol]).destruct()
			--place unused player palaces in outer city palaces
			for name,city in pairs(C.cities) do
				local index = #GD.network[city.node].palaces + 1
				local pos = board.positionToWorld(GD.network[city.node].center - C.city_palace_offsets[index])
				local p = {position=pos}
				local obj = paste(p)[1]
				assert(obj, "ERROR: coroFillPlayerBoards(): failed to paste object")
				obj.setRotation(rot)
				obj.setColorTint(C.object_color_tints[pcol])
				obj.setName("Unused")
				obj.memo = "palace"
				table.insert(GD.network[city.node].palaces, {g=obj.getGUID(), c=pcol, p=pos})
				pauseMe()
				Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
			end
		end
	end
	pauseMe(10)
	--fill seated player boards
	for _,pcol in ipairs(GD.game.player_order) do
		local player = GD.game.players[pcol]
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		assert(player_board, "ERROR: coroFillPlayerBoards(): no board object")
		local rot = player_board.getRotation()
		copy({palace})
		for i,loc in ipairs(C.player_board_palace_locations) do
			local pos = player_board.positionToWorld(loc)
			local p = {position=pos}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "palace"
			table.insert(player.palaces, {g=obj.getGUID(),p=pos})
			pauseMe()
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		end
		copy({house})
		for i,loc in ipairs(C.player_board_quarry_locations) do
			local pos = player_board.positionToWorld(loc)
			local p = {position=pos}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "house"
			table.insert(player.quarry, {g=obj.getGUID(),p=pos})
			pauseMe()
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		end
		for i=5,8 do
			local p = {position=player.pool[i].p}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "house"
			player.pool[i].g = obj.getGUID()
			pauseMe()
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		end
		local dial = getObjectFromGUID(C.action_dials[pcol])
		dial.call("disableDialButtons")
		dial.call("showMe")
	end

	--setup for next game stage
	if GD.game.auction_characters then

		--TODO: setup for auction

	else
		--setup for character card selection
		for _,char in ipairs(C.characters) do
			getObjectFromGUID(char.g).setLock(false)
		end
		GD.game.stage = "select_starting_characters"
		GD.game.characters_selected = 0
		broadcastToAll(GD.game.current_player_color.." player select a character card then continue clockwise around table")
		local p = {dormant = false,done = false,undo = false,}
		p.help_text = "Select a character card then click Done."
		for _,pcol in ipairs(GD.game.player_order) do
			p.active = (pcol == GD.game.current_player_color)
			local player_board = getObjectFromGUID(C.player_boards[pcol])
			player_board.call("setState",p)
		end
	end
	if env.test.trace then log("coroFillPlayerBoards(): EXIT") end
	return 1
end

--[[ *****************************
Set the locked state of a player's houses in the build pool
********************************]]
function setPlayerPoolLock(pcol, locked)
	locked = locked or false
	for _,e in ipairs(GD.game.players[pcol].pool) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of a player's unplaced palaces
********************************]]
function setPlayerPalacesLock(pcol, locked)
	locked = locked or false
	for _,e in ipairs(GD.game.players[pcol].palaces) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Handle dropping things on the main board.
House and palace drops off board are snapped back.
TODO: disable DEVELOPMENT stuff
********************************]]
function onObjectDrop(pcol, obj)
	if env.test.trace then log("onObjectDrop(): pcol "..pcol..", obj "..obj.getGUID()) end
	if not(GD.game.stage) then return end
	local type = obj.memo
	obj.setVelocity(Vector(0,0,0)) --in case player "throws it"
	if type == "character" then
		handleCharacterDrop(pcol, obj)
	elseif type == "palace" or type == "house" then
		local pos = obj.getPosition()
		local board = getObjectFromGUID(C.board_guid)
		local center = board.getBounds()["center"]
	  local size = board.getBounds()["size"]
		local snapback = false
		if pcol ~= GD.game.current_player_color then snapback = true
		elseif obj.getName() ~= pcol then snapback = true
	  elseif pos.x > center.x + (size.x/2) then snapback = true
	  elseif pos.x < center.x - (size.x/2) then snapback = true
	  elseif pos.z > center.z + (size.z/2) then snapback = true
	  elseif pos.z < center.z - (size.z/2) then snapback = true
		end
		if snapback then
			--TODO: consider use an array of GD.snaps for placed objects?  Use player board home loc if not in that list?
			obj.setPosition(getPlayerBoardLocation(obj))
			obj.setRotation(getObjectFromGUID(C.player_boards[obj.getName()]).getRotation())
			return
		end
		if type == "house" then
			handleHouseDrop(pcol, obj)
		else
			handlePalaceDrop(pcol, obj)
		end
	else
		log("WARN: onObjectDrop() unknown object "..obj.getGUID())
		return
	end
end

--[[ *****************************
Process a dropped character card.
Result depends on game stage.
TODO: handle during player turn
********************************]]
function handleCharacterDrop(pcol, obj)
	if env.test.trace then log("handleCharacterDrop()") end
	local char_id = getCharacterId(obj.getGUID())
	local board = getObjectFromGUID(C.board_guid)
	if GD.game.stage == "select_starting_characters" then
		if pcol ~= GD.game.current_player_color then --ignore non active player
			obj.setPosition(C.characters[char_id].bank_pos)
			obj.setRotation(board.getRotation())
			return
		end
		if #GD.game.players[pcol].pending_actions > 0 then --only select one
			broadcastToColor("Character already selected", pcol)
			obj.setPosition(C.characters[char_id].bank_pos)
			obj.setRotation(board.getRotation())
			return
		end
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		local pos = player_board.positionToWorld(C.player_board_character_location)
		local rot = player_board.getRotation()
		obj.setPositionSmooth(pos, false, true)
		obj.setRotation(rot)
		Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		local action = {
			key = "select_starting_character",
			player_color = pcol,
			character_id = char_id,
			undo = {
				guid = obj.getGUID(),
				snapback = {pos=C.characters[char_id].bank_pos, rot=board.getRotation()},
			},
		}
		table.insert(GD.game.players[pcol].pending_actions, action)
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=true,undo=true})
	elseif GD.game.stage == "player_turn" then

		--TODO: implement this

	end
end

--[[ *****************************
--TODO: thinking about this,
********************************]]
function isObjectPlaced(guid)
	return false
end

--[[ *****************************
TODO: need this in a fn? Used only once?
********************************]]
function isVillageFull(node)
	if GD.game.player_count == 2 and #node.houses == 1 then return true
	elseif GD.game.player_count > 2 and #node.houses == 2 then return true end
	return false
end

--[[ *****************************
Process a dropped house.
Result depends on game stage.
********************************]]
function handleHouseDrop(pcol, obj)
	if env.test.trace then log("handleHouseDrop()") end
	local board = getObjectFromGUID(C.board_guid)
	local color = obj.getName()
	local function snapBack()
		if isObjectPlaced(obj.getGUID()) then
			log("TODO: Handle placed obj snapback ***")
			--TODO: use array of GD.snaps for placed objects?
		else
			obj.setPosition(getPlayerBoardLocation(obj))
			obj.setRotation(getObjectFromGUID(C.player_boards[color]).getRotation())
		end
		return
	end
	local pos = obj.getPosition()
	pos.y = 0
	local index = closestNode(pos)
	log("nearest is id "..tostring(index)..", type "..GD.network[index].type..", name "..GD.network[index].name)
	if index < 1 then
		snapBack(obj)
		return
	end
	if GD.game.stage == "initial_placement" then
		local node = GD.network[index]
		if node.type == "village" then
			if isVillageFull(node) then
				snapBack()
				return
			end
			table.insert(node.houses,{g=obj.getGUID(),c=obj.getName()})
			--TODO: set position of house relative to village center, remove HACK:
			local pos_1 = node.center - VILLAGE_OFFSET
			local pos_2 = node.center + VILLAGE_OFFSET
			local pos = board.positionToWorld(pos_1)
			if #node.houses == 1 then pos = board.positionToWorld(pos_2) end
			pos.y = 1.5
			obj.setRotation(board.getRotation())
			obj.setPosition(pos)
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
			--add a pending action for this house placement
			local action = {
				key = "initial_placement",
				player_color = pcol,
				guid = obj.getGUID(),
				undo = {
					node_index = index,
					guid = obj.getGUID(),
					snapback = {pos=getPlayerBoardLocation(obj),rot=getObjectFromGUID(C.player_boards[pcol]).getRotation()}
				},
			}
			--show done and undo buttons
			table.insert(GD.game.players[pcol].pending_actions, action)
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=true,undo=true})

		elseif node.type == "city" then
			snapBack()
			return
		else
			snapBack()
			return
		end
	else

		log("TODO: handle house drop during play ***")

	end
end

--[[ *****************************
Remove an object from player board data.
********************************]]
function removeFromPlayerBoard(obj)
	if env.test.trace then log("removeFromPlayerBoard()") end
	local player = GD.game.players[obj.getName()]
	assert(player,"ERROR: removeFromPlayerBoard() could not locate player data")
	if obj.memo == "palace" then
		for i,data in ipairs(player.palaces) do
			if data.g == obj.getGUID() then
				-- table.remove(player.palaces, i)
				player.palaces[i].g = nil
				return
			end
		end
	else
		for i,data in ipairs(player.pool) do
			if data.g == obj.getGUID() then
				-- table.remove(player.pool, i)
				player.pool[i].g = nil
				return
			end
		end
	end
	log("WARN: could not find object "..obj.getGUID().." in "..obj.getName().." data")
end

--[[ *****************************
Process a dropped palace.
********************************]]
function handlePalaceDrop(pcol, obj)
	log("TODO: handlePalaceDrop(guid) ****")
end

--[[ *****************************
Return the snap back playerboard location for an object.
Playerboard determined from object name(color))
********************************]]
function getPlayerBoardLocation(obj)
	local color = obj.getName()
	for _,d in ipairs(GD.game.players[color].pool) do
		if d.g == obj.getGUID() then return d.p end
	end
	for _,d in ipairs(GD.game.players[color].palaces) do
		if d.g == obj.getGUID() then return d.p end
	end
	for _,d in ipairs(GD.game.players[color].quarry) do
		if d.g == obj.getGUID() then return d.p end
	end
end

--[[ *****************************
Update game player order sorted by current player character IDs
TODO: actually update and update UI
********************************]]
function updateTurnOrder()
	if env.test.trace then log("updateTurnOrder()") end
	--sort player order by character ID
	local new_order = nil
	for pcol,pdata in pairs(GD.game.players) do
		if new_order == nil then
			new_order = {pcol}
		else
			for i,player_color in ipairs(new_order) do
				if pdata.character_id < GD.game.players[player_color].character_id then
					table.insert(new_order, i, pcol)
					break
				elseif i == #new_order then
					table.insert(new_order, pcol)
					break
				end
			end
		end
	end
	GD.game.player_order = simpleDeepCopy(new_order)
	if env.test.debug then
		log("New player order sorted by char ID:")
		log(GD.game.player_order)
	end

	--TODO: update any respective UI stuff
	log("TODO: update player turn order UI")
	for i,pcol in ipairs(GD.game.player_order) do
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		player_board.call("setState",{turn_order=i})
	end

end

--[[ *****************************
Set the next active player.
Clockwise from current player if selecting initial characters.
Uses order sorted by character ID in other stages of play.
Returns color of current player
********************************]]
function setNextPlayer(first)
	first = first or false
	if env.test.trace then log("setNextPlayer()") end
	local old_color = GD.game.current_player_color
	if first then
		GD.game.current_player = 1
	elseif GD.game.stage == "select_starting_characters" then
		local next = GD.game.current_player + 1
		if next > #GD.game.player_order then next = 1 end
		GD.game.current_player = next
	else
		if GD.game.stage == "initial_placement" then
			--find first player in order that needs to place this round of placements
			for i,pcol in ipairs(GD.game.player_order) do
				if GD.game.players[pcol].init_placements == GD.game.init_placement then
					GD.game.current_player = i
					break
				end
			end
		else
			--find first player in order that has actions
			for i,pcol in ipairs(GD.game.player_order) do
				if GD.game.players[pcol].has_actions then
					GD.game.current_player = i
					break
				end
			end
		end
	end
	GD.game.current_player_color = GD.game.player_order[GD.game.current_player]
	broadcastToAll("Current player now "..GD.game.current_player_color)
	if env.test.players and env.test.auto_switch then
		if old_color != GD.game.current_player_color then
			Player[old_color].changeColor(GD.game.current_player_color)
		end
	end
	return GD.game.current_player_color
end

--[[ *****************************
Locate the closest network node to the position.
TODO: be smarter about city radius vs village radius.
As is the radius is equal so dropping in a city edge
might detect as a nearby village.  Minor thing.
********************************]]
function closestNode(pos)
	if env.test.trace then log("closestNode()") end
	local board = getObjectFromGUID(C.board_guid)
	local nearest_node = -1
	local shortest_dist = nil
	for i,node in ipairs(GD.network) do
		local dist = Vector.sqrDistance(pos, board.positionToWorld(node.center))
		if shortest_dist then
			if dist < shortest_dist then
				shortest_dist = dist
				nearest_node = i
			end
		else
			shortest_dist = dist
			nearest_node = i
		end
	end
	return nearest_node
end

--[[ *****************************
Lookup and return the id for a character card guid
Returns -1 if not found (log an error)
********************************]]
function getCharacterId(guid)
	for id,char in ipairs(C.characters) do
		if char.g == guid then
			return id
		end
	end
	log("ERROR: getCharacterId(): no character card found for guid "..tostring(guid))
	return -1
end

--[[ *****************************
Set or clear selected player actions
Called from player dial.
params:
	player_color - color of player
	command: 'confirm' or 'clear'
	actions: a list of selected actions
TODO: implement setting the actions in player data
********************************]]
function setPlayerActions(params)
	if env.test.trace then log("setPlayerActions()") end
	if env.test.debug then log(params) end
	local pcol = params.player_color
	if params.command == "confirm" then
		GD.game.players[pcol].actions_set = true

		--TODO: set actions in player data, update UI etc.

		--check to see if all players have set actions
		local all_set = true
		for _,pdata in pairs(GD.game.players) do
			if not(pdata.actions_set) then all_set = false end
		end
		if all_set then
			broadcastToAll("All players have set actions, starting player turns")
			for _,pcol in ipairs(GD.game.player_order) do
				local dial = getObjectFromGUID(C.action_dials[pcol])
				dial.call("lockActionSelections")
			end
			GD.game.stage = "player_turns"
			startPlayerTurn(setNextPlayer(FIRST))
		end
	elseif params.command == "clear" then
		GD.game.players[pcol].actions_set = false
	else
		log("ERROR: setPlayerActions() unknown command "..tostring(params.command))
	end
end

--[[ *****************************
Start a player's action turn.
********************************]]
function startPlayerTurn(pcol)
	if env.test.trace then log("startPlayerTurn()") end
	local dial = getObjectFromGUID(C.action_dials[pcol])
	local params = {state="player_turn"}
	if GD.game.players[pcol].extra_actions then
		params.extra_actions = true
	end
	dial.call("setState",params)

	--TODO: implement This

	--TODO: execute any per turn actions (action chit, 1 coin)
	--TODO: set any character bonus/discounts (palace disc, move for free, scoring bonus)
	--TODO: assign any free action (free build/move)

	--TODO: enable UI for actions

end

--[[ *****************************
Handler for button clicks on player board
********************************]]
function playerBoardClick(player, btn, id)
	if env.test.trace then log("playerBoardClick(): "..player.color..", id = "..id) end
	local action = Split(id,'_')[1]
	if action == "done" then
		playerDone(player.color)
	elseif action == "undo" then
		playerUndo(player.color)
	elseif action == "extraAction" then
		extraAction(player.color)
	else
		log("ERROR: playerBoardClick(): unknown action id")
		return
	end
end

--[[ *****************************
TODO: document
--For all entries in the player's pending action list:
	-- POP an entry off the LIFO stack
	-- finallize the pendign action, update data structures etc.
	-- remove the entry from the LIFO stack
	-- if more entries, repeat
********************************]]
function playerDone(pcol)
	if env.test.trace then log("playerDone(): "..pcol) end
	if #GD.game.players[pcol].pending_actions == 0 then
		log("WARN: playerDone() no actions to finaalize for player "..pcol)
		return
	end
	while #GD.game.players[pcol].pending_actions > 0 do
		local index = #GD.game.players[pcol].pending_actions
		local action = GD.game.players[pcol].pending_actions[index]
		if action.key == "select_starting_character" then
			setStartingCharacter(action)
		elseif action.key == "initial_placement" then
			setInitialPlacement(action)
		else
			log("ERROR: playerDone() unknown action key "..tostring(action.key))
			return
		end
		table.remove(GD.game.players[pcol].pending_actions, index)
	end
end

--[[ *****************************
Finalize a starting character select action
********************************]]
function setStartingCharacter(action)
	if env.test.trace then log("setStartingCharacter()") end
	if GD.game.stage ~= "select_starting_characters" then
		log(("ERROR: setStartingCharacter() invalid game stage")) --shouldn't happen
		return
	end
	local pcol = action.player_color
	GD.game.players[pcol].character_id = action.character_id
	GD.game.characters_selected = GD.game.characters_selected + 1
	if GD.game.characters_selected == GD.game.player_count then
		--All players selected a character, now setup game for initial house placement
		updateTurnOrder()
		setNextPlayer(FIRST)
		GD.game.stage = "initial_placement"
		broadcastToAll("Begin initial house placement")
		local p ={done=false,undo=false}
		p.help_text = "Place one starting house from Build Pool.\nOnly place on Villages."
		for pcol,pdata in pairs(GD.game.players) do
			for _,e in ipairs(pdata.pool) do
				if e.g then getObjectFromGUID(e.g).setLock(false) end
			end
			GD.game.players[pcol].init_placements = 4
			p.active = (pcol == GD.game.current_player_color)
			getObjectFromGUID(C.player_boards[pcol]).call("setState",p)
		end
		GD.game.players_init_placed = 0
		GD.game.init_placement = 4
	else
		getObjectFromGUID(C.player_boards[pcol]).call("setState")
		getObjectFromGUID(C.player_boards[setNextPlayer()]).call("setState", {active=true})
	end
end

--[[ *****************************
Finalize an initial house placement action
********************************]]
function setInitialPlacement(action)
	if env.test.trace then log("setInitialPlacement()") end
	if GD.game.stage ~= "initial_placement" then
		log(("ERROR: setInitialPlacement() invalid game stage")) --shouldn't happen
		return
	end
	local obj = getObjectFromGUID(action.guid)
	removeFromPlayerBoard(obj)
	GD.game.players[action.player_color].init_placements = GD.game.players[action.player_color].init_placements - 1
	GD.game.players_init_placed = GD.game.players_init_placed + 1
	if GD.game.players_init_placed == GD.game.player_count then
		--reset for next round of placement until all 4 placed
		GD.game.players_init_placed = 0
		GD.game.init_placement = GD.game.init_placement - 1
	end
	if GD.game.init_placement == 0 then
		--End of placement, setup for first round of action selection
		GD.game.stage = "select_actions"
		for pcol,pdata in pairs(GD.game.players) do
			startingQuarry(pcol)
			local dial = getObjectFromGUID(C.action_dials[pcol])
			dial.call("setState",{state="select_actions"})
			GD.game.players[pcol].has_actions = true --TODO: move this to "confirm" button?
			local txt = "Secretly choose turn actions and confirm with Done\n"
			txt = txt .. "Player turns will begin once all have confirmed\n"
			txt = txt .. "and until then selections can be modified."
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{active=true,done=false,undo=false,help_text=txt})
		end
		broadcastToAll("Begin action selection")
		return
	else
		getObjectFromGUID(C.player_boards[action.player_color]).call("setState")
		getObjectFromGUID(C.player_boards[setNextPlayer()]).call("setState",{active=true})
	end
end

--[[ *****************************
TODO: document
--POP an entry off the player's LIFO pending actions stack
--undo any placements, action effects, etc.
--remove the pending action entry
--disable player's done button
--if no remaining pending actinos, disable player's undo button
********************************]]
function playerUndo(pcol)
	if env.test.trace then log("playerUndo(): "..pcol) end
	local index = #GD.game.players[pcol].pending_actions
	if index == 0 then return end
	local action = GD.game.players[pcol].pending_actions[index]

	if action.key == "select_starting_character" then
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
	elseif action.key == "initial_placement" then
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
		local node = GD.network[action.undo.node_index]
		if node.houses[1] and node.houses[1].g == action.guid then
			node.houses[1] = nil
		elseif node.houses[2] and node.houses[2].g == action.guid then
			node.houses[2] = nil
		else
			log("WARN: playerUndo() unable to clear house "..action.guid.."from network node")
		end
	else
		log("ERROR: playerDone() unknown action key "..tostring(action.key))
		return
	end
	--remove entry and update player board UI
	table.remove(GD.game.players[pcol].pending_actions, index)
	local player_board = getObjectFromGUID(C.player_boards[action.player_color])
	p={done=false}
	if #GD.game.players[pcol].pending_actions == 0 then
		p.undo = false
	end
	player_board.call("setState",p)
end

--[[ *****************************
TODO: document
********************************]]
function extraAction(pcol)
	if env.test.trace then log("extraAction(): "..pcol) end

end

--[[ *****************************
TODO: document
********************************]]
function startingQuarry(pcol)
	if env.test.trace then log("startingQuarry(): "..pcol) end
	local quarry = GD.game.players[pcol].quarry
	local pool = GD.game.players[pcol].pool
	for i=1,6 do
		local index = 16 - i + 1
		local house = getObjectFromGUID(quarry[index].g)
		assert(house,"ERROR: startingQuarry() nil quarry house")
		house.setPosition(pool[i].p)
		quarry[index].g = nil
		pool[i].g = house.getGUID()
	end
end

--[[///////////////////////////////////////////////////////////]]
--[[/////////////// DEVELOPMENTAL STUFF ///////////////////////]]
--[[///////////////////////////////////////////////////////////]]


function testCityHouses(pcol, city_name)
	log("put selected houses in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(city_name.." center is "..tostring(center))
	local color_indexes = {Yellow = 0,Red = 0,Green = 0,Blue = 0,Purple = 0,}
	for _,o in ipairs(stuff) do
		local color = o.getName()
		color_indexes[color] = color_indexes[color] + 1
		local offset = Vector(C.city_house_offsets[color][color_indexes[color]].o)
		log("placing "..color.." object "..o.getGUID().." with offset "..tostring(color_indexes[color])..": "..tostring(offset))
		local pos = center - offset
		local rot = Vector(C.city_house_offsets[color][color_indexes[color]].r)
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function testCityPalaces(pcol, city_name)
	log("put selected houses in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	if #stuff > 7 then
		log("Only 7 palaces max allowed in a city")
		return
	end
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(center)
	for index,o in ipairs(stuff) do
		local offset = Vector(0,0,0)
		if index < 7 then offset = C.city_palace_offsets[index] end
		log("putting object "..o.getGUID().." in loc "..tostring(index)..", at offset "..tostring(offset))
		local pos = center - offset
		local rot = board.getRotation()
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function testCityPawns(pcol, city_name)
	log("put selected pawns in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	if #stuff > 5 then
		log("Only 5 pawns max allowed in a city")
		return
	end
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(center)
	for index,o in ipairs(stuff) do
		local offset = Vector(C.city_pawn_offsets[index])
		log("putting object "..o.getGUID().." in loc "..tostring(index)..", at offset "..tostring(offset))
		local pos = center - offset
		local rot = Vector(0,90,0)
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function getWorldPos(pcol)
	log("Getting positions of selected objects relative to world")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	local s=""
	for i,o in ipairs(stuff) do
    local p = o.getPosition()
		local t = tostring(i)..': '..o.getGUID()..': '..tostring(p)
		log(t)
		s = s .. t .. '\n'
	end
	if s ~= "" then
    Notes.setNotes(s)
  end
end

function getLTB(pcol)
  log("Getting positions of selected objects relative to board")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	--local board = getObjectFromGUID(C.board_guid)
	local board = getObjectFromGUID(C.board_guid)
  local s = ""
  for i,o in ipairs(stuff) do
    log("Processing object #"..tostring(i)..": "..o.getGUID())
    local p = board.positionToLocal(o.getPosition())
    -- local r = Vector(0,180,0)
		-- City house positions
		-- local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},r={'..r.x..','..r.y..','..r.z..'}},'
		local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},r={0,180,0}},'
    log(t)
    s = s .. t .. '\n'
  end
  if s ~= "" then
    Notes.setNotes(s)
  end
end

function getLTPB(pcol)
	log("Getting positions of selected objects relative to player board")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	local board = getObjectFromGUID(C.player_boards[pcol].g)
  local s = ""
  for i,o in ipairs(stuff) do
    log("Processing object #"..tostring(i)..": "..o.getGUID())
    local p = board.positionToLocal(o.getPosition())
		local r = board.getRotation()
		local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},},'
    log(t)
    s = s .. t .. '\n'
  end
  if s ~= "" then
    Notes.setNotes(s)
  end

end

function getOffsets()
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers.Agra
	center.y = 0
	log(center)
	local s = ""
	for i,loc in ipairs(C.ltb) do
		local pos = Vector(loc.p)
		pos.y = 0
		local o = center - pos
		-- local r = Vector(loc.r)
		-- local t = '{o={'..o.x..','..o.y..','..o.z..'},r={'..r.x..','..r.y..','..r.z..'}},'
		local t = '{o={'..o.x..','..o.y..','..o.z..'},r={0,180,0}}'
		log(t)
		s = s .. t .. '\n'
	end
	if s ~= "" then
		Notes.setNotes(s)
	end
end

require("tts-lib/utils")
require("tts-maharaja/Constants")
require("tts-maharaja/Network")
