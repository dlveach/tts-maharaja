-- #include tts-maharaja/Global
--[[///////////////////////////////////////////////////////////////////////////////////////////////

	Maharaja
		TODO: credits

  --TODO:
    - lots of stuff
		-- load/save restore
		-- (opt) starting character auction
		-- UI and implementation for Governor track
		-- Yogi extra action functionality
		-- turn execution, detection and update dial actions
		-- move architect route detection, display
		-- respect verbosity setting

		probablyi a bunch more I'm not thinking of!z

///////////////////////////////////////////////////////////////////////////////////////////////////]]

--[[==========================================================================================
TTS mod for Maharaja

--TODO: documentation

	--TODO: stuff to do
	-- convert playerboards to tile with jpeg vs token with png.  Takes too long to load.
	-- get save load working

	-- lots of implementation for feature complete

	--dedupe and refactor code for updating/setting player character bonuses.  Got very messy after`
		adding character exchange action.  Probably lots of bugs.

	--BUG character free action does not show in dial UI until player turn starts.  Should be in action selection too.

==========================================================================================]]

env = {}
env.test = {}
env.test.trace = true
env.test.debug = true
env.test.in_dev = false
env.test.force_fresh_save = false
env.test.save_positions = true
env.test.auto_switch = true
-- env.test.players = {"Blue","Red","Yellow","Purple","Green",}
-- env.test.players = {"Yellow","Red","Blue","Purple",}
-- env.test.players = {"Yellow","Purple",}
-- env.test.players = {"Green","Red",}
env.test.players = {"Green","Red","Blue"}

env.game = {}
env.game.fill_delay = 2
env.game.use_help = true

GD = {}

--[[/////////////// Load Save /////////////////]]

--[[ *****************************
TTS Game Load
********************************]]
function onLoad(saved_data)
	if env.test.force_fresh_save then saved_data = "" end
	--Initialize stuff
	if not(env.test.in_dev) then
		getObjectFromGUID(C.board_guid).interactable = false
		getObjectFromGUID(C.palace_object_guid).setInvisibleTo(Color.list)
		getObjectFromGUID(C.house_object_guid).setInvisibleTo(Color.list)
	end
	UI.setAttribute("penalty_dialog_pnl","visibility","Pink")
	UI.setAttribute("penalty_dialog_pnl","active","true")
	UI.setAttribute("replace_done_pnl","visibility","Pink")
	UI.setAttribute("replace_undo_pnl","visibility","Pink")
	UI.setAttribute("replace_character_pnl","active",false)
	--Reload saved data or if fresh load initialize everything
	if (saved_data ~= "") then
    log("onLoad(): load with saved data")
		log("saved data:")
		log(saved_data)
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
		if GD.game.stage ~= "setup" then  --HACK: don't show dialog if not restoring an active game.
			UI.setAttribute("restore_dialog_pnl", "active", true)
		end
    Wait.frames(function() restoreGameState() end, 10)
  else
		log("onLoad(): load with fresh state")
		GD.state = {}
		GD.state.global_UI = {}
		GD.state.board_UI = {}
		GD.game = {}
		GD.game.stage = "setup"
		GD.game.round = 1
		GD.game.city_scores = {}
		for name,_ in pairs(C.cities) do
			GD.game.city_scores[name] = {}
		end
		GD.env = {}
		GD.env.use_auction = false
		UI_setAttribute("opt_use_auction","isOn",GD.env.use_auction)
		GD.env.verbose = true
		UI_setAttribute("opt_verbose","isOn",GD.env.verbose)
		for _,g in pairs(C.player_pawns) do
			getObjectFromGUID(g).setLock(true)
		end
		GD.game.status_visibility = false
		UI_setAttribute("status_info","visibility",GD.game.status_visibility)
		UI_setAttribute("startPanel","active",true)
	end
end

--[[ *****************************
HACK: reload an object's XML UI
********************************]]
function reloadUI(guid)
	if env.test.trace then log("reloadUI() guid: "..tostring(guid)) end
	if guid then
		local obj = getObjectFromGUID(guid)
		if obj ~= nil then
			log("reloading object UI for guid "..tostring(guid))
			obj.UI.setXml(obj.UI.getXml())
		else
			log("***WARN: reloadUI() unable to get object for "..tostring(guid))
		end
	else
		log("reloading global UI")
		UI.setXml(UI.getXml())
	end
end

--[[ *****************************
Save game state
********************************]]
function onSave()
	local saved_data = ""
  if not(env.test.force_fresh_save) then
		saved_data = JSON.encode(GD)
  end
  return saved_data
end

--[[ *****************************
Restore the game state.
TODO: implement
********************************]]
function restoreGameState()
	if env.test.trace then log("restoreGameState()") end
	log("TESTING: restoreGameState()")
	if GD.game.stage == "setup" then
		log("TODO: any game restore in setup stage? <----------------")
	else
		log("TESTING: Restoring game state in game play stages <-------------")
		setupStatusPanel()
		updateGovernorTrack()
		updateStatusPanel()
		for pcol,player in pairs(GD.game.players) do
			if player.turn_actions ~= nil and #player.turn_actions > 1 then
				updateDialUI(pcol)
			end
		end
	end

	Wait.time(function()
		--[[ replay saved global UI setAttributes --]]
		if env.test.debug then log("replay saved global UI setAttributes") end
	  for key,value in pairs(GD.state.global_UI) do
	    local id = Split(key, '|')[1]
	    local field = Split(key, '|')[2]
	    local success = UI.setAttribute(id, field, value)
	    if not(success) and env.test.debug then
	      log("ERROR: restoreGameState(): Unable to setAttribute for global UI "..field.." on id "..id.." to "..tostring(value))
	    end
	  end

		--[[ replay saved board UI setAttributes --]]
	  if env.test.debug then log("replay saved board UI setAttributes") end
	  local board = getObjectFromGUID(C.board_guid)
	  for key,value in pairs(GD.state.board_UI) do
	    local id = Split(key, '|')[1]
	    local field = Split(key, '|')[2]
			local success = board.UI.setAttribute(id, field, value)
	    if not(success) and env.test.debug then
	      log("ERROR: restoreGameState(): Unable to setAttribute for board UI "..field.." on id "..id.." to "..tostring(value))
	    end
	  end
		UI.setAttribute("status_info","visibility",GD.game.status_visibility)
		UI.setAttribute("restore_dialog_pnl","active",false)
	end, 1)
end

--[[ ******************************
Wrapper function for global UI attributes.
Saves attribute update to be replayed on restore.
TODO: convert calls to use
*********************************]]
function UI_setAttribute(id, field, value)
  if env.test.trace2 then log("UI_setAttribute()") end
  assert(type(id) == "string", "UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "UI_setAttribute(): field must be a string")
  assert(value or value==false, "UI_setAttribute(): value missing")
  GD.state.global_UI[id.."|"..field] = value
  UI.setAttribute(id, field, value)
end

--[[ ******************************
Wrapper function for saving board UI attributes.
Saves attribute update to be replayed on restore.
TODO: convert calls to use
*********************************]]
function board_UI_setAttribute(id, field, value)
	if env.test.trace2 then log("board_UI_setAttribute()") end
	assert(type(id) == "string", "board_UI_setAttribute(): id must be a string")
	assert(type(field) == "string", "board_UI_setAttribute(): field must be a string")
	assert(value or value==false, "board_UI_setAttribute(): value missing")
	GD.state.board_UI[id.."|"..field] = value
	return getObjectFromGUID(C.board_guid).UI.setAttribute(id, field, value)
end

--[[/////////////// Event handlers /////////////////]]

--[[ *****************************
TODO: Thinking about these
********************************]]
function mouseOverCity(arg)
	log("mouse over")
	log(arg)
end
function mouseExitCity(arg)
	log("mouse exit")
	log(arg)
end
function mouseClickCity(arg)
	log("mouse click city")
	log(arg)
end

--[[ *****************************
Setup: Handler for start game options
********************************]]
function startOptionsBtn(player, value, id)
	if env.test.trace then log("startGameBtn() "..player.color..", "..id..": "..tostring(value)) end
	local setting = (value == 'True')
	UI_setAttribute(id, "isOn", setting)
	if id == "opt_use_auction" then
		broadcastToAll("Sorry, not yet imlemented")		--TODO: remove this when imlpemented
		UI_setAttribute(id, "isOn", false)
		return
		-- GD.env.use_auction = setting
	elseif id == "opt_verbose" then
		GD.env.verbose = setting
	else
		log("*** ERROR: startOptionsBtn() unknown id "..tostring(id))
	end
end

--[[ *****************************
Setup: A player clicked start game.
********************************]]
function startGameBtn(player, btn, id)
	if env.test.trace then log("startGameBtn() "..player.color) end
	if not(env.test.players) and #getSeatedPlayers() < 2 then
		broadcastToAll("At least 2 players needed to play")
		return
	end
	UI_setAttribute("startPanel","active",false)
	Wait.frames(function() startGame() end, 10)
end

--[[ *****************************
Player clicked a row on the Governor track
********************************]]
function governorClick(player, btn, id)
	if env.test.trace then log("governorClick() "..player.color..", id: "..tostring(id)) end
	if player.color ~= GD.game.current_player_color then return end
	if GD.game.players[player.color].governor_clicked then return end --guard double clicks
	GD.game.players[player.color].governor_clicked = true
	local track = GD.game.governor_track
	-- build a pending action and store current order in undo
	local row_clicked = tonumber(Split(id,'_')[2])
	local pending_action = {
		key = "track",
		player_color = pcol,	--TODO: need this?
		row_clicked = row_clicked,  --TODO: need this?
		undo = {
			restore_list = simpleDeepCopy(track),
		}
	}
	setActionIndex(player.color, pending_action)
	if pending_action.action_index < 1 then
		--shouldn't happen, for debugging
		log("***ERROR: governorClick() could not locate a turn action")
	else
		updateTurnAction(player.color, pending_action)
		table.insert(GD.game.players[player.color].pending_actions, pending_action)
		--find the data table index for the clicked row
		local index = -1
		for i=1,7 do
			if track[i].track_row == row_clicked then
				index = i
				break
			end
		end
		assert(index > 0,"***ERROR: bad track index")
		-- move down two (or one or zero) spots in track table, shift others up
		local temp = simpleDeepCopy(track[index])
		temp.track_row = temp.track_row - 2
		if temp.track_row < 1 then temp.track_row = 1 end
		temp.UI_row = temp.UI_row + 2
		if temp.UI_row > 7 then temp.UI_row = 7 end
		local new_index = index - 2
		if new_index < 1 then new_index = 1 end
		for i = index, new_index+1, -1 do
			track[i] = simpleDeepCopy(track[i-1])
			track[i].track_row = track[i-1].track_row + 1
			track[i].UI_row = track[i-1].UI_row - 1
		end
		track[new_index] = temp
		updateGovernorTrack()
		updateStatusPanel()
		governorButtons(false)
		updateDialUI(player.color)
		getObjectFromGUID(C.player_boards[player.color]).call("setState",{undo=true})
	end
end

--[[ *****************************
Handler for button clicks on player board
********************************]]
function playerBoardClick(player, btn, id)
	if env.test.trace then log("playerBoardClick(): "..player.color..", id = "..id) end
	local action = Split(id,'_')[1]
	if action == "done" then
		playerDone(player.color)
	elseif action == "undo" then
		playerUndo(player.color)
	elseif action == "extraAction" then
		extraAction(player.color)
	else
		log("*** ERROR: playerBoardClick(): unknown action id")
		return
	end
end

--[[ *****************************
Toggle the city status display for the player who clicked.
********************************]]
function statusClick(player, btn, id)
	if env.test.trace then log("statusClick() id: "..tostring(id)) end
	-- if env.test.debug then log(GD.game.status_visibility) end
	local players = Split(GD.game.status_visibility,'|')
	local index = indexOf(players, player.color)
	if index > 0 then
		table.remove(players,index)
	else
		table.insert(players,player.color)
	end
	GD.game.status_visibility = ""
	for _,pcol in ipairs(players) do
		if GD.game.status_visibility == "" then
			GD.game.status_visibility = pcol
		else
			GD.game.status_visibility = GD.game.status_visibility .."|"..pcol
		end
	end
	-- if env.test.debug then log("Setting vis to "..GD.game.status_visibility) end
	UI_setAttribute("status_info","visibility",GD.game.status_visibility)
end

--[[ *****************************
Handle dropping things on the main board.
House and palace drops off board are snapped back.
TODO: disable DEVELOPMENT stuff
********************************]]
function onObjectDrop(pcol, obj)
	if env.test.trace then log("onObjectDrop(): pcol "..pcol..", obj "..obj.getGUID()) end
	--/// DEV ///
	if env.test.save_positions then
		str = "Global: "
		str = str .. tostring(obj.getPosition())
		str = str .. "\nBoard: "
		str = str .. tostring(getObjectFromGUID(C.board_guid).positionToLocal(obj.getPosition()))
		Notes.setNotes(str)
	end
	--/// END DEV ///
	if GD.game.stage == "setup" then return end
	local type = obj.memo
	obj.setVelocity(Vector(0,0,0)) --in case player "throws it"
	if type == "character" then
		characterDrop(pcol, obj)
	elseif type == "palace" or type == "house" then
		local pos = obj.getPosition()
		local board = getObjectFromGUID(C.board_guid)
		local center = board.getBounds()["center"]
	  local size = board.getBounds()["size"]
		local snapback = false
		if pcol ~= GD.game.current_player_color then snapback = true
		elseif obj.getName() ~= pcol then snapback = true
	  elseif pos.x > center.x + (size.x/2) then snapback = true
	  elseif pos.x < center.x - (size.x/2) then snapback = true
	  elseif pos.z > center.z + (size.z/2) then snapback = true
	  elseif pos.z < center.z - (size.z/2) then snapback = true
		end
		if snapback then
			--TODO: consider use an array of GD.snaps for placed objects?  Use player board home loc if not in that list?
			obj.setPosition(getPlayerBoardLocation(obj))
			obj.setRotation(getObjectFromGUID(C.player_boards[obj.getName()]).getRotation())
			return
		end
		if type == "house" then
			houseDrop(pcol, obj)
		else
			palaceDrop(pcol, obj)
		end
	elseif type == "architect" then
		architectDrop(pcol, obj)
	else
		log("*** WARN: onObjectDrop() unknown object "..obj.getGUID())
		return
	end
end

--[[ ********* TODO **************
--TODO: implement and document
********************************]]
function extraActionClick(obj, pcol, rclick)
	log("extraActionClick() "..obj.getName()..", "..pcol..", "..tostring(rclick))
	log("TODO: extraActionClick()  <--------------------------")
end

--[[ *****************************
End turn with required actions penalty dialog.
If 'Cancel', return to turn actions.
if 'OK' then set failed status on remaining actions and end turn.
********************************]]
function penaltyDialogBtn(player, btn, id)
	log("penaltyDialogBtn() "..player.color..", "..tostring(id))
	if player.color ~= GD.game.current_player_color then return end
	local command = Split(id,'_')[3]
	if env.test.debug then log("action is "..tostring(command)) end
	if command == "ok" then
		for _,action in ipairs(GD.game.players[player.color].turn_actions) do
			if not(action.free) and action.status ~= "Done" then action.status = "Failed" end
		end
		updateDialUI(player.color)
		playerDone(player.color)
		-- endTurn(player.color)
	elseif command == "cancel" then
		--noop
	else
		log("***ERROR: unknown command")
		return
	end
	UI_setAttribute("penalty_dialog_pnl","visibility","Pink")
end

--[[ *****************************
Handler for modify button click (back of dial).
Flip dial face up and set state back to action selection.
Enable done button on player board.
********************************]]
function dialModifyClick(player, btn, id)
	if env.test.trace then log("dialModifyClick(): id="..tostring(id)) end
	GD.game.players[player.color].actions_set = false
	local dial = getObjectFromGUID(C.action_dials[player.color])
	dial.call("hideMe")
	dial.call("enableDialButtons")
	if dial.is_face_down then dial.call("flipMe") end
	getObjectFromGUID(C.player_boards[player.color]).call("setState",{done=true,undo=false})
end

--[[ *****************************
Handle player click on replace character dialog
If 'Done', finalize the selection in playerDone().
if 'Undo' undo the selection in playerUndo().
********************************]]
function replaceCharDialogBtn(player, btn, id)
	if env.test.trace then log("replaceCharDialogBtn(): player "..player.color..", id="..tostring(id)) end
	local command = Split(id,'_')[3]
	log("command = "..tostring(command))
	if command == "done" then
		local action,index
		for i,a in ipairs(GD.game.players[player.color].pending_actions) do
			if a.key == "exchange" and a.type == "replace" then
				action = a
				index = i
				break
			end
		end
		if not(action) then
			log("***ERROR: replaceCharDialogBtn() no pending action")
			return
		end
		GD.game.players[player.color].character_id = action.character_id
		setCharacterBonus(player.color)
		--special case, adjust free turn action for holding/not holding the Builder
		local free = false
		local index
		for i,a in ipairs(GD.game.players[player.color].turn_actions) do
			if a.free then
				free = true
				index = i
				break
			end
		end
		if action.character_id == 5 then
			if not(free) then
				local free_action = simpleDeepCopy(C.dial_actions[9].actions[1])
				free_action.status = ""
				free_action.pointer_id = ""
				free_action.free = true
				free_action.index = #GD.game.players[player.color].turn_actions + 1
				table.insert(GD.game.players[player.color].turn_actions, free_action)
			end
		else
			if free then
				table.remove(GD.game.players[player.color].turn_actions, index)
				for i,a in ipairs(GD.game.players[player.color].turn_actions) do
					a.index = i --fixup index
				end
			end
		end
		GD.game.players[player.color].replace_character = false
		table.remove(GD.game.players[player.color].pending_actions,index)
		updateDialUI(player.color)
		UI_setAttribute("replace_character_pnl","active",false)
		UI_setAttribute("replace_done_pnl","visibility","Pink")
		UI_setAttribute("replace_undo_pnl","visibility","Pink")
		--unlock mutex, check for round end or advance to next player in round
		GD.game.wait_for_character_replace = false
		updateTurnOrder()
		if #GD.game.remaining_round_players == 0 then
			finishCurrentRound()
		else
			startPlayerTurn(setNextPlayer())
		end
	elseif command == "undo" then
		playerUndo(player.color)
		UI_setAttribute("replace_undo_pnl","visibility","Pink")
	else
		log("*** ERROR replaceCharDialogBtn() unknown command")
	end
end


--[[/////////////// Game Setup /////////////////////]]

--[[ *****************************
Randomly assign the 7 Governors to starting positions on the track.
********************************]]
function setupGovernorTrack()
	if env.test.trace then log("setupGovernorTrack()") end
	local temp = simpleDeepCopy(C.governors)
	local row = 0
	local ref = 7
	GD.game.governor_track = {}
	while #temp > 0 do
		local i = math.random(#temp)
		row = row + 1
		if row > 7 then
			log("*** ERROR: setupGovernorTrack() exceeded safety stop, too many rows")
			return
		end --safety
		table.insert(GD.game.governor_track,{city=temp[i].city,node=temp[i].node,track_row=row, UI_row=ref, scoring=false})
		table.remove(temp,i)
		ref = ref - 1
	end
	updateGovernorTrack()
end

--[[ *****************************
Update the board UI with Governor images on the track.
Assumes governor track data has been initialized.
********************************]]
function updateGovernorTrack()
	if env.test.trace then log("updateGovernorTrack()") end
	-- local board = getObjectFromGUID(C.board_guid)
	--fill base track images
	for row=1,17 do
		if row > 7 then
			board_UI_setAttribute("gov_"..tostring(row),"image","Gray-"..(row-7))
		else
			board_UI_setAttribute("gov_"..tostring(row),"image","Gray")
		end
	end
	--set the governor images per gov track data table, overwriting base image set above
	for i,entry in ipairs(GD.game.governor_track) do
		board_UI_setAttribute("gov_"..tostring(entry.track_row),"image",entry.city)
	end
end

--[[ *****************************
Setup: initialize the game
********************************]]
function startGame()
	if env.test.trace then log("startGame()") end
	-- GD.game.stage = "setup"
	GD.game.auction_characters = false --TODO: get this from start dialog
	setupGovernorTrack()
	setupNetwork()
	if not(setupPlayers()) then return end
	setupStatusPanel()
	UI_setAttribute("statusPanel","active","true")
	--for testing, set solo player to start player color
	local players = Player.getPlayers()
	if #players == 1 then
		if env.test.players and env.test.auto_switch then
			Player[players[1].color].changeColor(GD.game.current_player_color)
		end
	end
end

--[[ *****************************
Setup: setup the status UI for number of players
Assumes GD.game.player_order is established.
********************************]]
function setupStatusPanel()
	if env.test.trace then log("setupStatusPanel()") end
	local letters = {Yellow="Y",Red="R",Green="G",Blue="B",Purple="P",}
	local xml=UI.getXmlTable()
	local status_panel = getXmlElement("statusPanel",xml)
	local status_table = getXmlElement("status_table",status_panel)
	local columnWidths="100 40"
	local panel_width = 140
	--setup the header row
	local index = 3
	local player_columns = {}
	local header_row = getXmlElement("status_header_row",status_table)
	local header_cell = getXmlElement("status_h_template",header_row)
	for pcol,initial in pairs(letters) do
		if contains(GD.game.player_order,pcol) then
			table.insert(player_columns, pcol)
			local cell = simpleDeepCopy(header_cell)
			cell.attributes.id = "status_h_"..pcol
			local text = cell.children[1]
			text.attributes.id = "status_h_txt_"..pcol
			text.attributes.color = pcol
			text.attributes.text = initial
			header_row.children[index] = cell
			columnWidths = columnWidths.." 36"
			panel_width = panel_width + 36
			index = index + 1
		end
	end
	--setup the city rows
	local city_row = getXmlElement("status_row_template",status_table)
	local temp_row = simpleDeepCopy(city_row)
	local player_cell = getXmlElement("status_p_template",temp_row)
	status_table.children[2] = nil --wipe out the template so it can be replaced
	for i,gov in ipairs(GD.game.governor_track) do
		local row = simpleDeepCopy(temp_row)
		local ref = gov.UI_row
		log("creating row for child "..tostring(ref))
		row.attributes.id = "status_row_"..tostring(ref)
		local text = getXmlElement("status_city_name_template",row)
		text.attributes.id = "status_city_name_"..tostring(ref)
		text.attributes.text = gov.city
		local image = getXmlElement("status_city_image_template",row)
		image.attributes.id = "status_city_image_"..tostring(ref)
		image.attributes.image = gov.city
		for p,pcol in ipairs(player_columns) do
			local pcell = simpleDeepCopy(player_cell)
			local ptext = getXmlElement("status_p_text_template",pcell)
			ptext.attributes.id = "status_p_text_"..tostring(ref).."_"..pcol
			ptext.attributes.text = ""
			row.children[2+p] = pcell
		end
		table.insert(status_table.children,2,row) --always next after header, pushing rest downward
	end
	if env.test.debug then
		log("status table")
		-- log(status_table.children)
		for i,c in ipairs(status_table.children) do
			if i > 1 then
				log(tostring(i)..": id:"..c.attributes.id)
				log(c.children[2].children[1].attributes)
			end
		end
	end
	--reload the xml UI
	status_panel.attributes.width = tostring(panel_width)
	status_table.attributes.columnWidths = columnWidths
	UI.setXmlTable(xml)
end

--[[ *****************************
Setup: initialize game for seated players
********************************]]
function setupPlayers()
	if env.test.trace then log("setupPlayers()") end
	local seated = getSeatedPlayers()
	if env.test.players ~= nil then
		seated = simpleDeepCopy(env.test.players)
	end
	GD.game.player_count = #seated
	if GD.game.player_count < 2 then
		broadcastToAll("2 or more players needed")
		return false
	end
	GD.game.player_order = {}
	for _,pcol in ipairs(C.table_colors) do
		if contains(seated,pcol) then table.insert(GD.game.player_order,pcol) end
	end
	GD.game.players = {}
	GD.game.status_visibility = "Pink"
	for _,pcol in ipairs(GD.game.player_order) do
		reloadUI(C.player_boards[pcol])
		GD.game.players[pcol] = simpleDeepCopy(C.player_data)
		local player = GD.game.players[pcol]
		player.architect_location = {
			current_node = 38,
			dest_node = -1,
			snap_pos = getObjectFromGUID(C.player_pawns[pcol]).getPosition(),
		}
		player.gold = 15
		player.extra_actions = 0
		player.turn_actions = {}
		player.actions_set = false
		player.pointers = {}
		getObjectFromGUID(C.player_pawns[pcol]).setLock(true)
		--initialize player pool
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		for i=1,12 do
			local pos = player_board.positionToWorld(C.player_board_pool_locations[i])
			table.insert(player.pool, i, {g=nil,p=pos})
		end
		GD.game.status_visibility = GD.game.status_visibility..'|'..pcol
		--initialize the city scores table
		for name,_ in pairs(C.cities) do
			GD.game.city_scores[name][pcol] = 0
		end
	end
	UI_setAttribute("status_info","visibility",GD.game.status_visibility)
	GD.game.current_player = math.random(#GD.game.player_order)
	GD.game.current_player_color = GD.game.player_order[GD.game.current_player]
	broadcastToAll("Starting player will be "..GD.game.current_player_color)
	startLuaCoroutine(Global, "coroFillPlayerBoards")
	return true
end

--[[ *****************************
Setup: fill player boards with palaces and houses,
remove unused player objects and place unused palaces
Run as a coro with pauses between spawning objects.
********************************]]
function coroFillPlayerBoards()
	if env.test.trace then log("coroFillPlayerBoards(): START") end
	--private function to pause (yield) coro for a number of frames
	local pauseMe = function(frames)
		frames = frames or env.game.fill_delay
		local count = 0
		while count < frames do
			count = count + 1
			coroutine.yield(0)
		end
	end
	local house = getObjectFromGUID(C.house_object_guid)
	assert(house, "*** ERROR: coroFillPlayerBoards(): no house object")
	local palace = getObjectFromGUID(C.palace_object_guid)
	assert(palace, "*** ERROR: coroFillPlayerBoards(): no palace object")

	--remove unused player area objects
	local board = getObjectFromGUID(C.board_guid)
	local rot = board.getRotation()
	copy({palace})
	for _,pcol in ipairs(C.table_colors) do
		if GD.game.players[pcol] == nil then
			getObjectFromGUID(C.player_boards[pcol]).destruct()
			getObjectFromGUID(C.action_dials[pcol]).destruct()
			getObjectFromGUID(C.player_aids[pcol]).destruct()
			getObjectFromGUID(C.player_pawns[pcol]).destruct()
			--place unused player palaces in outer city palaces
			for name,city in pairs(C.cities) do
				local index = #GD.network[city.node].palaces + 1
				local pos = board.positionToWorld(GD.network[city.node].center - C.city_palace_offsets[index])
				local p = {position=pos}
				local obj = paste(p)[1]
				assert(obj, "*** ERROR: coroFillPlayerBoards(): failed to paste object")
				obj.setRotation(rot)
				obj.setColorTint(C.object_color_tints[pcol])
				obj.setName("Unused")
				obj.memo = "palace"
				obj.tooltip = false
				obj.interactable = false
				table.insert(GD.network[city.node].palaces, {g=obj.getGUID(),c=pcol,})
				pauseMe()
				Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
			end
		end
	end
	pauseMe(10)

	--fill seated player boards
	for _,pcol in ipairs(GD.game.player_order) do
		local player = GD.game.players[pcol]
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		assert(player_board, "*** ERROR: coroFillPlayerBoards(): no board object for color "..tostring(pcol))
		player_board.tooltip = false
		local rot = player_board.getRotation()
		copy({palace})
		for i,loc in ipairs(C.player_board_palace_locations) do
			local pos = player_board.positionToWorld(loc)
			local p = {position=pos}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "palace"
			obj.setDescription("Palace")
			table.insert(player.palaces, {g=obj.getGUID(),p=pos})
			pauseMe()
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		end
		copy({house})
		for i,loc in ipairs(C.player_board_quarry_locations) do
			local pos = player_board.positionToWorld(loc)
			local p = {position=pos}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "house"
			obj.setDescription("House")
			table.insert(player.quarry, {g=obj.getGUID(),p=pos})
			pauseMe()
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		end
		for i=5,8 do
			local p = {position=player.pool[i].p}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "house"
			obj.setDescription("House")
			player.pool[i].g = obj.getGUID()
			pauseMe()
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		end
		local dial = getObjectFromGUID(C.action_dials[pcol])
		assert(dial, "*** ERROR: coroFillPlayerBoards(): no dial object for color "..tostring(pcol))
		dial.tooltip = false
		dial.call("disableDialButtons")
		dial.call("showMe")
	end

	--setup for next game stage
	if GD.game.auction_characters then

		--TODO: setup for auction

	else
		--setup for character card selection
		for _,char in ipairs(C.characters) do
			getObjectFromGUID(char.g).setLock(false)
		end
		GD.game.stage = "select_starting_characters"
		GD.game.characters_selected = 0
		broadcastToAll(GD.game.current_player_color.." player select a character card then continue clockwise around table")
		local p = {dormant = false,done = false,undo = false,}
		p.help_text = "Select a character card then click Done."
		for _,pcol in ipairs(GD.game.player_order) do
			p.active = (pcol == GD.game.current_player_color)
			p.gold_coins = GD.game.players[pcol].gold
			p.extra_actions = GD.game.players[pcol].extra_actions
			local player_board = getObjectFromGUID(C.player_boards[pcol])
			player_board.call("setState",p)
		end
	end
	board_UI_setAttribute("governor_panel", "active", true)
	reloadUI(C.board_guid)
	if env.test.trace then log("coroFillPlayerBoards(): EXIT") end
	return 1
end

--[[ *****************************
Load 6 starting houses into player Quarry after setup
********************************]]
function startingQuarry(pcol)
	if env.test.trace then log("startingQuarry(): "..pcol) end
	local quarry = GD.game.players[pcol].quarry
	local pool = GD.game.players[pcol].pool
	for i=1,6 do
		local index = 16 - i + 1
		local house = getObjectFromGUID(quarry[index].g)
		assert(house,"*** ERROR: startingQuarry() nil quarry house")
		house.setPosition(pool[i].p)
		quarry[index].g = nil
		pool[i].g = house.getGUID()
	end
end

--[[ *****************************
Move 2 houses from quarry
********************************]]
function quarryAction(pcol)
	if env.test.trace then log("startingQuarry(): "..pcol) end
	local player = GD.game.players[pcol]
	local quarry = player.quarry
	local pool = player.pool
	local success = false
	for i=1,2 do
		for p=1,12 do
			if not(pool[p].g) then
				for q=16,1,-1 do
					if quarry[q].g then
						getObjectFromGUID(quarry[q].g).setPosition(pool[p].p)
						pool[p].g = quarry[q].g
						quarry[q].g = nil
						success = true
						break --out of quarry loop
					end
				end
				break --out of pool loop
			end
		end
	end
	return success
end

--[[ *****************************
Finalize a starting character select action
Player has clicked "Done"
********************************]]
function setStartingCharacter(action)
	if env.test.trace then log("setStartingCharacter()") end
	if GD.game.stage ~= "select_starting_characters" then
		log(("*** ERROR: setStartingCharacter() invalid game stage")) --shouldn't happen
		return
	end
	local pcol = action.player_color
	GD.game.players[pcol].character_id = action.character_id
	GD.game.characters_selected = GD.game.characters_selected + 1
	if GD.game.characters_selected == GD.game.player_count then
		--All players selected a character, now setup game for initial house placement
		for id,char in ipairs(C.characters) do
			getObjectFromGUID(char.g).setLock(true)
		end
		updateTurnOrder()
		setNextPlayer(FIRST)
		GD.game.stage = "initial_placement"
		broadcastToAll("Begin initial house placement")
		local p ={done=false,undo=false}
		p.help_text = "Place one starting house from Build Pool.\nOnly place on Villages."
		for pcol,pdata in pairs(GD.game.players) do
			for _,e in ipairs(pdata.pool) do
				if e.g then getObjectFromGUID(e.g).setLock(false) end
			end
			GD.game.players[pcol].init_placements = 4
			p.active = (pcol == GD.game.current_player_color)
			getObjectFromGUID(C.player_boards[pcol]).call("setState",p)
		end
		GD.game.players_init_placed = 0
		GD.game.init_placement = 4
	else
		getObjectFromGUID(C.player_boards[pcol]).call("setState")
		getObjectFromGUID(C.player_boards[setNextPlayer()]).call("setState", {active=true})
	end
end

--[[ *****************************
Finalize an initial house placement action
Player has clicked "Done"
********************************]]
function setInitialPlacement(action)
	if env.test.trace then log("setInitialPlacement()") end
	if GD.game.stage ~= "initial_placement" then
		log(("*** ERROR: setInitialPlacement() invalid game stage")) --shouldn't happen
		return
	end
	local obj = getObjectFromGUID(action.guid)
	local player = GD.game.players[action.player_color]
	removeFromPlayerBoard(obj)
	player.init_placements = player.init_placements - 1
	player.placed_houses[obj.getGUID()] = obj.getPosition()
	GD.game.players_init_placed = GD.game.players_init_placed + 1
	if GD.game.players_init_placed == GD.game.player_count then
		--reset for next round of placement until all 4 placed
		GD.game.players_init_placed = 0
		GD.game.init_placement = GD.game.init_placement - 1
	end
	if GD.game.init_placement == 0 then
		--End of placement, setup for first round
		for pcol,pdata in pairs(GD.game.players) do
			startingQuarry(pcol)
		end
		broadcastToAll("Begin First Round")
		GD.game.current_round = 0
		beginNextRound()
		return
	else
		getObjectFromGUID(C.player_boards[action.player_color]).call("setState")
		getObjectFromGUID(C.player_boards[setNextPlayer()]).call("setState",{active=true})
	end
end

--[[/////////// Game Play ///////////////////////]]

--[[ *****************************
TODO: document
********************************]]
function beginNextRound()
	if env.test.trace then log("beginNextRound()") end
	GD.game.current_round = GD.game.current_round + 1
	if GD.env.verbose then broadcastToAll("Beginning round "..tostring(GD.game.current_round).." of max 10") end
	moveMaharaja()
	GD.game.remaining_round_players = {} ---HACK: is there a better way to do this?
	updateTurnOrder()
	GD.game.stage = "select_actions"
	for pcol,player in pairs(GD.game.players) do
		player.has_actions = true
		player.actions_set = false
		player.turn_actions = {}
		player.pointers = {}
		setCharacterBonus(pcol)
		local dial = getObjectFromGUID(C.action_dials[pcol])
		dial.call("reset")
		dial.call("enableDialButtons")
		dial.call("hideMe")
		if dial.is_face_down then dial.call("flipMe") end
		local txt = "Secretly choose turn actions and confirm with Done.\n"
		txt = txt .. "Player turns will begin once all have confirmed.\n"
		txt = txt .. "Until then selections can be modified."
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{active=true,done=false,undo=false,help_text=txt})
		table.insert(GD.game.remaining_round_players, pcol)
	end
end

--[[ *****************************
Process a dropped character card.
Result depends on game stage.
********************************]]
function characterDrop(pcol, obj)
	if env.test.trace then log("characterDrop()") end
	local char_id = getCharacterId(obj.getGUID())
	local board = getObjectFromGUID(C.board_guid)
	local player = GD.game.players[pcol]
	--///////// Local Functions //////////
	local function snapBack(obj)
		local pos,rot
		for color,pdata in pairs(GD.game.players) do
			if char_id == pdata.character_id then
				local player_board = getObjectFromGUID(C.player_boards[color])
				pos = player_board.positionToWorld(C.player_board_character_location)
				rot = player_board.getRotation()
			end
		end
		if not(pos) then pos = C.characters[char_id].bank_pos end
		if not(rot) then rot = board.getRotation() end
		obj.setPositionSmooth(pos, false, true)
		obj.setRotation(rot)
		return
	end
	--/////////////////////////////////
	if pcol ~= GD.game.current_player_color and not(player.replace_character) then
		snapBack(obj)
		return
	end
	if GD.game.stage == "select_starting_characters" then
		if #GD.game.players[pcol].pending_actions > 0 then
			if GD.env.verbose then broadcastToColor("Character already selected", pcol) end
			snapBack(obj)
			return
		end
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		local pos = player_board.positionToWorld(C.player_board_character_location)
		local rot = player_board.getRotation()
		obj.setPositionSmooth(pos, false, true)
		obj.setRotation(rot)
		Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		local pending_action = {
			key = "select_starting_character",
			player_color = pcol,
			character_id = char_id,
			undo = {
				guid = obj.getGUID(),
				snapback = {pos=C.characters[char_id].bank_pos, rot=board.getRotation()},
			},
		}
		table.insert(player.pending_actions, pending_action)
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=true,undo=true})
	elseif GD.game.stage == "player_turns" then
		for _,a in ipairs(player.pending_actions) do
			if a.key == "exchange" then
				log("TESTING: characterDrop() prevent player from selecting multiple character tiles")
				if GD.env.verbose then broadcastToColor("Character already selected", pcol) end
				snapBack(obj)
				return
			end
		end
		if char_id == player.character_id then
			log("TESTING: snap back own character and ignore")
			snapBack(obj)
			return
		end
		if player.replace_character then
			--this player selecting a new character after being stolen
			local player_board = getObjectFromGUID(C.player_boards[pcol])
			local pos = player_board.positionToWorld(C.player_board_character_location)
			local rot = player_board.getRotation()
			obj.setPositionSmooth(pos, false, true)
			obj.setRotation(rot)
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
			local pending_action = {
				key = "exchange",
				type = "replace",
				player_color = pcol,
				character_id = char_id,
				undo = {
					guid = obj.getGUID(),
					snapback = {pos=C.characters[char_id].bank_pos, rot=board.getRotation()},
				},
			}
			setCharacterBonus(pcol)
			local txt = "Execute actions in any order.\n"			--TODO: make this a constant?
			txt = txt.."May move Architect at any time.\n"
			txt = txt.."All required actions must be executed.\n"
			txt = txt..C.character_bonus_descriptions[player.character_id]
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{active=false,undo=false,help_text=txt})
			table.insert(player.pending_actions, pending_action)
			player.replace_character = false
			UI_setAttribute("replace_done_pnl","visibility",pcol)
			UI_setAttribute("replace_undo_pnl","visibility",pcol)
		else
			local curr_guid = C.characters[player.character_id].g
			if curr_guid ~= obj.getGUID() then
				local opponent = ""
				local opp_char_id = -1
				for color,opp in pairs(GD.game.players) do
					if color != pcol then
						if opp.character_id == char_id then
							opponent = color
							opp_char_id = opp.character_id
							break
						end
					end
				end
				log("TESTING: opponent = "..tostring(opponent))
				local curr_char = getObjectFromGUID(curr_guid)
				local player_board = getObjectFromGUID(C.player_boards[pcol])
				local pos = player_board.positionToWorld(C.player_board_character_location)
				local rot = player_board.getRotation()
				local pending_action = {
					key = "exchange",
					type = "exchange",
					player_color = pcol,
					character_id = char_id,
					old_char_id = player.character_id,
					opponent = opponent,
					opp_char_id = opp_char_id,
					undo = {
						new_guid = obj.getGUID(),
						snapback = {pos=C.characters[char_id].bank_pos, rot=board.getRotation()},
						old_guid = curr_guid,
					},
				}
				if opponent == "" then
					pending_action.bank = true
				else
					pending_action.bank = false
					pending_action.opp_char_id = opp_char_id
					local opp_board =  getObjectFromGUID(C.player_boards[opponent])
					pending_action.undo.snapback.pos = opp_board.positionToWorld(C.player_board_character_location)
					pending_action.undo.snapback.rot = opp_board.getRotation()
				end
				setActionIndex(pcol, pending_action)
				if pending_action.action_index < 1 then
					--TODO: shouldn't happen if checking for pending action above???
					if GD.env.verbose then broadcastToColor("No available Exchange Character action",pcol) end
					log("ERROR: characterDrop() unexpected: unable to locate unused exchange character action for player "..tostring(pcol))
					snapBack(obj)
				else
					curr_char.setPosition(C.characters[player.character_id].bank_pos)
					curr_char.setRotation(board.getRotation())
					obj.setPositionSmooth(pos, false, true)
					obj.setRotation(rot)
					Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
					player.character_id = char_id
					setCharacterBonus(pcol)
					local txt = "Execute actions in any order.\n"			--TODO: make this a constant?
					txt = txt.."May move Architect at any time.\n"
					txt = txt.."All required actions must be executed.\n"
					txt = txt..C.character_bonus_descriptions[player.character_id]
					getObjectFromGUID(C.player_boards[pcol]).call("setState",{active=active,done=active,undo=true,help_text=txt})
					if player.character_id == 7 then
						player.extra_actions = player.extra_actions + 1
						getObjectFromGUID(C.player_boards[pcol]).call("setState",{extra_actions=player.extra_actions})
						if GD.env.verbose then printToAll(pcol.." +1 extra action token for the Yogi") end
						pending_action.undo.extra_actions = -1
					elseif player.character_id == 2 then
						player.gold = player.gold + 1
						getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
						if GD.env.verbose then printToAll(pcol.." +1 gold for the Trader") end
						pending_action.undo.gold = -1
					elseif player.character_id == 5 then
						if GD.env.verbose then printToAll(pcol.." free build/move") end
						pending_action.undo.free_action = true
					end
					table.insert(player.pending_actions, pending_action)
					getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=true,undo=true})
					updateTurnAction(pcol, pending_action)
					updateDialUI(pcol)
				end
			end
		end
	else
		log("***ERROR: characterDrop() invalid game stage")
	end
end

--[[ *****************************
Process a dropped house.
Result depends on game stage.
********************************]]
function houseDrop(pcol, obj)
	if env.test.trace then log("houseDrop()") end
	local board = getObjectFromGUID(C.board_guid)
	local player = GD.game.players[pcol]
	local color = obj.getName()
	--/////// local functions ///////

	--[[TODO: document]]
	local function snapBack(obj)
		local pos = placedObjSnap(obj.getGUID())
		if pos then
			obj.setPosition(pos)
			obj.setRotation(getObjectFromGUID(C.board_guid).getRotation())
		else
			obj.setPosition(getPlayerBoardLocation(obj))
			obj.setRotation(getObjectFromGUID(C.player_boards[color]).getRotation())
		end
	end

	--[[TODO: document]]
	local function placeVillageHouse(obj, node)
		if env.test.trace then log("placeVillageHouse() "..tostring(obj)..", "..tostring(node)) end
		if env.test.debug then log(node) end
		table.insert(node.houses,{g=obj.getGUID(),c=obj.getName()})
		local pos = board.positionToWorld(Vector(node.center))
		if GD.game.player_count > 2 then
			local pos_1 = Vector(node.center) - Vector(VILLAGE_OFFSET)
			local pos_2 = Vector(node.center) + Vector(VILLAGE_OFFSET)
			pos = board.positionToWorld(pos_1)
			if #node.houses == 1 then pos = board.positionToWorld(pos_2) end
		end
		pos.y = 1.5
		obj.setRotation(board.getRotation())
		obj.setPosition(pos)
		Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
	end

	--[[TODO: document]]
	local function placeCityHouse(obj, node)
		if env.test.trace then log("placeCityHouse() "..tostring(obj)..", "..tostring(node)) end
		if env.test.debug then log(node) end
		local color = obj.getName()
		local center = GD.network[node.id].center
		log(tostring(node.name).." center is "..tostring(center))
		local index = #node.houses[color] + 1
		log("TODO: handle more than 6 houses of a color in a city.  <-------------------")
		local offset = Vector(C.city_house_offsets[color][index].o)
		local pos = Vector(center) - offset
		local rot = Vector(C.city_house_offsets[color][index].r)
		pos.y = 1.5
		obj.setRotationSmooth(rot, false, true)
		obj.setPositionSmooth(board.positionToWorld(pos), false, true)
		table.insert(node.houses[color],obj.getGUID())
		Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
	end

	--[[  TODO: merge with global helper function?
	Override this function locally for house drop special case handling
	find first available turn action for the pending_action.key
	Search required actions (dial selected) first, then try free action. ]]
	local function setActionIndex(pcol, pending_action)
		if env.test.trace then log("setActionIndex()") end
		if env.test.debug then
			log("pcol "..tostring(pcol))
			log("pending action:")
			log(pending_action)
		end
		local action_index = -1
		local free_action = false
		local player = GD.game.players[pcol]
		--search first for a pointer action
		for i,a in ipairs(player.turn_actions) do
			if a.id == pending_action.key and a.status == "" and a.pointer_id ~= "" then
				if a.city_required then  --HACK: ugly special case for build in a city only action
					if pending_action.location == "city" then
						action_index = i
						break
					end
				else
					action_index = i
					break
				end
			end
		end
		if action_index == -1 then
			--no pointer action so search for a free action (no pointer_id)
			for i,a in ipairs(player.turn_actions) do
				if a.id == pending_action.key and a.status == "" and a.pointer_id == "" then
					action_index = i
					free_action = true
					break
				end
			end
		end
		--set the values in the pending action (pass by reference)
		pending_action.action_index = action_index
		pending_action.free_action = free_action
	end
	--//////////////////////////////////

	local pos = obj.getPosition()
	pos.y = 0
	local node_index = closestNode(pos)
	if env.test.debug then log("nearest is id "..tostring(node_index)..", type "..GD.network[node_index].type..", name "..GD.network[node_index].name) end
	if node_index < 1 then
		snapBack(obj)
		return
	end
	local node = GD.network[node_index]
	if GD.game.stage == "initial_placement" then
		if node.type == "village" then
			if isVillageFull(node) then
				snapBack(obj)
				return
			end
			placeVillageHouse(obj,node)
			local pending_action = {
				key = "initial_placement",
				player_color = pcol,
				guid = obj.getGUID(),
				undo = {
					node_index = node_index,
					guid = obj.getGUID(),
					snapback = {
						pos=getPlayerBoardLocation(obj),
						rot=getObjectFromGUID(C.player_boards[pcol]).getRotation(),
					}
				},
			}
			--show done and undo buttons
			log(pending_action)
			table.insert(player.pending_actions, pending_action)
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=true,undo=true})
		elseif node.type == "city" then
			snapBack(obj)
		else
			snapBack(obj)
		end
	else
		if node.type == "village" or node.type == "city" then
			local pending_action = {
				key = "move",
				action_index = -1,
				free_action = false,
				location = node.type,
				player_color = pcol,
				guid = obj.getGUID(),
				undo = {
					node_index = node_index,
					guid = obj.getGUID(),
					snapback = {
						pos=placedObjSnap(obj.getGUID()),
						rot=getObjectFromGUID(C.board_guid).getRotation()
					},
				},
			}

			log("TODO: TEST move house action. <--------------------------- ")

			if not(pending_action.undo.snapback.pos) then --this house coming from player's pool
				pending_action.undo.snapback.pos = getPlayerBoardLocation(obj)
				pending_action.undo.snapback.rot = getObjectFromGUID(C.player_boards[pcol]).getRotation()
 				pending_action.key = "build"
			end
			setActionIndex(pcol, pending_action)
			if pending_action.action_index == -1 then
				snapBack(obj)
				if GD.env.verbose then broadcastToColor("No more "..pending_action.key.." actions", pcol) end
				return
			end
			if not(pending_action.free_action) and pending_action.key == "build" and player.gold < 1 then
				snapBack(obj)
				if GD.env.verbose then broadcastToColor("Not enough gold", pcol) end
				return
			end
			if node.type == "village" then
				if isVillageFull(node) then
					snapBack(obj)
					return
				else
					placeVillageHouse(obj,node)
				end
			else
				if player.architect_location.current_node == node_index then
					placeCityHouse(obj, node)
					updateCityScores(node)
					updateStatusPanel()
				else
					snapBack(obj)
					if GD.env.verbose then broadcastToColor("Architect must be present in the city", pcol) end
					return
				end
			end
			if pending_action.key == "build" then
				if pending_action.free_action then
					if GD.env.verbose then printToAll(pcol.." builds a house for free") end
				else
					player.gold = player.gold - 1
					getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
					if GD.env.verbose then printToAll(pcol.." builds a house for 1 gold") end
				end
			else
				if GD.env.verbose then printToAll(pcol.." moves a house") end
			end
			updateTurnAction(pcol, pending_action)
			updateDialUI(pcol)
			table.insert(player.pending_actions, pending_action)
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{undo=true})
		else
			snapBack(obj)
		end
	end
end

--[[ ********* TODO: TESTING *************
Process a dropped palace.
********************************]]
function palaceDrop(pcol, obj)
	if env.test.trace then log("palaceDrop()") end
	local board = getObjectFromGUID(C.board_guid)
	local player = GD.game.players[pcol]
	local color = obj.getName()

	--/////// local functions ///////
	--[[TODO: document]]
	local function snapBack(obj)
		obj.setPosition(getPlayerBoardLocation(obj))
		obj.setRotation(getObjectFromGUID(C.player_boards[color]).getRotation())
	end
	--[[TODO: document]]
	local function placePalace(obj, node)
		local color = obj.getName()
		local center = GD.network[node.id].center
		local rot = board.getRotation()
		local pos = center
		if node.center_palace then
			local index = #node.palaces + 1
			local offset = Vector(C.city_palace_offsets[index])
			log("placing "..color.." palace "..obj.getGUID().." with offset "..tostring(offset))
			pos = Vector(center) - offset
			table.insert(node.palaces,{g=obj.getGUID(),c=color,})
		else
			log("placing "..color.." palace "..obj.getGUID().." with offset in city center")
			node.center_palace = {g=obj.getGUID(),c=color,}
		end
		pos.y = 1.5
		log("position is:")
		log(pos)
		obj.setRotationSmooth(rot, false, true)
		obj.setPositionSmooth(board.positionToWorld(pos), false, true)
		Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
	end
	--//////////////////////////////////

	local pos = obj.getPosition()
	pos.y = 0
	local node_index = closestNode(pos)
	log("nearest is id "..tostring(node_index)..", type "..GD.network[node_index].type..", name "..GD.network[node_index].name)
	if node_index < 1 then
		snapBack(obj)
		return
	end
	local node = GD.network[node_index]
	if node.type ~= "city" then
		snapBack(obj)
		return
	end
	local pending_action = {
		key = "palace",
		action_index = -1,
		player_color = pcol,
		guid = obj.getGUID(),
		undo = {
			node_index = node_index,
			guid = obj.getGUID(),
			snapback = {
				pos=getPlayerBoardLocation(obj),
				rot=getObjectFromGUID(C.player_boards[color]).getRotation(),
			},
		},
	}
	setActionIndex(pcol, pending_action)
	if pending_action.action_index == -1 then
		snapBack(obj)
		if GD.env.verbose then broadcastToColor("No more palace actions", pcol) end
		return
	end
	local cost = 12
	if player.character_id == 6 then cost = 9 end
	if player.gold < cost then
		snapBack(obj)
		if GD.env.verbose then broadcastToColor("Not enough gold", pcol) end
		return
	end
	if player.architect_location.current_node == node_index then
		placePalace(obj, node)
		updateCityScores(node)
		updateStatusPanel()
		player.gold = player.gold - cost
		pending_action.cost = cost
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
		updateTurnAction(pcol, pending_action)
		updateDialUI(pcol)
		table.insert(player.pending_actions, pending_action)
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{undo=true})
		if GD.env.verbose then printToAll(pcol.." places a palace for "..tostring(cost).." gold") end
	else
		snapBack(obj)
		if GD.env.verbose then broadcastToColor("Architect must be present in the city", pcol) end
	end
end

--[[ ********* TODO: *************
Process a dropped architect.
********************************]]
function architectDrop(pcol, obj)
	if env.test.trace then log("architectDrop(): "..pcol..", "..tostring(obj)) end
	local board = getObjectFromGUID(C.board_guid)
	local player = GD.game.players[pcol]
	local color = obj.getName()
	local function snapback(obj)
		local pos = player.architect_location.snap_pos
		assert(pos, "***ERROR: architectDrop() invalid snap back position")
		obj.setPosition(pos)
	end
	if color ~= pcol then snapback(obj) end
	local pos = obj.getPosition()
	local node_index = closestNode(pos)
	log("nearest is id "..tostring(node_index)..", type "..GD.network[node_index].type..", name "..GD.network[node_index].name)
	if node_index < 1 then
		snapBack(obj)
		return
	end
	local node = GD.network[node_index]
	if node.type ~= "city" then
		snapback(obj)
		return
	end
	if node_index == player.architect_location.current_node then
		snapback(obj)
		return
	end
	--position pawn on city location
	local lpos = Vector(node.center) - Vector(C.city_pawn_offsets[pcol])
	obj.setPosition(board.positionToWorld(lpos))

	--/////////// TESTING
	updatePathTable(pcol)
	local start_id = player.architect_location.current_node
	local dest_id = node_index
	local tmp = buildRouteTable(start_id, dest_id)
	if #tmp == 0 then --no valid route
		log("No valid route from node "..tostring(start_id).." to node "..dest_id)
		snapback(obj)
		return
	end
	log("////////// TESTING: architectDrop ")
	log(tmp)
	local routes = {}
	for i,e in ipairs(tmp) do  --calculate routes
		local route = {}
		route.total_cost = 0
		route.length = 0
		local cities = ""
		for _,c in ipairs(e.seen) do
			cities = cities .." "..tostring(c)
		end
		route.cities = cities
		local costs = {}
		for _,p in ipairs(e.paths) do
			route.length = route.length + 1
			for color,cost in pairs(GD.path_table[p].cost) do
				route.total_cost = route.total_cost + cost
				if costs[color] ~= nil then
					costs[color] = costs[color] + cost
				else
					costs[color] = cost
				end
			end
		end
		route.costs = simpleDeepCopy(costs)
		table.insert(routes,simpleDeepCopy(route))
	end
	log("routes discovered:")
	log(routes)
	-- prune too expensive (total cost > player gold), if all are too expensive then snapback & warn
	for i,route in ipairs(routes) do  --prune routes
		if route.total_cost > player.gold then routes[i]=nil end
	end
	if #routes == 0 then
		log("All routes from node "..tostring(start_id).." to node "..dest_id.." cost more than player gold")
		snapback(obj)
		return
	end
	-- keep just one (the shortest) free route
	local shortest = {id=-1,len=99}
	for i,route in ipairs(routes) do
		if route.total_cost == 0 then
			if route.length < shortest.len then
				if routes[shortest.id] then routes[shortest.id] = nil end
				shortest.id = i
				shortest.len = route.length
			else
				routes[i]=nil
			end
		end
	end
	-- TODO: remove duplicates (where all color costs are same, len or cities does not matter)
	for i,route in ipairs(routes) do
		local costs = route.costs
		for j,r in ipairs(routes) do
			if r then
				local same = true
				for color,cost in pairs(costs) do
					if not(r[color]) or r[color].cost ~= cost then same = false; break end
				end
				if same then routes[j] = nil end
			end
		end
	end

	log("routes after pruning:")
	log(routes)

	--condense routes table after all pruning (remove nil entries)
	local temp = {}
	for _,route in pairs(routes) do
		if route then table.insert(temp,1,route) end
	end
	routes = temp

	log("routes after condensing:")
	log(routes)

	--TODO: set up pending action (maybe in route picker handler)
	log("TODO: create an undo pending action for architect move. <---------------------")

	--TODO: set up route picker dialog and display it
			--handler will charge player cost for move TODO: set in pending action that can be undone?

	--TODO: this player update may move to route picker dialog handler, to finalize pawn placement
	player.architect_location.current_node = node_index
	player.architect_location.snap_pos = obj.getPosition()

end

--[[ *****************************
Start a player's action turn.
********************************]]
function startPlayerTurn(pcol)
	if env.test.trace then log("startPlayerTurn() for player "..tostring(pcol)) end
	local player = GD.game.players[pcol]
	assert(player,"Failed to locate player for color "..tostring(pcol))
	-- player.failed_actions = false
	player.pending_actions = {}
	player.free_action = false	--TODO: FIX free_action
	if GD.env.verbose then printToAll("Starting turn for player "..pcol) end
	local dial = getObjectFromGUID(C.action_dials[pcol])
	Wait.condition(
		function()
			dial.call("disableDialButtons")
			dial.call("disableBackButton")
			dial.call("showMe")
			if dial.is_face_down then dial.call("flipMe") end
		end,
		function() return(dial.resting) end, 5) --HACK: might be flipping from lock actions call so wait
	getObjectFromGUID(C.player_pawns[pcol]).setLock(false)
	--set and/or execute bonus of character tile
	if player.character_bonus == "+1_extra_action" then
			player.extra_actions = player.extra_actions + 1
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{extra_actions=player.extra_actions})
			if GD.env.verbose then printToAll(pcol.." +1 extra action token for the Yogi") end
	elseif player.character_bonus == "+1_gold" then
			player.gold = player.gold + 1
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
			if GD.env.verbose then printToAll(pcol.." +1 gold for the Trader") end
	end
	--execute any immediate turn actions, set pawn, house, palace lock state based on actions selected
	local palace,pool,move,track,char = false,false,false,false,false
	for _,action in pairs(player.turn_actions) do
		if action.id == "gold" then
			player.gold = player.gold + 2
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
			if GD.env.verbose then printToAll(pcol.." +2 gold for Coins action") end
			action.status = "Done"
			updateDialUI(pcol)
		elseif action.id == "quarry" then
			if quarryAction(pcol) then
				if GD.env.verbose then printToAll(pcol.." moves 2 houses into their Build Pool") end
				action.status = "Done"
				updateDialUI(pcol)
			else
				if GD.env.verbose then printToAll(pcol.." is unable to complete selected Quarry action!") end
				action.status = "Failed"
				updateDialUI(pcol)
			end
		elseif action.id == "palace" then palace = true
		elseif action.id == "build" or action.free then pool = true
		elseif action.id == "move" or action.free then move = true
		elseif action.id == "track" then track = true
		elseif action.id == "exchange" then char = true
		end
	end
	if player.free_action then pool,move = true,true end   --TODO: FIX free_action
	if palace then unplayedPalacesLock(pcol, false) end
	if pool then buildPoolLock(pcol, false) end
	if move then placedHousesLock(pcol, false) end
	if track then governorButtons(true) end
	if char then charactersLock(pcol, false) end
	--enable player board for actions
	local txt = "Execute actions in any order.\n" 			--TODO: make this a constant?
	txt = txt.."May move Architect at any time.\n"
	txt = txt.."All required actions must be executed.\n"
	for _,p in ipairs(GD.game.player_order) do
		local active = (p == pcol)
		local help_txt = txt..C.character_bonus_descriptions[player.character_id]
		getObjectFromGUID(C.player_boards[p]).call("setState",{active=active,done=active,undo=false,help_text=help_txt})
	end
end

--[[ *****************************
Process player Done click based on current game stage.
--For all entries in the player's pending action list:
	-- POP an entry off the LIFO stack
	-- finallize the pendign action, update data structures etc.
	-- remove the entry from the LIFO stack
	-- if more entries, repeat
********************************]]
function playerDone(pcol)
	if env.test.trace then log("playerDone(): "..pcol) end
	local player = GD.game.players[pcol]
	if GD.game.stage == "select_starting_characters" then  --Done during character selection
		local action = player.pending_actions[1]
		assert(action,"*** ERROR: missing starting character action")
		setStartingCharacter(action)
		if env.test.debug then log("Player "..pcol.." finalize "..action.key.." action") end
		table.remove(player.pending_actions, 1)
	elseif GD.game.stage == "initial_placement" then  --Done during initial placement
		local action = player.pending_actions[1]
		assert(action,"*** ERROR: missing initial placement action")
		setInitialPlacement(action)
		if env.test.debug then log("Player "..pcol.." finalize "..action.key.." action") end
		table.remove(player.pending_actions, 1)
	elseif GD.game.stage == "select_actions" then  --Done during action selection
		if player.choosing_extra_action then

			--TODO: extra action STUFF

			setExtraAction(pcol)
		else
			log("Player clicked Done during action selection")   --TODO: LOGGING
			player.actions_set = true
			--TODO: BUG: use a flag on players when actions are set vs. checking pointers in for loop
			log("Checking to see if all have set")
			local all_set = true
			for _,pdata in pairs(GD.game.players) do
				if not(pdata.actions_set) then all_set = false; break end
			end
			log("all_set is "..tostring(all_set))
			if all_set then
				broadcastToAll("All players have set actions, starting player turns")
				for _,pcol in ipairs(GD.game.player_order) do
					local dial = getObjectFromGUID(C.action_dials[pcol])
					dial.call("disableBackButton")
					if not(dial.is_face_down) then dial.call("flipMe") end
					getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=false,help=false})
				end
				GD.game.stage = "player_turns"
				startPlayerTurn(setNextPlayer(FIRST))
			else
				local dial = getObjectFromGUID(C.action_dials[pcol])
				dial.call("enableBackButton")
				dial.call("disableDialButtons")
				if not(dial.is_face_down) then dial.call("flipMe") end
				getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=false})
			end
		end
	elseif GD.game.stage == "player_turns" then --Done during other game stages
		if #player.pending_actions == 0 then
			log("*** WARN: playerDone() no actions to finalize for player "..pcol)
		end
		if failedActions(pcol) then
			if GD.env.verbose then broadcastToAll(pcol.." did not complete all required actions!") end
			for color,player in pairs(GD.game.players) do
				if color ~= pcol then
					player.gold = player.gold + 2
					getObjectFromGUID(C.player_boards[color]).call("setState",{gold_coins=player.gold})
					if GD.env.verbose then printToAll(color.." recieves +2 penalty gold") end
				end
			end
		elseif hasRequiredActions(pcol) then
			UI_setAttribute("penalty_dialog_pnl","visibility","Pink|"..pcol)
			return
		end
		while #player.pending_actions > 0 do
			local index = #player.pending_actions
			local action = player.pending_actions[index]
			if action.key == "track" then
				player.governor_clicked = false
			elseif action.key == "gold" then
				--noop
			elseif action.key == "exchange" then
				if action.bank then
					updateTurnOrder()
				else
					--lock game progression and show confirmation dialog for replace character
					GD.game.wait_for_character_replace = true
					local opp = GD.game.players[action.opponent]
					opp.replace_character = true
					UI_setAttribute("replace_done_pnl","visibility","Pink")
					UI_setAttribute("replace_undo_pnl","visibility","Pink")
					UI_setAttribute("replace_character_txt","text",action.opponent)
					UI_setAttribute("replace_character_txt","color",action.opponent)
					UI_setAttribute("replace_character_pnl","active",true)
				end
			elseif action.key == "palace" then
				log("TESTING: finalize palace action <---------------")
				table.insert(player.placed_palaces, action.guid)
				if #player.placed_palaces == 7 then
					if not(GD.game.game_end_this_round) then
						GD.game.game_end_this_round = true
						broadcastToAll("Player "..pcol.." has built their 7th Palace.")
						broadcastToAll("Game will end after scoring current city!")
					end
				end
			elseif action.key == "quarry" then
				--noop
			elseif action.key == "move" then
				log("TODO: finalize move action, noop?? <---------------")

			elseif action.key == "build" then
				local obj = getObjectFromGUID(action.guid)
				removeFromPlayerBoard(obj)
				player.placed_houses[obj.getGUID()] = obj.getPosition()
			else
				log("*** ERROR: playerDone() unknown action key "..tostring(action.key))
				return
			end
			if env.test.debug then log("Player "..pcol.." finalize "..action.key.." action") end
			table.remove(player.pending_actions, index)
		end
		endTurn(pcol)
	else
		log("*** ERROR: unknown game stage")
	end
end

--[[ *****************************
Check for end of round & start a new one otherwise start next players turn
********************************]]
function endTurn(pcol)
	if env.test.trace then log("endTurn() "..tostring(pcol)) end
	--clear out all player turn data`
	local player = GD.game.players[pcol]
	player.has_actions = false
	player.turn_actions = {}
	player.pointers = {}
	player.pending_actions = {}
	getObjectFromGUID(C.player_pawns[pcol]).setLock(true)
	unplayedPalacesLock(pcol, true)
	buildPoolLock(pcol, true)
	placedHousesLock(pcol, true)
	--update round and check for end of round or end of game
	local index = indexOf(GD.game.remaining_round_players,pcol)
	assert(index > 0,"***ERROR: could not locate player in remaining_round_players")
	table.remove(GD.game.remaining_round_players,index)
	if not(GD.game.wait_for_character_replace) then
		if #GD.game.remaining_round_players == 0 then
			finishCurrentRound()
		else
			startPlayerTurn(setNextPlayer())
		end
	else
		if GD.env.verbose then broadcastToAll("Waiting on a player to select a replacement character") end
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{active=false,done=false,undo=false})
	end
end

--[[ ****************************
Score the current city, check for endgame and advance to next round if not.
********************************]]
function finishCurrentRound()
	if env.test.trace then log("finishCurrentRound()") end
	local city = GD.game.governor_track[7].city
	if GD.env.verbose then printToAll("End of round "..tostring(GD.game.current_round)) end
	scoreCity(city)
	if GD.game.current_round == 10 or GD.game.game_end_this_round then  --TODO: may move to city scoring results dialog ack???
		endGame()
	else
		beginNextRound()
	end
end

--[[ ****************************
Calculate gold payouts for all players with presence in the city.
********************************]]
function scoreCity(city)
	if env.test.trace then log("doCityScoring(): "..tostring(city)) end
	local scores = GD.game.city_scores[city]
	if env.test.debug then
		log("scores for city:")
		log(scores)
	end
	if GD.env.verbose then printToAll("Scoring city: "..tostring(city)) end
	local places = {}
	local player_list = simpleDeepCopy(GD.game.player_order)
	--cull players with 0 score
	for pcol,score in pairs(scores) do
		if score == 0 then
			table.remove(player_list, indexOf(player_list,pcol))
			if GD.env.verbose then printToAll(pcol.." has no presence in city, recieves 0 gold") end
		end
	end
	--rank players by score in city
	local safety = 5
	while #player_list > 0 and safety > 0 do
		local highest = {score=0, player=""}
		for pcol,score in pairs(scores) do
			if contains(player_list, pcol) then
				if score > highest.score then
					highest.score = score
					highest.player = pcol
				elseif score == highest.score then
					if GD.game.players[pcol].character_id < GD.game.players[highest.player].character_id then
						highest.player = pcol
					end
				end
			end
		end
		table.insert(places, highest)
		local index = indexOf(player_list, highest.player)
		table.remove(player_list, index)
		safety = safety - 1
	end
	if #places == 0 then
		log("Handle case nobody scored anything")
		if GD.env.verbose then printToAll("No players recieve gold for city scoring") end
		return
	end
	--hand out money based on score ranking
	local index = 0
	local payouts = C.city_payouts[#GD.game.player_order]
	for i,place in ipairs(places) do
		local pay = payouts[i]
		local player = GD.game.players[place.player]
		player.gold = player.gold + pay
		getObjectFromGUID(C.player_boards[place.player]).call("setState",{gold_coins=player.gold})
		if GD.env.verbose then printToAll(place.player.." recieves "..tostring(pay).." gold for city scoring") end
	end
	--monopoly bonus
	if #places == 1 then
		local place = places[1]
		local player = GD.game.players[place.player]
		player.gold = player.gold + 5
		getObjectFromGUID(C.player_boards[place.player]).call("setState",{gold_coins=player.gold})
		if GD.env.verbose then printToAll(place.player.." recieves 5 gold for city monopoly bonus") end
	end

	--TODO: show a results dialog ???  or is game log enough?

end

--[[ *****************************
TODO: document
--POP an entry off the player's LIFO pending actions stack
--undo any placements, action effects, etc.
--remove the pending action entry
--disable player's done button
--if no remaining pending actinos, disable player's undo button
********************************]]
function playerUndo(pcol)
	if env.test.trace then log("playerUndo(): "..pcol) end
	local function resetAction(pcol, action)
		for _,a in pairs(GD.game.players[pcol].turn_actions) do
			if a.free and action.free_action then a.status = ""; break
			elseif a.index == action.action_index then a.status = ""; break end
		end
	end
	local player = GD.game.players[pcol]
	local actions = player.pending_actions
	if #actions == 0 then return end
	local action = actions[#actions]
	if env.test.debug then log("action to undo:");log(action) end
	if action.key == "select_starting_character" then
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
	elseif action.key == "initial_placement" then
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
		local node = GD.network[action.undo.node_index]
		if node.houses[1] and node.houses[1].g == action.guid then
			node.houses[1] = nil
		elseif node.houses[2] and node.houses[2].g == action.guid then
			node.houses[2] = nil
		else
			log("*** ERROR: playerUndo() unable to clear house "..action.guid.."from network node "..tostring(action.undo.node_index))
		end
	elseif action.key == "track" then
		GD.game.governor_track = simpleDeepCopy(action.undo.restore_list)
		updateGovernorTrack()
		updateStatusPanel()
		governorButtons(true)
		resetAction(pcol, action)
		updateDialUI(pcol)
		player.governor_clicked = false
		action.status = ""
	elseif action.key == "build" then
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
		local node = GD.network[action.undo.node_index]
		if node.type == "city" then
			local i = indexOf(node.houses[pcol], action.guid)
			if i > 0 then
				table.remove(node.houses[pcol], i)
			else
				log("***ERROR: playerUndo() unable to clear house "..action.guid.." from network node "..tostring(action.undo.node_index))
			end
			updateCityScores(node)
			updateStatusPanel()
		else
			if node.houses[1] and node.houses[1].g == action.guid then
				node.houses[1] = nil
			elseif node.houses[2] and node.houses[2].g == action.guid then
				node.houses[2] = nil
			else
				log("*** ERROR: playerUndo() unable to clear house "..action.guid.." from network node "..tostring(action.undo.node_index))
				return
			end
		end
		resetAction(pcol, action)
		player.gold = player.gold + 1
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
		updateDialUI(pcol)
	elseif action.key == "exchange" then
		if action.type == "replace" then --TODO: maybe move this to the dialog btn handler for undo?  get rid of type then perhaps
			local obj = getObjectFromGUID(action.undo.guid)
			obj.setPosition(action.undo.snapback.pos)
			obj.setRotation(action.undo.snapback.rot)
			obj.setLock(false)
			player.replace_character = true
		elseif action.type == "exchange" then
			local new = getObjectFromGUID(action.undo.new_guid)
			local old = getObjectFromGUID(action.undo.old_guid)
			new.setPosition(action.undo.snapback.pos)
			new.setRotation(action.undo.snapback.rot)
			new.setLock(false)
			local player_board = getObjectFromGUID(C.player_boards[action.player_color])
			old.setPosition(player_board.positionToWorld(C.player_board_character_location))
			old.setRotation(player_board.getRotation())
			old.setLock(false)
			player.character_id = action.old_char_id
			setCharacterBonus(pcol)
			local txt = "Execute actions in any order.\n"			--TODO: make this a constant?
			txt = txt.."May move Architect at any time.\n"
			txt = txt.."All required actions must be executed.\n"
			txt = txt..C.character_bonus_descriptions[player.character_id]
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{active=active,done=active,undo=true,help_text=txt})
			if action.undo.extra_actions ~= nil then
				player.extra_actions = player.extra_actions + action.undo.extra_actions
				getObjectFromGUID(C.player_boards[pcol]).call("setState",{extra_actions=player.extra_actions})
			elseif action.undo.gold ~= nil then
				player.gold = player.gold + action.undo.gold
				getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
			elseif action.undo.free_action then
				for i,a in ipairs(player.turn_actions) do
					if a.free then table.remove(player.turn_actions, i); break end
				end
			end
			resetAction(pcol, action)
			updateDialUI(pcol)
		else
			log("*** ERROR: playerUndo() unknown action type")
		end
	elseif action.key == "move" then
		log("TESTING: undo move action <--------------------")
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
		local node = GD.network[action.undo.node_index]
		if node.type == "city" then
			local i = indexOf(node.houses[pcol], action.guid)
			if i > 0 then
				table.remove(node.houses[pcol], i)
			else
				log("***ERROR: playerUndo() unable to clear house "..action.guid.." from network node "..tostring(action.undo.node_index))
			end
			updateCityScores(node)
			updateStatusPanel()
		else
			if node.houses[1] and node.houses[1].g == action.guid then
				node.houses[1] = nil
			elseif node.houses[2] and node.houses[2].g == action.guid then
				node.houses[2] = nil
			else
				log("*** ERROR: playerUndo() unable to clear house "..action.guid.." from network node "..tostring(action.undo.node_index))
				return
			end
		end
		resetAction(pcol, action)
		updateDialUI(pcol)

	elseif action.key == "palace" then
		local obj = getObjectFromGUID(action.guid)
		assert(obj, "***ERROR: no object for palace on undo")
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
		local node = GD.network[action.undo.node_index]
		if node.center_palace and node.center_palace.g == action.guid then
			node.center_palace = nil
		else
			for i,e in ipairs(node.palaces) do
				if e.g == action.guid then
					table.remove(node.palaces, i)
					break
				end
			end
		end
		resetAction(pcol, action)
		player.gold = player.gold + action.cost
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
		updateDialUI(pcol)
		updateCityScores(node)
		updateStatusPanel()

	else
		log("*** ERROR: playerUndo() unknown action key "..tostring(action.key))
		return
	end
	--remove entry and update player board UI
	table.remove(player.pending_actions, index)
	if #player.pending_actions == 0 then
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{undo=false})
	end
end

--[[ ********* TODO **************
TODO: document
********************************]]
function extraAction(pcol)
	if env.test.trace then log("extraAction(): "..pcol) end
	log("TODO: implement extraAction() <--------------------")
end

--[[ *****************************
TODO: implement and document
********************************]]
function moveMaharaja()
	if env.test.trace then log("moveMaharaja()") end
	-- move maha to next city position (1st in gov track table)
	local board = getObjectFromGUID(C.board_guid)
	local track = GD.game.governor_track
	local city = track[1].city
	local pos = board.positionToWorld(C.cities[city].maharaja_pos)
	local maha = getObjectFromGUID(C.maharaja_guid)
	maha.setLock(false)
	maha.setPosition(pos)
	Wait.condition(function() maha.setLock(true) end, function() return(maha.resting) end, 2)
	-- move table 1st to 7th, shift others up
	local temp = simpleDeepCopy(track[1])
	temp.UI_row = track[7].UI_row
	temp.track_row = track[7].track_row + 1
	for i=2,7 do
		track[i-1] = simpleDeepCopy(track[i])
		track[i-1].UI_row = track[i-1].UI_row + 1
	end
	track[7] = temp
	-- update city status UI
	updateGovernorTrack()
	updateStatusPanel()
end

--[[ ********* TODO **************
TODO: implement and document
********************************]]
function endGame()
	if env.test.trace then log("endGame(): "..pcol) end
	log("TODO: implement endGame() <--------------------")
end

--[[/////////////// Support functions /////////////////////]]

--[[ *****************************
Set the character bonus based on current character ID.
If character is Builder (#5) then add a free build action
Update dial UI
********************************]]
function setCharacterBonus(pcol)
	if env.test.trace then log("setCharacterBonus()") end
	local player = GD.game.players[pcol]
	log("Player character ID = "..tostring(player.character_id))
	player.character_bonus = nil
	if player.character_id == 7 then player.character_bonus = "+1_extra_action"
	elseif player.character_id == 6 then player.character_bonus = "build_palace_discount"
	elseif player.character_id == 5 then
		local has_free_action = false
		for _,a in ipairs(player.turn_actions) do
			if a.free then has_free_action = true; break end
		end
		if not(has_free_action) then --TODO: is this check necessary?  Is there a scenario player had it, then gets it back? Possibly.
			local action = simpleDeepCopy(C.dial_actions[9].actions[1])
			action.status = ""
			action.pointer_id = ""
			action.free = true
			table.insert(player.turn_actions,action)
		end
		player.character_bonus = "free_build_move"
	elseif player.character_id == 4 then player.character_bonus = "free_travel"
	elseif player.character_id == 3 then player.character_bonus = "outer_palace_scoring"
	elseif player.character_id == 2 then player.character_bonus = "+1_gold"
	else
		log("***ERROR: setCharacterBonus() Unknown character id for "..tostring(pcol))  --debugging
	end
	updateDialUI(pcol)
end

--[[ *****************************
Searches player's turn actions for an unfinished pointer (selected) action matching the
supplied pending action key.
if one is found, the pending_action table is updated with the corresponding player's turn_actions index.
If not, then the pending_action is updated with a -1 to indicate no corresponding turn action.
********************************]]
function setActionIndex(pcol, pending_action)
	if env.test.trace then log("setActionIndex(): "..tostring(pcol)) end
	local action_index = -1
	local player = GD.game.players[pcol]
	for i,a in ipairs(player.turn_actions) do
		if a.id == pending_action.key and a.status == "" and a.pointer_id ~= "" then
			action_index = i
			break
		end
	end
	if action_index == -1 then
		if env.test.debug then log("setActionIndex(): No matching turn action found for "..tostring(pending_action.key)) end
	end
	pending_action.action_index = action_index
end

--[[ *****************************
Searches player's turn actions for an unfinished action matching the supplied pending action.
if supplied action is "free" then only checks for free dial action.
Otherwise searches all dial actions.
if one is found, it is set to "Done" (finished) and returns true.
If no unfinished matching action is found returns false.
TODO: get rid of return value, earlier calls to hasAvailableAction() should prevent a failed lookup here.
HACK: special case for city only build
********************************]]
function updateTurnAction(pcol, pending_action)
	if env.test.trace then log("updateTurnAction() "..tostring(pcol)..", "..tostring(pending_action.key)) end
	local player = GD.game.players[pcol]
	local success = false
	if pending_action.free_action then   --TODO: FIX free_action
		for _,a in ipairs(player.turn_actions) do
			if a.free then
				a.status = "Done"
				success = true
				break
			end
		end
	else
		for index,a in ipairs(player.turn_actions) do
			if a.index == pending_action.action_index then
				if a.city_required then
					if pending_action.location == "city" then    --HACK: ugly special case
						a.status = "Done"
						success = true
						break
					end
				else
					a.status = "Done"
					success = true
					break
				end
			end
		end
	end
	if not(success) then
		--this really shouldn't happen if earlier checks are working, here for debugging
		log("***ERROR: updateTurnAction() could not locate turn action for pending action:")
		log(pending_action)
	end
end

--[[ *****************************
TODO: need this in a fn?
********************************]]
function failedActions(pcol)
	if env.test.trace then log("failedActions() "..tostring(pcol)) end
	for _,action in ipairs(GD.game.players[pcol].turn_actions) do
		if not(action.free) and action.status == "Failed" then return true end
	end
	return false
end

--[[ *****************************
Check to see if a player has any unfinished required actions.
Return true if any, false if not.
********************************]]
function hasRequiredActions(pcol)
	if env.test.trace then log("hasRequiredActions() "..tostring(pcol)) end
	for id,action in pairs(GD.game.players[pcol].turn_actions) do
		if not(action.free) and action.status == "" then return true end
	end
	return false
end

--[[ *****************************
Check to see if a player has any unfinished action of specified action id.
Return true if any, false if not.
********************************]]
function hasAvailableAction(pcol, pending_action)
	if env.test.trace then log("hasAvailableAction() "..tostring(pcol)..", key = "..tostring(pending_action.key)) end
	for id,action in pairs(GD.game.players[pcol].turn_actions) do
		if action.id == pending_action.key and action.status == "" then
			if action.city_required then
				if pending_action.location == "city" then  --HACK: ugly special case
					return true
				end
			else
				return true
			end
		end
	end
	return false
end

--[[ *****************************
Set the locked state of a player's houses in the build pool
********************************]]
function buildPoolLock(pcol, locked)
	if env.test.trace then log("buildPoolLock()") end
	locked = locked or false
	for _,e in ipairs(GD.game.players[pcol].pool) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of a player's unplayed palaces
********************************]]
function unplayedPalacesLock(pcol, locked)
	if env.test.trace then log("unplayedPalacesLock()") end
	locked = locked or false
	for _,e in ipairs(GD.game.players[pcol].palaces) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of a player's placed houses
********************************]]
function placedHousesLock(pcol, locked)
	if env.test.trace then log("placedHousesLock()") end
	locked = locked or false
	for g,_ in pairs(GD.game.players[pcol].placed_houses) do
		local o = getObjectFromGUID(g)
		if o then
			o.setLock(locked)
		else
			log("***ERROR: unable to unlock placed house for "..tostring(g))
		end
	end
end

--[[ *****************************
Set the locked state of a palaces on a player board
Defaults to unlocked
********************************]]
function palacesLock(pcol, locked)
	locked = locked or false
	if env.test.trace then log("palacesLock() "..tostring(locked)) end
	for _,e in ipairs(GD.game.players[pcol].palaces) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of a player's build pool
Defaults to unlocked
********************************]]
function poolLock(pcol, locked)
	locked = locked or false
	if env.test.trace then log("poolLock() "..tostring(locked)) end
	for _,e in ipairs(GD.game.players[pcol].pool) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of all characters.
If pcol supplied, skip it.
Defaults to unlocked
********************************]]
function charactersLock(pcol, locked)
	locked = locked or false
	pcol = pcol or "none"
	if env.test.trace then log("charactersLock() player: "..tostring(pcol)..", locked = "..tostring(locked)) end
	local player = getObjectFromGUID(pcol)
	for id,char in ipairs(C.characters) do
		if not(player) or player.character_id ~= id then
			getObjectFromGUID(char.g).setLock(locked)
		end
	end
end

--[[ ***************************
For a given network node (that is a city) update the
City score for each player
********************************]]
function updateCityScores(node)
	if env.test.trace then log("updateCityScores() "..tostring(node.name)..", "..tostring(node.id)) end
	assert(node.type == "city", "***ERROR: updateCityScores() node "..tostring(node.id).." is not a city")
	for _,pcol in ipairs(GD.game.player_order) do
		local score = #node.houses[pcol]
		if GD.game.players[pcol].architect_location.current_node == node.id then score = score + 1 end
		for _,palace in pairs(node.palaces) do
			if palace.c == pcol then
				if GD.game.players[pcol].character_id == 3 then
					score = score + 2
				else
					score = score + 1
				end
			end
		end
		if node.center_palace then
			if node.center_palace.c == pcol then score = score + 3 end
		end
		GD.game.city_scores[node.name][pcol] = score
	end
end

--[[ ***************************
Update city names and images from GD.game.governor_track
Update corresponding player score for each associated city
********************************]]
function updateStatusPanel()
	if env.test.trace then log("updateStatusPanel()") end
	for i,gov in ipairs(GD.game.governor_track) do
		UI_setAttribute("status_city_name_"..gov.UI_row, "text", gov.city)
		UI_setAttribute("status_city_image_"..gov.UI_row, "image", gov.city)
		local scores = GD.game.city_scores[gov.city]
		for pcol,score in pairs(scores) do
			if score > 0 then
				UI_setAttribute("status_p_text_"..tostring(gov.UI_row).."_"..pcol,"text",tostring(score))
			else
				UI_setAttribute("status_p_text_"..tostring(gov.UI_row).."_"..pcol,"text","")
			end
		end
	end
end

--[[ *****************************
Remove an object from player board data.
********************************]]
function removeFromPlayerBoard(obj)
	if env.test.trace then log("removeFromPlayerBoard()") end
	local player = GD.game.players[obj.getName()]
	assert(player,"*** ERROR: removeFromPlayerBoard() could not locate player data")
	if obj.memo == "palace" then
		for i,data in ipairs(player.palaces) do
			if data.g == obj.getGUID() then
				player.palaces[i].g = nil
				return
			end
		end
	else
		for i,data in ipairs(player.pool) do
			if data.g == obj.getGUID() then
				player.pool[i].g = nil
				return
			end
		end
	end
	log("*** WARN: could not find object "..obj.getGUID().." in "..obj.getName().." data")
end

--[[ *****************************
Search all players placed object lists for this guid.
Return snap pos if any, nil if not.
--TODO: replace with list of placed guids for cheaper lookup?
********************************]]
function placedObjSnap(guid)
	if env.test.trace then log("placedObjSnap()") end
	local obj = getObjectFromGUID(guid)
	assert(obj, "***ERROR: placedObjSnap() unable to get object ref")
	for _,pcol in ipairs(GD.game.player_order) do
		local list = {}
		if obj.memo == "house" then
			list = GD.game.players[pcol].placed_houses
		elseif obj.memo == "palace" then
			list = GD.game.players[pcol].placed_palaces
		elseif obj.memo == "architect" then
			if obj.getName() == pcol then return GD.game.players[pcol].architect_location.snapback end
		end
		if list[guid] then return list[guid] end
	end
	return nil
end

--[[ *****************************
Return true if a Village is full per number of plaayers
and number of houses placed in the village.
TODO: need this in a fn? Used only once?
********************************]]
function isVillageFull(node)
	if GD.game.player_count == 2 and #node.houses == 1 then return true
	elseif GD.game.player_count > 2 and #node.houses == 2 then return true end
	return false
end

--[[ *****************************
Return the snap back playerboard location for an object.
Playerboard determined from object name(color))
********************************]]
function getPlayerBoardLocation(obj)
	if env.test.trace then log("getPlayerBoardLocation() "..tostring(obj.getGUID())) end
	local color = obj.getName()
	for _,d in ipairs(GD.game.players[color].pool) do
		if d.g == obj.getGUID() then return d.p end
	end
	for _,d in ipairs(GD.game.players[color].palaces) do
		if d.g == obj.getGUID() then return d.p end
	end
	for _,d in ipairs(GD.game.players[color].quarry) do
		if d.g == obj.getGUID() then return d.p end
	end
end

--[[ *****************************
Update game player order sorted by current player character IDs
TODO: actually update and update UI
********************************]]
function updateTurnOrder()
	if env.test.trace then log("updateTurnOrder()") end
	--sort player order by character ID
	local new_order = nil
	for pcol,pdata in pairs(GD.game.players) do
		if new_order == nil then
			new_order = {pcol}
		else
			for i,player_color in ipairs(new_order) do
				if pdata.character_id < GD.game.players[player_color].character_id then
					table.insert(new_order, i, pcol)
					break
				elseif i == #new_order then
					table.insert(new_order, pcol)
					break
				end
			end
		end
	end
	GD.game.player_order = simpleDeepCopy(new_order)
	if env.test.debug then
		log("New player order sorted by char ID:")
		log(GD.game.player_order)
	end
	for i,pcol in ipairs(GD.game.player_order) do
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		player_board.call("setState",{turn_order=i})
	end
end

--[[ *****************************
Set the next active player.
Clockwise from current player if selecting initial characters.
Uses order sorted by character ID in other stages of play.
Returns color of current player
********************************]]
function setNextPlayer(first)
	first = first or false
	if env.test.trace then log("setNextPlayer()") end
	local old_color = GD.game.current_player_color
	if first then
		GD.game.current_player = 1
	elseif GD.game.stage == "select_starting_characters" then
		local next = GD.game.current_player + 1
		if next > #GD.game.player_order then next = 1 end
		GD.game.current_player = next
	else
		if GD.game.stage == "initial_placement" then
			--find first player in order that needs to place this round of placements
			for i,pcol in ipairs(GD.game.player_order) do
				if GD.game.players[pcol].init_placements == GD.game.init_placement then
					GD.game.current_player = i
					break
				end
			end
		else
			--find first player in order that has actions
			for i,pcol in ipairs(GD.game.player_order) do
				if GD.game.players[pcol].has_actions then
					GD.game.current_player = i
					break
				end
			end
		end
	end
	GD.game.current_player_color = GD.game.player_order[GD.game.current_player]
	broadcastToAll("Current player now "..GD.game.current_player_color)
	if env.test.players and env.test.auto_switch then
		if old_color != GD.game.current_player_color then
			Player[old_color].changeColor(GD.game.current_player_color)
		end
	end
	return GD.game.current_player_color
end

--[[ *****************************
Locate the closest network node to the position.
TODO: be smarter about city radius vs village radius.
As is the radius is equal so dropping in a city edge
might detect as a nearby village.  Minor thing.
********************************]]
function closestNode(pos)
	if env.test.trace then log("closestNode()") end
	assert(pos, "***ERROR: closestNode() missing pos")
	local board = getObjectFromGUID(C.board_guid)
	local nearest_node = -1
	local shortest_dist = nil
	for i,node in ipairs(GD.network) do
		local dist = Vector.sqrDistance(pos, board.positionToWorld(node.center))
		if shortest_dist then
			if dist < shortest_dist then
				shortest_dist = dist
				nearest_node = i
			end
		else
			shortest_dist = dist
			nearest_node = i
		end
	end
	return nearest_node
end

--[[ *****************************
Lookup and return the id for a character card guid
Returns -1 if not found (log an error)
********************************]]
function getCharacterId(guid)
	for id,char in ipairs(C.characters) do
		if char.g == guid then
			return id
		end
	end
	log("*** ERROR: getCharacterId(): no character card found for guid "..tostring(guid))
	return -1
end

--[[ *****************************
TODO: implement and document
********************************]]
function governorButtons(on)
	on = on or false
	if env.test.trace then log("enableGovernorButtons() "..tostring(on)) end
	local board = getObjectFromGUID(C.board_guid)
	for _,gov in ipairs(GD.game.governor_track) do
		local id = "gov_"..tostring(gov.track_row)
		if on then
			log("Turn button on for image in row "..id)
			board.UI.setClass(id ,"gImg_")
		else
			log("Turn button off for image in row "..id)
			board.UI.setClass(id,"gImg")
		end
	end
	Wait.frames(function() reloadUI(C.board_guid) end, 60)
end

--[[ *****************************
Update the dial UI for a player with player's current action state
********************************]]
function updateDialUI(pcol)
	if env.test.trace then log("updateDialUI() "..tostring(pcol)) end
	local player = GD.game.players[pcol]
	local dial = getObjectFromGUID(C.action_dials[pcol])
	for i=1,7 do
		dial.UI.setAttribute("row_action_"..tostring(i),"active",false)
	end
	local row = 0
	for _,action in ipairs(player.turn_actions) do
		log("updating dial UI with dial_action: "..tostring(action.id))   --TODO: LOGGING
		log(action)
		if action.free then
			dial.UI.setAttribute("action_text_7", "text", action.label)
			dial.UI.setAttribute("action_text_7", "color", "rgb(1,1,0)")
			dial.UI.setAttribute("row_action_7", "active", true)
			dial.UI.setAttribute("status_text_7", "text", action.status)
			if action.status == "Done" then
				dial.UI.setAttribute("action_text_7", "color", "Gray")
			end
		else
			row = row + 1
			dial.UI.setAttribute("action_text_"..tostring(row), "text", action.label)
			dial.UI.setAttribute("action_text_"..tostring(row), "color", "rgb(1,1,0)")
			dial.UI.setAttribute("row_action_"..tostring(row), "active", true)
			dial.UI.setAttribute("status_text_"..tostring(row), "text", action.status)
			if action.status == "Done" then
				dial.UI.setAttribute("action_text_"..tostring(row), "color", "Gray")
			elseif action.status == "Incomplete" then
				dial.UI.setAttribute("action_text_"..tostring(row), "color", "Gray")
				dial.UI.setAttribute("status_text_"..tostring(row), "color", "Red")
			end
		end
	end
end

--[[/////////////// External call functions /////////////////////]]

--[[ ****** TODO: DEPRECATED *********
Called from player dial during player action selection.
params:
	- command:
			- Set: Update player's data with selected action(s), enable Done if both pointers are set.
			- Clear: remove player action data, disable Done (dial modify button clicked)
		player_color: The player color.
		actions: The list of actions for an update (command==set)
********************************]]
function updatePlayerActionSelection(params)
		log("***WARN: updatePlayerActionSelection() is deprecated")
end

--[[ ***************************
Called from player dial during player action selection.
Update player's data with selected action on dial.
Enable Done if actions for both pointer 1 and 2 are set.
params:
		player_color: The player color.
		dial_index: The index on the dial of the selected action
			1-9
		pointer_id: the id of the dial pointer
			'pointer-1', 'pointer-2', 'pointer-3'
********************************]]
function addDialAction(params)
	if env.test.trace then log("addDialAction()") end
	assert(params, "***ERROR addDialAction(): missing params")
	if env.test.debug then log(params) end
	local pcol = params.player_color
	assert(pcol,"***ERROR addDialAction(): missing player_color param")
	local dial_index = params.dial_index
	assert(dial_index, "***ERROR addDialAction(): missing dial_index param")
	local pointer_id = params.pointer_id
	assert(pointer_id, "***ERROR addDialAction(): missing pointer_id param")
	local player = GD.game.players[pcol]

	--TODO: TESTING flatten player actions

	--remove any previous entries for this pointer id
	for i,a in ipairs(player.turn_actions) do
		if a.pointer_id == pointer_id then player.turn_actions[i] = nil end
	end
	--add new actions for this dial index
	for _,a in ipairs(C.dial_actions[dial_index].actions) do
		local action = simpleDeepCopy(a)
		action.index = #player.turn_actions + 1
		action.status = ""
		action.pointer_id = pointer_id
		action.free = false  		--TODO: pick one
		table.insert(player.turn_actions,action)
	end
	player.pointers[pointer_id] = true
	if player.pointers["pointer-1"] and player.pointers["pointer-2"] then
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		player_board.call("setState",{done=true})
	end

	updateDialUI(pcol)
end

--[[/////////////// Network stuff  /////////////////////]]

--[[ *****************************
Setup: initialize network data
********************************]]
function setupNetwork()
	if env.test.trace then log("setupNetwork()") end
	GD.network = simpleDeepCopy(NETWORK)
	for i,node in ipairs(GD.network) do
		node.center = CENTERS[i]
		if node.type == "city" then
			node.houses = {}
			for _,pcol in pairs(C.table_colors) do
				node.houses[pcol] = {}
			end
			node.palaces = {}
			node.architects = {}
		elseif node.type == "village" then
			node.houses = {}
		end
	end
	setupPathTable()
end

--[[ *****************************
Setup: initialize path table
********************************]]
function setupPathTable()
	if env.test.trace then log("setupPathTable()") end
	GD.path_table = simpleDeepCopy(PATH_TABLE)
end

--[[ *****************************
Update path table state and associated costs for given player
Path state is "open" if all villages on Path have at least one house.
Path cost is determined by supplied player color and villages on Path.
	Each village is a table of costs to be paid to colors of opponents
		for each matching house color in the village..
	Villages with at least one house of player's color are free.
Closed Path initialized to an empty cost table.
If no player color given, all Path costs will be initialized to empty.
********************************]]
function updatePathTable(pcol)
	if env.test.trace then log("updatePathTable() "..tostring(pcol)) end
	for i,path in ipairs(GD.path_table) do
		path.open = true
		for _,v in ipairs(path.villages) do
			if #GD.network[v].houses == 0 then
				path.open = false
				break
			end
		end
		path.cost = {}
		if path.open and pcol ~= nil then
			for _,v in ipairs(path.villages) do
				local free = false
				local village_cost = {}
				for _,house in ipairs(GD.network[v].houses) do
					if house.c == pcol then
						free = true
						break
					else
						if village_cost[house.c] then
							village_cost[house.c] = village_cost[house.c] + 1
						else
							village_cost[house.c] = 1
						end
					end
				end
				if not(free) then
					for color,cost in pairs(village_cost) do
						if path.cost[color] then
							path.cost[color] = path.cost[color] + cost
						else
							path.cost[color] = cost
						end
					end
				end
			end
		end
	end
end

--[[ *****************************
Build a table of valid routes between start and destination cities.
NOTE: 'start_id' and 'dest_id' are the city IDs from the network table.  This
has to be converted to index into the CITY_CONNECTIONS table.  TODO: May be
able to consolidate this into one table
Returns a table of discovered routes.
********************************]]
function buildRouteTable(start_id, dest_id)
	if env.test.trace then log("buildRouteTable() start: "..tostring(start_id)..", dest: "..tostring(dest_id)) end
	local sub_debug = false
	local start, dest
	local route_table = {}
	--get the city connection table ids for supplied start and dest network node ids HACK:
	for id,conn in ipairs(CITY_CONNECTIONS) do
		if conn.network_id == start_id then start = id end
		if conn.network_id == dest_id then dest = id end
	end
	if env.test.debug then log("connections start: "..tostring(start)..", dest: "..tostring(dest)) end
	--[[///////////////////////////////////////////////////////////
	Recursively crawl the neighbors of a city.
	Ignore loops back to start.
	Ignore paths already seen.
	Return true if dest found, false if not.
	Paths added to route if dest found.
	///////////////////////////////////////////////////////////////]]
	local function addPaths(id, route)
		if sub_debug then log("addPaths() process city id: "..tostring(id)) end
		if #route.seen > 8 or #route.paths > 16 then log("*****ERROR: addPath() safety exceeded"); return end
		if id == route.dest then
			table.insert(route.seen,id)
			table.insert(route_table, simpleDeepCopy(route)) --save a copy of this route
			return
		end
		table.insert(route.seen, id)
		for _,neighbor in ipairs(CITY_CONNECTIONS[id].neighbors) do
			if not(contains(route.seen, neighbor.id)) and GD.path_table[neighbor.path].open then
				local route_to_here = simpleDeepCopy(route)
				table.insert(route_to_here.paths, neighbor.path)
				addPaths(neighbor.id, route_to_here)
			end
		end
	end
	--[[////////////////////
	Start the crawl
	///////////////////////]]
	for _,neighbor in ipairs(CITY_CONNECTIONS[start].neighbors) do
		if GD.path_table[neighbor.path].open then
			local route = {dest=dest, paths={neighbor.path}, seen={start}}
			if neighbor.id == route.dest then
				table.insert(route.seen, neighbor.id)
				table.insert(route_table, route)
			else
				addPaths(neighbor.id, route)
			end
		end
	end
	return route_table
end



--[[/////////////// DEVELOPMENTAL STUFF ///////////////////////]]

function t_testRecursiveCoro()
	startLuaCoroutine(Global, "testRecursiveCoro")
end

g_limit = 5
g_list = {}
function testRecursiveCoro()
	local limit = g_limit
	-- local list = {}
	local step = 1
	function doit()
		if step > limit then
			log("normal stop")
			return
		end
		if step > 100 then
			log("Hit safety limit")
			return
		end
		table.insert(g_list,step)
		log("Step "..tostring(step))
		step = step + 1
		for i=1,10 do
			coroutine.yield(0)
		end
		doit(step)
	end
	doit()
	log(g_list)
	return 1
end

function testCityHouses(pcol, city_name)
	log("put selected houses in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(city_name.." center is "..tostring(center))
	local color_indexes = {Yellow = 0,Red = 0,Green = 0,Blue = 0,Purple = 0,}
	for _,o in ipairs(stuff) do
		local color = o.getName()
		color_indexes[color] = color_indexes[color] + 1
		local offset = Vector(C.city_house_offsets[color][color_indexes[color]].o)
		log("placing "..color.." object "..o.getGUID().." with offset "..tostring(color_indexes[color])..": "..tostring(offset))
		local pos = center - offset
		local rot = Vector(C.city_house_offsets[color][color_indexes[color]].r)
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function testCityPalaces(pcol, city_name)
	log("put selected houses in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	if #stuff > 7 then
		log("Only 7 palaces max allowed in a city")
		return
	end
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(center)
	for index,o in ipairs(stuff) do
		local offset = Vector(0,0,0)
		if index < 7 then offset = C.city_palace_offsets[index] end
		log("putting object "..o.getGUID().." in loc "..tostring(index)..", at offset "..tostring(offset))
		local pos = center - offset
		local rot = board.getRotation()
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function testCityPawns(pcol, city_name)
	log("put selected pawns in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	if #stuff > 5 then
		log("Only 5 pawns max allowed in a city")
		return
	end
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(center)
	for index,o in ipairs(stuff) do
		local offset = Vector(C.city_pawn_offsets[index])
		log("putting object "..o.getGUID().." in loc "..tostring(index)..", at offset "..tostring(offset))
		local pos = center - offset
		local rot = Vector(0,90,0)
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function getWorldPos(pcol)
	log("Getting positions of selected objects relative to world")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	local s=""
	for i,o in ipairs(stuff) do
    local p = o.getPosition()
		local t = tostring(i)..': '..o.getGUID()..': '..tostring(p)
		log(t)
		s = s .. t .. '\n'
	end
	if s ~= "" then
    Notes.setNotes(s)
  end
end

function getLTB(pcol)
  log("Getting positions of selected objects relative to board")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	--local board = getObjectFromGUID(C.board_guid)
	local board = getObjectFromGUID(C.board_guid)
  local s = ""
  for i,o in ipairs(stuff) do
    log("Processing object #"..tostring(i)..": "..o.getGUID())
    local p = board.positionToLocal(o.getPosition())
    -- local r = Vector(0,180,0)
		-- City house positions
		-- local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},r={'..r.x..','..r.y..','..r.z..'}},'
		local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},r={0,180,0}},'
    log(t)
    s = s .. t .. '\n'
  end
  if s ~= "" then
    Notes.setNotes(s)
  end
end

function getLTPB(pcol)
	log("Getting positions of selected objects relative to player board")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	local board = getObjectFromGUID(C.player_boards[pcol].g)
  local s = ""
  for i,o in ipairs(stuff) do
    log("Processing object #"..tostring(i)..": "..o.getGUID())
    local p = board.positionToLocal(o.getPosition())
		local r = board.getRotation()
		local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},},'
    log(t)
    s = s .. t .. '\n'
  end
  if s ~= "" then
    Notes.setNotes(s)
  end

end

function getOffsets()
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers.Agra
	center.y = 0
	log(center)
	local s = ""
	for i,loc in ipairs(C.ltb) do
		local pos = Vector(loc.p)
		pos.y = 0
		local o = center - pos
		-- local r = Vector(loc.r)
		-- local t = '{o={'..o.x..','..o.y..','..o.z..'},r={'..r.x..','..r.y..','..r.z..'}},'
		local t = '{o={'..o.x..','..o.y..','..o.z..'},r={0,180,0}}'
		log(t)
		s = s .. t .. '\n'
	end
	if s ~= "" then
		Notes.setNotes(s)
	end
end

require("tts-lib/utils")
require("tts-maharaja/Constants")
require("tts-maharaja/Network")
