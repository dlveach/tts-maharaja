-- #include tts-maharaja/Global
--[[///////////////////////////////////////////////////////////////////////////////////////////////

	Maharaja
		TODO: credits

  --TODO:
    - lots of stuff
		-- load/save restore
		-- (opt) starting character auction
		-- UI and implementation for Governor track
		-- Yogi extra action functionality
		-- turn execution, detection and update dial actions
		-- move architect route detection, display
		-- respect verbosity setting

		probablyi a bunch more I'm not thinking of!z

///////////////////////////////////////////////////////////////////////////////////////////////////]]

--[[==========================================================================================
TTS mod for Maharaja

--TODO: documentation

	--TODO: stuff to do
	-- convert playerboards to tile with jpeg vs token with png.  Takes too long to load.
	-- get save load working

	-- lots of implementation for feature complete

	--BUG character free action does not show in dial UI until player turn starts.  Should be in action selection too.

==========================================================================================]]

env = {}
env.test = {}
env.test.trace = true
env.test.debug = true
env.test.in_dev = false
env.test.force_fresh_save = true
env.test.save_positions = true
env.test.auto_switch = true
-- env.test.players = {"Blue","Red","Yellow","Purple","Green",}
-- env.test.players = {"Yellow","Red","Blue","Purple",}
-- env.test.players = {"Yellow","Purple",}
env.test.players = {"Green","Red",}
-- env.test.players = {"Green","Red","Blue"}
-- env.test.players = {"Red","Green","Purple",}

env.game = {}
env.game.fill_delay = 2
env.game.use_help = true

GD = {}

--[[/////////////// Load Save /////////////////]]

--[[ *****************************
TTS Game Load
********************************]]
function onLoad(save_state)
	if env.test.force_fresh_save then saved_data = "" end
	--Initialize stuff
	if not(env.test.in_dev) then
		getObjectFromGUID(C.board_guid).interactable = false
		getObjectFromGUID(C.palace_object_guid).setInvisibleTo(Color.list)
		getObjectFromGUID(C.house_object_guid).setInvisibleTo(Color.list)
		for _,g in pairs(C.action_dials) do
			getObjectFromGUID(g).setInvisibleTo(Color.list)
		end
	end
	UI.setAttribute("penalty_dialog_pnl","visibility","Pink")
	UI.setAttribute("penalty_dialog_pnl","active","true")
	--Reload saved data or if fresh load initialize everything
	if (saved_data ~= "") then
    log("onLoad(): load with saved data")
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
    restoreGameState()
  else
		log("onLoad(): load with fresh state")
		GD.state = {}
		GD.state.global_UI = {}
		GD.state.board_UI = {}
		GD.game = {}
		GD.game.stage = "setup"
		GD.game.round = 1
		GD.env = {}
		GD.env.use_auction = false
		UI.setAttribute("opt_use_auction","isOn",GD.env.use_auction)
		GD.env.verbose = true
		UI.setAttribute("opt_verbose","isOn",GD.env.verbose)
		for _,g in pairs(C.player_pawns) do
			getObjectFromGUID(g).setLock(true)
		end
	end
end

--[[ *****************************
HACK: reload an object's XML UI
********************************]]
function reloadUI(guid)
	if env.test.trace then log("reloadUI() guid: "..tostring(guid)) end
	if guid then
		local obj = getObjectFromGUID(guid)
		if obj ~= nil then
			obj.UI.setXml(obj.UI.getXml())
		else
			log("***WARN: reloadUI() unable to get object for "..tostring(guid))
		end
	else
		UI.setXml(UI.getXml())
	end
end

--[[ *****************************
Save game state
********************************]]
function onSave()
	local saved_data = JSON.encode(GD)
  if env.test.force_fresh_save then
    saved_data = ""
  end
  return saved_data
end

--[[ *****************************
Restore the game state.
TODO: implement
********************************]]
function restoreGameState()
	if env.test.trace then log("restoreGameState()") end
	log("TODO: restoreGameState()")
	--TODO: TEST THIS: rebuild the status display XML
	if GD.game.stage ~= "setup" then
		setupStatusPanel()
		updateGovernorTrack()
		updateStatusPanel()
		for _,pcol in ipairs(GD.game.player_order) do
			if GD.game.players[pcol].dial_actions ~= nil then updateDialUI(pcol) end
			if GD.game.stage == "select_actions" then
				local dial = getObjectFromGUID(C.action_dials[pcol])
				dial.call("enableDialButtons")
				dial.call("hideMe")
				if dial.is_face_down then dial.call("flipMe") end
			elseif GD.game.stage == "player_turns" then
				--TODO: this
				log("TODO: handle restore during player_turns game stage <----------------")
			end
		end
	end

	--TODO: replay global UI setattributes

	--TODO: replay main board UI setattributes

	--TODO: confirm UI restore for all player boards handled in board onLoad() ???

	UI.setAttribute("status_info","visibility",GD.game.status_visibility)
end

--[[ ******************************
Wrapper function for global UI attributes.
Saves attribute update to be replayed on restore.
TODO: convert calls to use
*********************************]]
function UI_setAttribute(id, field, value)
  if env.test.trace2 then log("UI_setAttribute()") end
  assert(type(id) == "string", "UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "UI_setAttribute(): field must be a string")
  assert(value or value==false, "UI_setAttribute(): value missing")
  GD.states.global_UI[id.."|"..field] = value
  UI.setAttribute(id, field, value)
end

--[[ ******************************
Wrapper function for saving board UI attributes.
Saves attribute update to be replayed on restore.
TODO: convert calls to use
*********************************]]
function board_UI_setAttribute(id, field, value)
	if env.test.trace2 then log("board_UI_setAttribute()") end
	assert(type(id) == "string", "board_UI_setAttribute(): id must be a string")
	assert(type(field) == "string", "board_UI_setAttribute(): field must be a string")
	assert(value or value==false, "board_UI_setAttribute(): value missing")
	GD.states.board_UI[id.."|"..field] = value
	return getObjectFromGUID(C.board_guid).UI.setAttribute(id, field, value)
end

--[[/////////////// Event handlers /////////////////]]

--[[ *****************************
TODO: Thinking about these
********************************]]
function mouseOverCity(arg)
	log("mouse over")
	log(arg)
end
function mouseExitCity(arg)
	log("mouse exit")
	log(arg)
end
function mouseClickCity(arg)
	log("mouse click city")
	log(arg)
end

--[[ *****************************
Setup: Handler for start game options
********************************]]
function startOptionsBtn(player, value, id)
	if env.test.trace then log("startGameBtn() "..player.color..", "..id..": "..tostring(value)) end
	local setting = (value == 'True')
	UI.setAttribute(id, "isOn", setting)
	if id == "opt_use_auction" then
		broadcastToAll("Sorry, not yet imlemented")		--TODO: remove this when imlpemented
		UI.setAttribute(id, "isOn", false)
		return
		-- GD.env.use_auction = setting
	elseif id == "opt_verbose" then
		GD.env.verbose = setting
	else
		log("*** ERROR: startOptionsBtn() unknown id "..tostring(id))
	end
end

--[[ *****************************
Setup: A player clicked start game.
********************************]]
function startGameBtn(player, btn, id)
	if env.test.trace then log("startGameBtn() "..player.color) end
	if not(env.test.players) and #getSeatedPlayers() < 2 then
		broadcastToAll("At least 2 players needed to play")
		return
	end
	UI.setAttribute("startPanel","active",false)
	Wait.frames(function() startGame() end, 10)
end

--[[ *****************************
Player clicked a row on the Governor track
********************************]]
function governorClick(player, btn, id)
	if env.test.trace then log("governorClick() "..player.color..", id: "..tostring(id)) end
	if player.color ~= GD.game.current_player_color then return end
	if GD.game.players[player.color].governor_clicked then return end --guard double clicks
	GD.game.players[player.color].governor_clicked = true
	local track = GD.game.governor_track
	-- build a pending action and store current order in undo
	local row_clicked = tonumber(Split(id,'_')[2])
	local pending_action = {
		key = "track",
		player_color = pcol,	--TODO: need this?
		row_clicked = row_clicked,  --TODO: need this?
		undo = {
			restore_list = simpleDeepCopy(track),
		}
	}
	if updateDialAction(player.color, pending_action) then
		table.insert(GD.game.players[player.color].pending_actions, pending_action)
		--find the data table index for the clicked row
		local index = -1
		for i=1,7 do
			if track[i].track_row == row_clicked then
				index = i
				break
			end
		end
		assert(index > 0,"***ERROR: bad track index")
		-- move down two (or one or zero) spots in track table, shift others up
		local temp = simpleDeepCopy(track[index])
		temp.track_row = temp.track_row - 2
		if temp.track_row < 1 then temp.track_row = 1 end
		temp.UI_row = temp.UI_row + 2
		if temp.UI_row > 7 then temp.UI_row = 7 end
		local new_index = index - 2
		if new_index < 1 then new_index = 1 end
		for i = index, new_index+1, -1 do
			track[i] = simpleDeepCopy(track[i-1])
			track[i].track_row = track[i-1].track_row + 1
			track[i].UI_row = track[i-1].UI_row - 1
		end
		track[new_index] = temp
		updateGovernorTrack()
		updateStatusPanel()
		governorButtons(false)
		updateDialUI(player.color)
		getObjectFromGUID(C.player_boards[player.color]).call("setState",{undo=true})
	end
end

--[[ *****************************
Handler for button clicks on player board
********************************]]
function playerBoardClick(player, btn, id)
	if env.test.trace then log("playerBoardClick(): "..player.color..", id = "..id) end
	local action = Split(id,'_')[1]
	if action == "done" then
		playerDone(player.color)
	elseif action == "undo" then
		playerUndo(player.color)
	elseif action == "extraAction" then
		extraAction(player.color)
	else
		log("*** ERROR: playerBoardClick(): unknown action id")
		return
	end
end

--[[ *****************************
Toggle the city status display for the player who clicked.
********************************]]
function statusClick(player, btn, id)
	if env.test.trace then log("statusClick() id: "..tostring(id)) end
	-- if env.test.debug then log(GD.game.status_visibility) end
	local players = Split(GD.game.status_visibility,'|')
	local index = indexOf(players, player.color)
	if index > 0 then
		table.remove(players,index)
	else
		table.insert(players,player.color)
	end
	GD.game.status_visibility = ""
	for _,pcol in ipairs(players) do
		if GD.game.status_visibility == "" then
			GD.game.status_visibility = pcol
		else
			GD.game.status_visibility = GD.game.status_visibility .."|"..pcol
		end
	end
	-- if env.test.debug then log("Setting vis to "..GD.game.status_visibility) end
	UI.setAttribute("status_info","visibility",GD.game.status_visibility)
end

--[[ *****************************
Handle dropping things on the main board.
House and palace drops off board are snapped back.
TODO: disable DEVELOPMENT stuff
********************************]]
function onObjectDrop(pcol, obj)
	if env.test.trace then log("onObjectDrop(): pcol "..pcol..", obj "..obj.getGUID()) end
	--/// DEV ///
	if env.test.save_positions then
		str = "Global: "
		str = str .. tostring(obj.getPosition())
		str = str .. "\nBoard: "
		str = str .. tostring(getObjectFromGUID(C.board_guid).positionToLocal(obj.getPosition()))
		Notes.setNotes(str)
	end
	--/// END DEV ///
	if GD.game.stage == "setup" then return end
	local type = obj.memo
	obj.setVelocity(Vector(0,0,0)) --in case player "throws it"
	if type == "character" then
		characterDrop(pcol, obj)
	elseif type == "palace" or type == "house" then
		local pos = obj.getPosition()
		local board = getObjectFromGUID(C.board_guid)
		local center = board.getBounds()["center"]
	  local size = board.getBounds()["size"]
		local snapback = false
		if pcol ~= GD.game.current_player_color then snapback = true
		elseif obj.getName() ~= pcol then snapback = true
	  elseif pos.x > center.x + (size.x/2) then snapback = true
	  elseif pos.x < center.x - (size.x/2) then snapback = true
	  elseif pos.z > center.z + (size.z/2) then snapback = true
	  elseif pos.z < center.z - (size.z/2) then snapback = true
		end
		if snapback then
			--TODO: consider use an array of GD.snaps for placed objects?  Use player board home loc if not in that list?
			obj.setPosition(getPlayerBoardLocation(obj))
			obj.setRotation(getObjectFromGUID(C.player_boards[obj.getName()]).getRotation())
			return
		end
		if type == "house" then
			houseDrop(pcol, obj)
		else
			palaceDrop(pcol, obj)
		end
	elseif type == "architect" then
		architectDrop(pcol, obj)
	else
		log("*** WARN: onObjectDrop() unknown object "..obj.getGUID())
		return
	end
end

--[[ ********* TODO **************
--TODO: implement and document
********************************]]
function extraActionClick(obj, pcol, rclick)
	log("extraActionClick() "..obj.getName()..", "..pcol..", "..tostring(rclick))
	log("TODO: extraActionClick()  <--------------------------")
end

--[[ *****************************
End turn with required actions penalty dialog.
If 'Cancel', return to turn actions.
if 'OK' then set failed status on remaining actions and end turn.
********************************]]
function penaltyDialogBtn(player, btn, id)
	log("penaltyDialogBtn() "..player.color..", "..tostring(id))
	if player.color ~= GD.game.current_player_color then return end
	local action = Split(id,'_')[3]
	if env.test.debug then log("action is "..tostring(action)) end
	if action == "ok" then
		for _,action in ipairs(GD.game.players[player.color].dial_actions) do  --TODO: this feels a bit HACK ish, is there a better way?
			if action.type == "selected" and action.status ~= "Done" then
				action.status = "Failed"
			end
		end
		endTurn(player.color)
	elseif action == "cancel" then
		--noop
	else
		log("***ERROR: unknown action")
		return
	end
	UI.setAttribute("penalty_dialog_pnl","visibility","Pink")
end

--[[ *****************************
Handler for modify button click (back of dial).
Flip dial face up and set state back to action selection.
Enable done button on player board.
********************************]]
function dialModifyClick(player, btn, id)
	if env.test.trace then log("dialModifyClick(): id="..tostring(id)) end
  -- if player.color ~= GD.color then return end
	local dial = getObjectFromGUID(C.action_dials[player.color])
	dial.call("hideMe")
	dial.call("enableDialButtons")
	if dial.is_face_down then dial.call("flipMe") end
	getObjectFromGUID(C.player_boards[player.color]).call("setState",{done=true,undo=false})
end

--[[/////////////// Game Setup /////////////////////]]

--[[ *****************************
Randomly assign the 7 Governors to starting positions on the track.
********************************]]
function setupGovernorTrack()
	if env.test.trace then log("setupGovernorTrack()") end
	local temp = simpleDeepCopy(C.governors)
	local row = 0
	local ref = 7
	GD.game.governor_track = {}
	while #temp > 0 do
		local i = math.random(#temp)
		row = row + 1
		if row > 7 then
			log("*** ERROR: setupGovernorTrack() exceeded safety stop, too many rows")
			return
		end --safety
		table.insert(GD.game.governor_track,{city=temp[i].city,node=temp[i].node,track_row=row, UI_row=ref, scoring=false})
		table.remove(temp,i)
		ref = ref - 1
	end
	updateGovernorTrack()
end

--[[ *****************************
Update the board UI with Governor images on the track.
Assumes governor track data has been initialized.
********************************]]
function updateGovernorTrack()
	if env.test.trace then log("updateGovernorTrack()") end
	local board = getObjectFromGUID(C.board_guid)
	--fill base track images
	for row=1,17 do
		if row > 7 then
			board.UI.setAttribute("gov_"..tostring(row),"image","Gray-"..(row-7))
		else
			board.UI.setAttribute("gov_"..tostring(row),"image","Gray")
		end
	end
	--set the governor images per gov track data table, overwriting base image set above
	for i,entry in ipairs(GD.game.governor_track) do
		board.UI.setAttribute("gov_"..tostring(entry.track_row),"image",entry.city)
	end
end

--[[ *****************************
Setup: initialize the game
********************************]]
function startGame()
	if env.test.trace then log("startGame()") end
	-- GD.game.stage = "setup"
	GD.game.auction_characters = false --TODO: get this from start dialog
	setupGovernorTrack()
	setupNetwork()
	if not(setupPlayers()) then return end
	setupStatusPanel()
	UI.setAttribute("statusPanel","active","true")
	--for testing, set solo player to start player color
	local players = Player.getPlayers()
	if #players == 1 then
		if env.test.players and env.test.auto_switch then
			Player[players[1].color].changeColor(GD.game.current_player_color)
		end
	end
end

--[[ *****************************
Setup: setup the status UI for number of players
Assumes GD.game.player_order is established.
********************************]]
function setupStatusPanel()
	if env.test.trace then log("setupStatusPanel()") end
	local letters = {Yellow="Y",Red="R",Green="G",Blue="B",Purple="P",}
	local xml=UI.getXmlTable()
	local status_panel = getXmlElement("statusPanel",xml)
	local status_table = getXmlElement("status_table",status_panel)
	local columnWidths="100 40"
	local panel_width = 140
	--setup the header row
	local index = 3
	local player_columns = {}
	local header_row = getXmlElement("status_header_row",status_table)
	local header_cell = getXmlElement("status_h_template",header_row)
	for pcol,initial in pairs(letters) do
		if contains(GD.game.player_order,pcol) then
			table.insert(player_columns, pcol)
			local cell = simpleDeepCopy(header_cell)
			cell.attributes.id = "status_h_"..pcol
			local text = cell.children[1]
			text.attributes.id = "status_h_txt_"..pcol
			text.attributes.color = pcol
			text.attributes.text = initial
			header_row.children[index] = cell
			columnWidths = columnWidths.." 36"
			panel_width = panel_width + 36
			index = index + 1
		end
	end
	--setup the city rows
	local city_row = getXmlElement("status_row_template",status_table)
	local temp_row = simpleDeepCopy(city_row)
	local player_cell = getXmlElement("status_p_template",temp_row)
	status_table.children[2] = nil --wipe out the template so it can be replaced
	for i,gov in ipairs(GD.game.governor_track) do
		local row = simpleDeepCopy(temp_row)
		local ref = gov.UI_row
		log("creating row for child "..tostring(ref))
		row.attributes.id = "status_row_"..tostring(ref)
		local text = getXmlElement("status_city_name_template",row)
		text.attributes.id = "status_city_name_"..tostring(ref)
		text.attributes.text = gov.city
		local image = getXmlElement("status_city_image_template",row)
		image.attributes.id = "status_city_image_"..tostring(ref)
		image.attributes.image = gov.city
		for p,pcol in ipairs(player_columns) do
			local pcell = simpleDeepCopy(player_cell)
			local ptext = getXmlElement("status_p_text_template",pcell)
			ptext.attributes.id = "status_p_text_"..tostring(ref).."_"..pcol
			ptext.attributes.text = ""
			row.children[2+p] = pcell
		end
		table.insert(status_table.children,2,row) --always next after header, pushing rest downward
	end
	if env.test.debug then
		log("status table")
		-- log(status_table.children)
		for i,c in ipairs(status_table.children) do
			if i > 1 then
				log(tostring(i)..": id:"..c.attributes.id)
				log(c.children[2].children[1].attributes)
			end
		end
	end
	--reload the xml UI
	status_panel.attributes.width = tostring(panel_width)
	status_table.attributes.columnWidths = columnWidths
	UI.setXmlTable(xml)
end

--[[ *****************************
Setup: initialize network data
********************************]]
function setupNetwork()
	if env.test.trace then log("setupNetwork()") end
	GD.network = simpleDeepCopy(NETWORK)
	for i,node in ipairs(GD.network) do
		node.center = CENTERS[i]
		if node.type == "city" then
			node.houses = {}
			for _,pcol in pairs(C.table_colors) do
				node.houses[pcol] = {}
			end
			node.palaces = {}
			node.architects = {}
		elseif node.type == "village" then
			node.houses = {}
		end
	end
end

--[[ *****************************
Setup: initialize game for seated players
********************************]]
function setupPlayers()
	if env.test.trace then log("setupPlayers()") end
	local seated = getSeatedPlayers()
	if env.test.players ~= nil then
		seated = simpleDeepCopy(env.test.players)
	end
	GD.game.player_count = #seated
	if GD.game.player_count < 2 then
		broadcastToAll("2 or more players needed")
		return false
	end
	GD.game.player_order = {}
	for _,pcol in ipairs(C.table_colors) do
		if contains(seated,pcol) then table.insert(GD.game.player_order,pcol) end
	end
	GD.game.players = {}
	GD.game.status_visibility = "Pink"
	for _,pcol in ipairs(GD.game.player_order) do
		reloadUI(C.player_boards[pcol])
		GD.game.players[pcol] = simpleDeepCopy(C.player_data)
		local player = GD.game.players[pcol]
		player.pawn_location = getObjectFromGUID(C.player_pawns[pcol]).getPosition()
		player.gold = 15
		player.extra_actions = 0
		getObjectFromGUID(C.player_pawns[pcol]).setLock(true)
		--initialize player pool
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		for i=1,12 do
			local pos = player_board.positionToWorld(C.player_board_pool_locations[i])
			table.insert(player.pool, i, {g=nil,p=pos})
		end
		GD.game.status_visibility = GD.game.status_visibility..'|'..pcol
	end
	UI.setAttribute("status_info","visibility",GD.game.status_visibility)
	GD.game.current_player = math.random(#GD.game.player_order)
	GD.game.current_player_color = GD.game.player_order[GD.game.current_player]
	broadcastToAll("Starting player will be "..GD.game.current_player_color)
	startLuaCoroutine(Global, "coroFillPlayerBoards")
	return true
end

--[[ *****************************
Setup: fill player boards with palaces and houses,
remove unused player objects and place unused palaces
Run as a coro with pauses between spawning objects.
********************************]]
function coroFillPlayerBoards()
	if env.test.trace then log("coroFillPlayerBoards(): START") end
	--private function to pause (yield) coro for a number of frames
	local pauseMe = function(frames)
		frames = frames or env.game.fill_delay
		local count = 0
		while count < frames do
			count = count + 1
			coroutine.yield(0)
		end
	end
	local house = getObjectFromGUID(C.house_object_guid)
	assert(house, "*** ERROR: coroFillPlayerBoards(): no house object")
	local palace = getObjectFromGUID(C.palace_object_guid)
	assert(palace, "*** ERROR: coroFillPlayerBoards(): no palace object")

	--remove unused player area objects
	local board = getObjectFromGUID(C.board_guid)
	local rot = board.getRotation()
	copy({palace})
	for _,pcol in ipairs(C.table_colors) do
		if GD.game.players[pcol] == nil then
			getObjectFromGUID(C.player_boards[pcol]).destruct()
			getObjectFromGUID(C.action_dials[pcol]).destruct()
			getObjectFromGUID(C.player_aids[pcol]).destruct()
			getObjectFromGUID(C.player_pawns[pcol]).destruct()
			--place unused player palaces in outer city palaces
			for name,city in pairs(C.cities) do
				local index = #GD.network[city.node].palaces + 1
				local pos = board.positionToWorld(GD.network[city.node].center - C.city_palace_offsets[index])
				local p = {position=pos}
				local obj = paste(p)[1]
				assert(obj, "*** ERROR: coroFillPlayerBoards(): failed to paste object")
				obj.setRotation(rot)
				obj.setColorTint(C.object_color_tints[pcol])
				obj.setName("Unused")
				obj.memo = "palace"
				obj.tooltip = false
				obj.interactable = false
				table.insert(GD.network[city.node].palaces, {g=obj.getGUID(), c=pcol, p=pos})
				pauseMe()
				Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
			end
		end
	end
	pauseMe(10)
	--fill seated player boards
	for _,pcol in ipairs(GD.game.player_order) do
		local player = GD.game.players[pcol]
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		assert(player_board, "*** ERROR: coroFillPlayerBoards(): no board object for color "..tostring(pcol))
		player_board.tooltip = false
		local rot = player_board.getRotation()
		copy({palace})
		for i,loc in ipairs(C.player_board_palace_locations) do
			local pos = player_board.positionToWorld(loc)
			local p = {position=pos}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "palace"
			obj.setDescription("Palace")
			table.insert(player.palaces, {g=obj.getGUID(),p=pos})
			pauseMe()
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		end
		copy({house})
		for i,loc in ipairs(C.player_board_quarry_locations) do
			local pos = player_board.positionToWorld(loc)
			local p = {position=pos}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "house"
			obj.setDescription("House")
			table.insert(player.quarry, {g=obj.getGUID(),p=pos})
			pauseMe()
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		end
		for i=5,8 do
			local p = {position=player.pool[i].p}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "house"
			obj.setDescription("House")
			player.pool[i].g = obj.getGUID()
			pauseMe()
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		end
		local dial = getObjectFromGUID(C.action_dials[pcol])
		assert(dial, "*** ERROR: coroFillPlayerBoards(): no dial object for color "..tostring(pcol))
		dial.tooltip = false
		dial.call("disableDialButtons")
		dial.call("showMe")
	end

	--setup for next game stage
	if GD.game.auction_characters then

		--TODO: setup for auction

	else
		--setup for character card selection
		for _,char in ipairs(C.characters) do
			getObjectFromGUID(char.g).setLock(false)
		end
		GD.game.stage = "select_starting_characters"
		GD.game.characters_selected = 0
		broadcastToAll(GD.game.current_player_color.." player select a character card then continue clockwise around table")
		local p = {dormant = false,done = false,undo = false,}
		p.help_text = "Select a character card then click Done."
		for _,pcol in ipairs(GD.game.player_order) do
			p.active = (pcol == GD.game.current_player_color)
			p.gold_coins = GD.game.players[pcol].gold
			p.extra_actions = GD.game.players[pcol].extra_actions
			local player_board = getObjectFromGUID(C.player_boards[pcol])
			player_board.call("setState",p)
		end
	end
	getObjectFromGUID(C.board_guid).UI.setAttribute("governor_panel", "active", true)
	reloadUI(C.board_guid)
	if env.test.trace then log("coroFillPlayerBoards(): EXIT") end
	return 1
end

--[[ *****************************
Load 6 starting houses into player Quarry after setup
********************************]]
function startingQuarry(pcol)
	if env.test.trace then log("startingQuarry(): "..pcol) end
	local quarry = GD.game.players[pcol].quarry
	local pool = GD.game.players[pcol].pool
	for i=1,6 do
		local index = 16 - i + 1
		local house = getObjectFromGUID(quarry[index].g)
		assert(house,"*** ERROR: startingQuarry() nil quarry house")
		house.setPosition(pool[i].p)
		quarry[index].g = nil
		pool[i].g = house.getGUID()
	end
end

--[[ *****************************
Move 2 houses from quarry
********************************]]
function quarryAction(pcol)
	if env.test.trace then log("startingQuarry(): "..pcol) end
	local player = GD.game.players[pcol]
	local quarry = player.quarry
	local pool = player.pool
	local success = false
	for i=1,2 do
		for p=1,12 do
			if not(pool[p].g) then
				for q=16,1,-1 do
					if quarry[q].g then
						getObjectFromGUID(quarry[q].g).setPosition(pool[p].p)
						pool[p].g = quarry[q].g
						quarry[q].g = nil
						success = true
						break --out of quarry loop
					end
				end
				break --out of pool loop
			end
		end
	end
	return success
end

--[[ *****************************
Finalize a starting character select action
Player has clicked "Done"
********************************]]
function setStartingCharacter(action)
	if env.test.trace then log("setStartingCharacter()") end
	if GD.game.stage ~= "select_starting_characters" then
		log(("*** ERROR: setStartingCharacter() invalid game stage")) --shouldn't happen
		return
	end
	local pcol = action.player_color
	GD.game.players[pcol].character_id = action.character_id
	GD.game.characters_selected = GD.game.characters_selected + 1
	if GD.game.characters_selected == GD.game.player_count then
		--All players selected a character, now setup game for initial house placement
		updateTurnOrder()
		setNextPlayer(FIRST)
		GD.game.stage = "initial_placement"
		broadcastToAll("Begin initial house placement")
		local p ={done=false,undo=false}
		p.help_text = "Place one starting house from Build Pool.\nOnly place on Villages."
		for pcol,pdata in pairs(GD.game.players) do
			for _,e in ipairs(pdata.pool) do
				if e.g then getObjectFromGUID(e.g).setLock(false) end
			end
			GD.game.players[pcol].init_placements = 4
			p.active = (pcol == GD.game.current_player_color)
			getObjectFromGUID(C.player_boards[pcol]).call("setState",p)
		end
		GD.game.players_init_placed = 0
		GD.game.init_placement = 4
	else
		getObjectFromGUID(C.player_boards[pcol]).call("setState")
		getObjectFromGUID(C.player_boards[setNextPlayer()]).call("setState", {active=true})
	end
end

--[[ *****************************
Finalize an initial house placement action
Player has clicked "Done"
********************************]]
function setInitialPlacement(action)
	if env.test.trace then log("setInitialPlacement()") end
	if GD.game.stage ~= "initial_placement" then
		log(("*** ERROR: setInitialPlacement() invalid game stage")) --shouldn't happen
		return
	end
	local obj = getObjectFromGUID(action.guid)
	local player = GD.game.players[action.player_color]
	removeFromPlayerBoard(obj)
	player.init_placements = player.init_placements - 1
	player.placed_houses[obj.getGUID()] = obj.getPosition()
	GD.game.players_init_placed = GD.game.players_init_placed + 1
	if GD.game.players_init_placed == GD.game.player_count then
		--reset for next round of placement until all 4 placed
		GD.game.players_init_placed = 0
		GD.game.init_placement = GD.game.init_placement - 1
	end
	if GD.game.init_placement == 0 then
		--End of placement, setup for first round
		for pcol,pdata in pairs(GD.game.players) do
			startingQuarry(pcol)
		end
		broadcastToAll("Begin First Round")
		GD.game.current_round = 0
		beginNextRound()
		return
	else
		getObjectFromGUID(C.player_boards[action.player_color]).call("setState")
		getObjectFromGUID(C.player_boards[setNextPlayer()]).call("setState",{active=true})
	end
end

--[[/////////// Game Play ///////////////////////]]

--[[ *****************************
TODO: document
********************************]]
function beginNextRound()
	if env.test.trace then log("beginNextRound()") end
	GD.game.current_round = GD.game.current_round + 1
	if GD.env.verbose then broadcastToAll("Beginning round "..tostring(GD.game.current_round).." of max 10") end
	moveMaharaja()
	GD.game.remaining_round_players = {} --TODO: redundant to pdata.has_actions ???  Decide which way to go
	GD.game.stage = "select_actions"
	for pcol,pdata in pairs(GD.game.players) do
		pdata.has_actions = true
		pdata.dial_actions = {}
		updateDialUI(pcol)
		local dial = getObjectFromGUID(C.action_dials[pcol])
		dial.call("reset")
		dial.call("enableDialButtons")
		dial.call("hideMe")
		if dial.is_face_down then dial.call("flipMe") end
		local txt = "Secretly choose turn actions and confirm with Done.\n"
		txt = txt .. "Player turns will begin once all have confirmed.\n"
		txt = txt .. "Until then selections can be modified."
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{active=true,done=false,undo=false,help_text=txt})
		table.insert(GD.game.remaining_round_players, pcol)
	end
end

--[[ *****************************
Process a dropped character card.
Result depends on game stage.
TODO: handle during player turn
********************************]]
function characterDrop(pcol, obj)
	if env.test.trace then log("characterDrop()") end
	local char_id = getCharacterId(obj.getGUID())
	local board = getObjectFromGUID(C.board_guid)
	if GD.game.stage == "select_starting_characters" then
		if pcol ~= GD.game.current_player_color then --ignore non active player
			obj.setPosition(C.characters[char_id].bank_pos)
			obj.setRotation(board.getRotation())
			return
		end
		if #GD.game.players[pcol].pending_actions > 0 then --only select one
			broadcastToColor("Character already selected", pcol)
			obj.setPosition(C.characters[char_id].bank_pos)
			obj.setRotation(board.getRotation())
			return
		end
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		local pos = player_board.positionToWorld(C.player_board_character_location)
		local rot = player_board.getRotation()
		obj.setPositionSmooth(pos, false, true)
		obj.setRotation(rot)
		Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		local action = {
			key = "select_starting_character",
			player_color = pcol,
			character_id = char_id,
			undo = {
				guid = obj.getGUID(),
				snapback = {pos=C.characters[char_id].bank_pos, rot=board.getRotation()},
			},
		}
		table.insert(GD.game.players[pcol].pending_actions, action)
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=true,undo=true})
	elseif GD.game.stage == "player_turn" then

		--TODO: implement this
		log("TODO: implement character drop on player turn <-------------------")

	end
end

--[[ *****************************
Process a dropped house.
Result depends on game stage.
********************************]]
function houseDrop(pcol, obj)
	if env.test.trace then log("houseDrop()") end
	local board = getObjectFromGUID(C.board_guid)
	local color = obj.getName()
	--/////// internal functions ///////
	local function snapBack(obj)
		local pos = placedObjSnap(obj.getGUID())
		if pos then
			obj.setPosition(pos)
			obj.setRotation(getObjectFromGUID(C.board_guid).getRotation())
		else
			obj.setPosition(getPlayerBoardLocation(obj))
			obj.setRotation(getObjectFromGUID(C.player_boards[color]).getRotation())
		end
		return
	end
	local function placeVillageHouse(obj, node)
		table.insert(node.houses,{g=obj.getGUID(),c=obj.getName()})
		local pos = board.positionToWorld(node.center)
		if GD.game.player_count > 2 then
			local pos_1 = node.center - VILLAGE_OFFSET
			local pos_2 = node.center + VILLAGE_OFFSET
			pos = board.positionToWorld(pos_1)
			if #node.houses == 1 then pos = board.positionToWorld(pos_2) end
		end
		pos.y = 1.5
		obj.setRotation(board.getRotation())
		obj.setPosition(pos)
		Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
	end
	local function placeCityHouse(obj, node)
		--TODO: this
	end
	--//////////////////////////////////
	local pos = obj.getPosition()
	pos.y = 0
	local index = closestNode(pos)
	log("nearest is id "..tostring(index)..", type "..GD.network[index].type..", name "..GD.network[index].name)
	if index < 1 then
		snapBack(obj)
		return
	end
	local player = GD.game.players[pcol]
	local node = GD.network[index]
	if GD.game.stage == "initial_placement" then
		if node.type == "village" then
			if isVillageFull(node) then
				snapBack(obj)
				return
			end
			placeVillageHouse(obj,node)
			local action = {
				key = "initial_placement",
				player_color = pcol,
				guid = obj.getGUID(),
				undo = {
					node_index = index,
					guid = obj.getGUID(),
					snapback = {pos=getPlayerBoardLocation(obj),rot=getObjectFromGUID(C.player_boards[pcol]).getRotation()}
				},
			}
			--show done and undo buttons
			table.insert(player.pending_actions, action)
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=true,undo=true})
		elseif node.type == "city" then
			snapBack(obj)
		else
			snapBack(obj)
		end
	else
		if node.type == "village" then
			if isVillageFull(node) then
				snapBack(obj)
				return
			end
			local pos = placedObjSnap(obj.getGUID())
			local rot = getObjectFromGUID(C.board_guid).getRotation()
			local action_key = "move"
			if not(pos) then --this house coming from player's pool
				pos = getPlayerBoardLocation(obj)
				rot = getObjectFromGUID(C.player_boards[pcol]).getRotation()
				action_key = "build"
			end
			if hasAvailableAction(pcol, action_key) then
				placeVillageHouse(obj,node)
			else
				snapBack(obj)
				return
			end
			local pending_action = {
				key = action_key, --TODO: rename this to 'id' for consistency???
				player_color = pcol,
				guid = obj.getGUID(),
				undo = {
					node_index = index,
					guid = obj.getGUID(),
					snapback = {pos=pos,rot=rot}
				},
			}
			if player.free_action then
				player.free_action = false
				pending_action.free_action = true
			end
			if updateDialAction(pcol, pending_action) then
				updateDialUI(pcol)
				table.insert(player.pending_actions, pending_action)
				getObjectFromGUID(C.player_boards[pcol]).call("setState",{undo=true})
			else
				--shouldn't really happen but handle anyway
				log("***ERROR: no matching dial_action for dropped house")
				snapback(obj)
			end
		elseif node.type == "city" then
			log("TODO: handle house drop action in City <--------------")

			placeCityHouse(obj, node)

		else
			snapBack(obj)
		end
	end
end

--[[ ********* TODO: *************
Process a dropped palace.
********************************]]
function palaceDrop(pcol, obj)
	log("TODO: palaceDrop ****")
end

--[[ ********* TODO: *************
Process a dropped architect.
********************************]]
function architectDrop(pcol, obj)
	log("TODO: architectDrop ****")
end

--[[ *****************************
Start a player's action turn.
********************************]]
function startPlayerTurn(pcol)
	if env.test.trace then log("startPlayerTurn() for player "..tostring(pcol)) end
	local player = GD.game.players[pcol]
	assert(player,"Failed to locate player for color "..tostring(pcol))
	-- player.failed_actions = false
	player.pending_actions = {}
	player.free_action = false
	if GD.env.verbose then printToAll("Starting turn for player "..pcol) end
	local dial = getObjectFromGUID(C.action_dials[pcol])
	Wait.condition(
		function()
			dial.call("disableDialButtons")
			dial.call("disableBackButton")
			dial.call("showMe")
			if dial.is_face_down then dial.call("flipMe") end
		end,
		function() return(dial.resting) end, 5) --HACK: might be flipping from lock actions call so wait
	--unlock pawn
	getObjectFromGUID(C.player_pawns[pcol]).setLock(false)
	--set and/or execute bonus of character tile
	player.character_bonus = nil
	if player.character_id == 7 then
		player.extra_actions = player.extra_actions + 1
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{extra_actions=player.extra_actions})
		if GD.env.verbose then printToAll(pcol.." +1 extra action token for the Yogi") end
	elseif player.character_id == 6 then
		player.character_bonus = "build_palace_discount"
	elseif player.character_id == 5 then
		log("adding free build/move action for player "..tostring(pcol))
		player.dial_actions["free-action"] = {
			id = "free",
			actions = {
				{id = "free", label="Free Build/Move House", status = "",},
			},
		}
		player.free_action = true
		player.character_bonus = "free_build_move"
	elseif player.character_id == 4 then
		player.character_bonus = "free_travel"
	elseif player.character_id == 3 then
		player.character_bonus = "outer_palace_scoring"
	elseif player.character_id == 2 then
		player.gold = player.gold + 1
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
		if GD.env.verbose then printToAll(pcol.." +1 gold for the Trader") end
	end
	--execute any immediate actions, set pawn, house, palace lock state based on actions selected
	local palace,pool,move,track,char = false,false,false,false,false
	for _,dial_action in pairs(player.dial_actions) do
		for _,action in ipairs(dial_action.actions) do
			if action.id == "gold" then
				player.gold = player.gold + 2
				getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
				if GD.env.verbose then printToAll(pcol.." +2 gold for Coins action") end
				action.status = "Done"
				updateDialUI(pcol)
			elseif action.id == "quarry" then
				if quarryAction(pcol) then
					if GD.env.verbose then printToAll(pcol.." moves 2 houses into their Build Pool") end
					action.status = "Done"
					updateDialUI(pcol)
				else
					if GD.env.verbose then printToAll(pcol.." is unable to complete selected Quarry action!") end
					action.status = "Failed"
					updateDialUI(pcol)
				end
			elseif action.id == "palace" then palace = true
			elseif action.id == "build" or action.action_id == "free" then pool = true
			elseif action.id == "move" or action.action_id == "free" then move = true
			elseif action.id == "track" then track = true
			elseif action.id == "character" then char = true
			end
		end
	end
	if player.free_action then pool,move = true,true end
	if palace then unplayedPalacesLock(pcol, false) end
	if pool then buildPoolLock(pcol, false) end
	if move then placedHousesLock(pcol, false) end
	if track then governorButtons(true) end
	if char then charactersLock(pcol, false) end
	--enable player board for actions
	local txt = "Execute actions in any order.\n"
	txt = txt.."May move Architect at any time.\n"
	txt = txt.."All required actions must be executed.\n"
	for _,p in ipairs(GD.game.player_order) do
		local active = (p == pcol)
		local help_txt = txt..C.character_bonus_descriptions[player.character_id]
		getObjectFromGUID(C.player_boards[p]).call("setState",{active=active,done=active,undo=false,help_text=help_txt})
	end
end

--[[ *****************************
Process player Done click based on current game stage.
--For all entries in the player's pending action list:
	-- POP an entry off the LIFO stack
	-- finallize the pendign action, update data structures etc.
	-- remove the entry from the LIFO stack
	-- if more entries, repeat
********************************]]
function playerDone(pcol)
	if env.test.trace then log("playerDone(): "..pcol) end
	local player = GD.game.players[pcol]
	if GD.game.stage == "select_starting_characters" then  --Done during character selection
		local action = player.pending_actions[1]
		assert(action,"*** ERROR: missing starting character action")
		setStartingCharacter(action)
		if env.test.debug then log("Player "..pcol.." finalize "..action.key.." action") end
		table.remove(player.pending_actions, 1)
	elseif GD.game.stage == "initial_placement" then  --Done during initial placement
		local action = player.pending_actions[1]
		assert(action,"*** ERROR: missing initial placement action")
		setInitialPlacement(action)
		if env.test.debug then log("Player "..pcol.." finalize "..action.key.." action") end
		table.remove(player.pending_actions, 1)
	elseif GD.game.stage == "select_actions" then  --Done during action selection
			if player.choosing_extra_action then
				setExtraAction(pcol)
			else
			log("Player clicked Done during action selection")
			local p1,p2 = false,false
			if player.dial_actions["pointer-1"] ~= nil then p1 = true end
			if player.dial_actions["pointer-2"] ~= nil then p2 = true end
			assert(p1 and p2, "***ERROR: playerDone() two player action selections have not been made")  --TODO: is this really needed?
			player.actions_set = true
			local all_set = true
			for _,pdata in pairs(GD.game.players) do
				if not(pdata.actions_set) then all_set = false end
			end
			if all_set then
				broadcastToAll("All players have set actions, starting player turns")
				for _,pcol in ipairs(GD.game.player_order) do
					local dial = getObjectFromGUID(C.action_dials[pcol])
					dial.call("disableBackButton")
					if not(dial.is_face_down) then dial.call("flipMe") end
					getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=false,help=false})
				end
				GD.game.stage = "player_turns"
				startPlayerTurn(setNextPlayer(FIRST))
			else
				local dial = getObjectFromGUID(C.action_dials[pcol])
				dial.call("enableBackButton")
				dial.call("disableDialButtons")
				if not(dial.is_face_down) then dial.call("flipMe") end
				getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=false})
			end
		end
	elseif GD.game.stage == "player_turns" then --Done during other game stages
		if #player.pending_actions == 0 then
			log("*** WARN: playerDone() no actions to finalize for player "..pcol)
		end
		while #player.pending_actions > 0 do
			local index = #player.pending_actions
			local action = player.pending_actions[index]
			if action.key == "track" then
				player.governor_clicked = false
			elseif action.key == "gold" then
				--noop
			elseif action.key == "character" then
				log("TODO: finalize character action <---------------")

			elseif action.key == "palace" then
				log("TODO: finalize palace action <---------------")

			elseif action.key == "quarry" then
				--noop
			elseif action.key == "move" then
				log("TODO: finalize move action <---------------")

			elseif action.key == "build" then
				log("TESTING: finalize house action")
				local obj = getObjectFromGUID(action.guid)
				removeFromPlayerBoard(obj)
				player.placed_houses[obj.getGUID()] = obj.getPosition()
			else
				log("*** ERROR: playerDone() unknown action key "..tostring(action.key))
				return
			end
			if env.test.debug then log("Player "..pcol.." finalize "..action.key.." action") end
			table.remove(player.pending_actions, index)
		end
		-- if player.failed_actions then
		if failedActions(pcol) then
			--give other players +2 gold automatically
			for color,player in pairs(GD.game.players) do
				if color ~= pcol then
					player.gold = player.gold + 2
					getObjectFromGUID(C.player_boards[color]).call("setState",{gold_coins=player.gold})
					if GD.env.verbose then printToAll(color.." recieves +2 gold") end
				end
			end
		else
			if hasRequiredActions(pcol) then
				UI.setAttribute("penalty_dialog_pnl","visibility","Pink|"..pcol)
				return
			end
		end
		endTurn(pcol)
	else
		log("*** ERROR: unknown game stage")
	end
end

--[[ *****************************
Check for end of round & start a new one otherwise start next players turn
********************************]]
function endTurn(pcol)
	if env.test.trace then log("endTurn() "..tostring(pcol)) end
	local index = indexOf(GD.game.remaining_round_players,pcol) --TODO: redundant ???
	assert(index > 0,"***ERROR: could not locate player in remaining_round_players")
	--clear out all player turn data`
	local player = GD.game.players[pcol]
	player.has_actions = false
	player.dial_actions = {}
	player.pending_actions = {}
	player.actions_set = false
	getObjectFromGUID(C.player_pawns[pcol]).setLock(true)
	--update round and check for end of round or end of game
	table.remove(GD.game.remaining_round_players,index) --TODO: redundant to has_actions ???
	if #GD.game.remaining_round_players == 0 then  --TODO: just check for any player.has_actions ???
		finishCurrentRound()
	else
		startPlayerTurn(setNextPlayer())
	end
end

--[[ ********* TODO **************
TODO: implement and document
********************************]]
function finishCurrentRound()
	if env.test.trace then log("finishCurrentRound():") end
	if env.test.debug then log("Finishing round "..tostring(GD.game.current_round)) end

	--TODO: score current city
	log("TODO: score current city <-----------------")
		--calculate city score
		--hand out payments
		--show results dialog ???

	if GD.game.current_round == 10 then  --TODO: may move to city scoring results dialog ???
		endGame()
	else
		beginNextRound()
	end
end

--[[ *****************************
TODO: document
--POP an entry off the player's LIFO pending actions stack
--undo any placements, action effects, etc.
--remove the pending action entry
--disable player's done button
--if no remaining pending actinos, disable player's undo button
********************************]]
function playerUndo(pcol)
	if env.test.trace then log("playerUndo(): "..pcol) end
	local function resetAction(pcol, key)
		for _,dial_action in pairs(GD.game.players[pcol].dial_actions) do
			for i,a in ipairs(dial_action.actions) do
				if a.id == key and a.status == "Done" then
					a.status = ""
					return
				end
			end
		end
	end
	local player = GD.game.players[pcol]
	local actions = player.pending_actions
	if #actions == 0 then return end
	local action = actions[#actions]
	if env.test.debug then log("action to undo:");log(action) end
	if action.key == "select_starting_character" then
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
	elseif action.key == "initial_placement" then
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
		local node = GD.network[action.undo.node_index]
		if node.houses[1] and node.houses[1].g == action.guid then
			node.houses[1] = nil
		elseif node.houses[2] and node.houses[2].g == action.guid then
			node.houses[2] = nil
		else
			log("*** ERROR: playerUndo() unable to clear house "..action.guid.."from network node "..tostring(action.undo.node_index))
		end
	elseif action.key == "track" then
		GD.game.governor_track = simpleDeepCopy(action.undo.restore_list)
		updateGovernorTrack()
		updateStatusPanel()
		governorButtons(true)
		resetAction(pcol, action.key)
		player.governor_clicked = false
		action.status = ""
	elseif action.key == "build" then
		log("TESTING: undoing build house action")
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
		local node = GD.network[action.undo.node_index]
		if node.houses[1] and node.houses[1].g == action.guid then
			node.houses[1] = nil
		elseif node.houses[2] and node.houses[2].g == action.guid then
			node.houses[2] = nil
		else
			log("*** ERROR: playerUndo() unable to clear house "..action.guid.."from network node "..tostring(action.undo.node_index))
			return
		end
		if action.free_action then
			player.dial_actions["free-action"].actions[1].status = ""
		else
			resetAction(pcol, action.key)
		end
		updateDialUI(pcol)
	else
		log("*** ERROR: playerUndo() unknown action key "..tostring(action.key))
		return
	end
	--remove entry and update player board UI
	table.remove(player.pending_actions, index)
	if #player.pending_actions == 0 then
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{undo=false})
	end
end

--[[ ********* TODO **************
TODO: document
********************************]]
function extraAction(pcol)
	if env.test.trace then log("extraAction(): "..pcol) end
	log("TODO: implement extraAction() <--------------------")
end

--[[ *****************************
TODO: implement and document
********************************]]
function moveMaharaja()
	if env.test.trace then log("moveMaharaja()") end
	-- move maha to next city position (1st in gov track table)
	local board = getObjectFromGUID(C.board_guid)
	local track = GD.game.governor_track
	local city = track[1].city
	local pos = board.positionToWorld(C.cities[city].maharaja_pos)
	local maha = getObjectFromGUID(C.maharaja_guid)
	maha.setLock(false)
	-- maha.setPositionSmooth(pos, false, true)
	maha.setPosition(pos)
	Wait.condition(function() maha.setLock(true) end, function() return(maha.resting) end, 2)
	-- move table 1st to 7th, shift others up
	local temp = simpleDeepCopy(track[1])
	temp.UI_row = track[7].UI_row
	temp.track_row = track[7].track_row + 1
	for i=2,7 do
		track[i-1] = simpleDeepCopy(track[i])
		track[i-1].UI_row = track[i-1].UI_row + 1
	end
	track[7] = temp
	-- update city status UI
	updateGovernorTrack()
	updateStatusPanel()
end

--[[ ********* TODO **************
TODO: implement and document
********************************]]
function endGame()
	if env.test.trace then log("endGame(): "..pcol) end
	log("TODO: implement endGame() <--------------------")
end

--[[/////////////// Support functions /////////////////////]]

function updateDialAction(pcol, action)
	if env.test.trace then log("updateDialAction() "..tostring(pcol)..", "..tostring(action.id)) end
	local player = GD.game.players[pcol]
	if action.free_action then
		local dial_action = player.dial_actions["free-action"]
		if dial_action then
			dial_action.actions[1].status = "Done"
			return true
		else
			log("***ERROR: could not locate free-action")
			return false
		end
	else
		for id,dial_action in pairs(player.dial_actions) do
			for _,entry in ipairs(dial_action.actions) do
				if entry.id == action.key then
					entry.status = "Done"
					return true
				end
			end
		end
	end
	return false
end

--[[ *****************************
TODO: need this in a fn?
********************************]]
function failedActions(pcol)
	if env.test.trace then log("failedActions() "..tostring(pcol)) end
	for _,action in ipairs(GD.game.players[pcol].dial_actions) do
		if action.type == "selected" and action.status == "Failed" then return true end
	end
	return false
end

--[[ *****************************
Check to see if a player has any unfinished required actions.
Return true if any, false if not.
********************************]]
function hasRequiredActions(pcol)
	if env.test.trace then log("hasRequiredActions() "..tostring(pcol)) end
	for id,dial_action in ipairs(GD.game.players[pcol].dial_actions) do
		if Split(id,'-')[1] == "pointer" then
			for _,a in ipairs(dial_action.actions) do
				if a.status == "" then return true end
			end
		end
	end
	return false
end

--[[ *****************************
Check to see if a player has any unfinished action of specified action id.
Return true if any, false if not.
********************************]]
function hasAvailableAction(pcol, action_id)
	if env.test.trace then log("hasRequiredActions() "..tostring(pcol)) end
	for id,dial_action in ipairs(GD.game.players[pcol].dial_actions) do
		for _,a in ipairs(dial_action.actions) do
			if a.id == action_id and a.status == "" then return true end
		end
	end
	return false
end

--[[ *****************************
Set the locked state of a player's houses in the build pool
********************************]]
function buildPoolLock(pcol, locked)
	if env.test.trace then log("buildPoolLock()") end
	locked = locked or false
	for _,e in ipairs(GD.game.players[pcol].pool) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of a player's unplayed palaces
********************************]]
function unplayedPalacesLock(pcol, locked)
	if env.test.trace then log("unplayedPalacesLock()") end
	locked = locked or false
	for _,e in ipairs(GD.game.players[pcol].palaces) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of a player's placed houses
********************************]]
function placedHousesLock(pcol, locked)
	if env.test.trace then log("placedHousesLock()") end
	locked = locked or false
	for g,_ in pairs(GD.game.players[pcol].placed_houses) do
		local o = getObjectFromGUID(g)
		if o then
			o.setLock(locked)
		else
			log("***ERROR: unable to unlock placed house for "..tostring(g))
		end
	end
end

--[[ *****************************
Set the locked state of a palaces on a player board
Defaults to unlocked
********************************]]
function palacesLock(pcol, locked)
	locked = locked or false
	if env.test.trace then log("palacesLock() "..tostring(locked)) end
	for _,e in ipairs(GD.game.players[pcol].palaces) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of a player's build pool
Defaults to unlocked
********************************]]
function poolLock(pcol, locked)
	locked = locked or false
	if env.test.trace then log("poolLock() "..tostring(locked)) end
	for _,e in ipairs(GD.game.players[pcol].pool) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of all characters.
If pcol supplied, skip it.
Defaults to unlocked
********************************]]
function charactersLock(pcol, locked)
	locked = locked or false
	pcol = pcol or "none"
	if env.test.trace then log("charactersLock() player: "..tostring(pcol)..", locked = "..tostring(locked)) end
	local player = getObjectFromGUID(pcol)
	for id,char in ipairs(C.characters) do
		if not(player) or player.character_id ~= id then
			getObjectFromGUID(char.g)setLock(locked)
		end
	end
end

--[[ *****************************
TODO: document
********************************]]
function updateStatusPanel()
	if env.test.trace then log("updateStatusPanel()") end
	--update city names and images from GD.game.governor_track
	for i,gov in ipairs(GD.game.governor_track) do
		UI.setAttribute("status_city_name_"..gov.UI_row, "text", gov.city)
		UI.setAttribute("status_city_image_"..gov.UI_row, "image", gov.city)
	end
	--update player scores per city
	log("TODO: update status panel city scores <---------------")
end

--[[ *****************************
Remove an object from player board data.
********************************]]
function removeFromPlayerBoard(obj)
	if env.test.trace then log("removeFromPlayerBoard()") end
	local player = GD.game.players[obj.getName()]
	assert(player,"*** ERROR: removeFromPlayerBoard() could not locate player data")
	if obj.memo == "palace" then
		for i,data in ipairs(player.palaces) do
			if data.g == obj.getGUID() then
				player.palaces[i].g = nil
				return
			end
		end
	else
		for i,data in ipairs(player.pool) do
			if data.g == obj.getGUID() then
				player.pool[i].g = nil
				return
			end
		end
	end
	log("*** WARN: could not find object "..obj.getGUID().." in "..obj.getName().." data")
end

--[[ *****************************
Search all players placed object lists for this guid.
Return snap pos if any, nil if not.
--TODO: replace with list of placed guids for cheaper lookup?
********************************]]
function placedObjSnap(guid)
	if env.test.trace then log("placedObjSnap()") end
	local obj = getObjectFromGUID(guid)
	assert(obj, "***ERROR: placedObjSnap() unable to get object ref")
	for _,pcol in ipairs(GD.game.player_order) do
		local list = {}
		if obj.memo == "house" then
			list = GD.game.players[pcol].placed_houses
		elseif obj.memo == "palace" then
			list = GD.game.players[pcol].placed_palaces
		end
		if list[guid] then return list[guid] end
	end
	return nil
end

--[[ *********** TODO ??? ******************
TODO: need this in a fn? Used only once?
********************************]]
function isVillageFull(node)
	if GD.game.player_count == 2 and #node.houses == 1 then return true
	elseif GD.game.player_count > 2 and #node.houses == 2 then return true end
	return false
end

--[[ *****************************
Return the snap back playerboard location for an object.
Playerboard determined from object name(color))
********************************]]
function getPlayerBoardLocation(obj)
	local color = obj.getName()
	for _,d in ipairs(GD.game.players[color].pool) do
		if d.g == obj.getGUID() then return d.p end
	end
	for _,d in ipairs(GD.game.players[color].palaces) do
		if d.g == obj.getGUID() then return d.p end
	end
	for _,d in ipairs(GD.game.players[color].quarry) do
		if d.g == obj.getGUID() then return d.p end
	end
end

--[[ *****************************
Update game player order sorted by current player character IDs
TODO: actually update and update UI
********************************]]
function updateTurnOrder()
	if env.test.trace then log("updateTurnOrder()") end
	--sort player order by character ID
	local new_order = nil
	for pcol,pdata in pairs(GD.game.players) do
		if new_order == nil then
			new_order = {pcol}
		else
			for i,player_color in ipairs(new_order) do
				if pdata.character_id < GD.game.players[player_color].character_id then
					table.insert(new_order, i, pcol)
					break
				elseif i == #new_order then
					table.insert(new_order, pcol)
					break
				end
			end
		end
	end
	GD.game.player_order = simpleDeepCopy(new_order)
	if env.test.debug then
		log("New player order sorted by char ID:")
		log(GD.game.player_order)
	end
	for i,pcol in ipairs(GD.game.player_order) do
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		player_board.call("setState",{turn_order=i})
	end
end

--[[ *****************************
Set the next active player.
Clockwise from current player if selecting initial characters.
Uses order sorted by character ID in other stages of play.
Returns color of current player
********************************]]
function setNextPlayer(first)
	first = first or false
	if env.test.trace then log("setNextPlayer()") end
	local old_color = GD.game.current_player_color
	if first then
		GD.game.current_player = 1
	elseif GD.game.stage == "select_starting_characters" then
		local next = GD.game.current_player + 1
		if next > #GD.game.player_order then next = 1 end
		GD.game.current_player = next
	else
		if GD.game.stage == "initial_placement" then
			--find first player in order that needs to place this round of placements
			for i,pcol in ipairs(GD.game.player_order) do
				if GD.game.players[pcol].init_placements == GD.game.init_placement then
					GD.game.current_player = i
					break
				end
			end
		else
			--find first player in order that has actions
			for i,pcol in ipairs(GD.game.player_order) do
				if GD.game.players[pcol].has_actions then
					GD.game.current_player = i
					break
				end
			end
		end
	end
	GD.game.current_player_color = GD.game.player_order[GD.game.current_player]
	broadcastToAll("Current player now "..GD.game.current_player_color)
	if env.test.players and env.test.auto_switch then
		if old_color != GD.game.current_player_color then
			Player[old_color].changeColor(GD.game.current_player_color)
		end
	end
	return GD.game.current_player_color
end

--[[ *****************************
Locate the closest network node to the position.
TODO: be smarter about city radius vs village radius.
As is the radius is equal so dropping in a city edge
might detect as a nearby village.  Minor thing.
********************************]]
function closestNode(pos)
	if env.test.trace then log("closestNode()") end
	local board = getObjectFromGUID(C.board_guid)
	local nearest_node = -1
	local shortest_dist = nil
	for i,node in ipairs(GD.network) do
		local dist = Vector.sqrDistance(pos, board.positionToWorld(node.center))
		if shortest_dist then
			if dist < shortest_dist then
				shortest_dist = dist
				nearest_node = i
			end
		else
			shortest_dist = dist
			nearest_node = i
		end
	end
	return nearest_node
end

--[[ *****************************
Lookup and return the id for a character card guid
Returns -1 if not found (log an error)
********************************]]
function getCharacterId(guid)
	for id,char in ipairs(C.characters) do
		if char.g == guid then
			return id
		end
	end
	log("*** ERROR: getCharacterId(): no character card found for guid "..tostring(guid))
	return -1
end

--[[ *****************************
TODO: implement and document
********************************]]
function governorButtons(on)
	on = on or false
	if env.test.trace then log("enableGovernorButtons() "..tostring(on)) end
	local board = getObjectFromGUID(C.board_guid)
	for _,gov in ipairs(GD.game.governor_track) do
		local id = "gov_"..tostring(gov.track_row)
		if on then
			log("Turn button on for image in row "..id)
			board.UI.setClass(id ,"gImg_")
		else
			log("Turn button off for image in row "..id)
			board.UI.setClass(id,"gImg")
		end
	end
	Wait.frames(function() reloadUI(C.board_guid) end, 60)
end

--[[ *****************************
Update the dial UI for a player with player's current action state
********************************]]
function updateDialUI(pcol)
	if env.test.trace then log("updateDialUI() "..tostring(pcol)) end
	local player = GD.game.players[pcol]
	local dial = getObjectFromGUID(C.action_dials[pcol])
	for i=1,7 do
		dial.UI.setAttribute("row_action_"..tostring(i),"active",false)
	end
	local row = 0
	for id,dial_action in pairs(player.dial_actions) do
		log("updating dial UI with dial_action: "..tostring(id))
		log(dial_action)
		if id == "free-action" then
			local action = dial_action.actions[1]
			log(action)
			dial.UI.setAttribute("action_text_7", "text", action.label)
			dial.UI.setAttribute("action_text_7", "color", "rgb(1,1,0)")
			dial.UI.setAttribute("row_action_7", "active", true)
			dial.UI.setAttribute("status_text_7", "text", action.status)
			if action.status == "Done" then
				dial.UI.setAttribute("action_text_7", "color", "Gray")
			end
		else
			for i,action in ipairs(dial_action.actions) do
				row = row + 1
				dial.UI.setAttribute("action_text_"..tostring(row), "text", action.label)
				dial.UI.setAttribute("action_text_"..tostring(row), "color", "rgb(1,1,0)")
		    dial.UI.setAttribute("row_action_"..tostring(row), "active", true)
	      dial.UI.setAttribute("status_text_"..tostring(row), "text", action.status)
	      if action.status == "Done" then
	        dial.UI.setAttribute("action_text_"..tostring(row), "color", "Gray")
	      elseif action.status == "Incomplete" then
	        dial.UI.setAttribute("action_text_"..tostring(row), "color", "Gray")
	        dial.UI.setAttribute("status_text_"..tostring(row), "color", "Red")
	      end
			end
		end
	end
end

--[[/////////////// External call functions /////////////////////]]

--[[ ****** TODO: DEPRECATED *********
Called from player dial during player action selection.
params:
	- command:
			- Set: Update player's data with selected action(s), enable Done if both pointers are set.
			- Clear: remove player action data, disable Done (dial modify button clicked)
		player_color: The player color.
		actions: The list of actions for an update (command==set)
********************************]]
function updatePlayerActionSelection(params)
		log("***WARN: updatePlayerActionSelection() is deprecated")
end

--[[ ***************************
Called from player dial during player action selection.
Update player's data with selected action on dial.
Enable Done if actions for both pointer 1 and 2 are set.
params:
		player_color: The player color.
		dial_index: The index on the dial of the selected action
			1-9
		pointer_id: the id of the dial pointer
			'pointer-1', 'pointer-2', 'pointer-extra'
********************************]]
function addDialAction(params)
	if env.test.trace then log("addDialAction()") end
	assert(params, "***ERROR addDialAction(): missing params")
	if env.test.debug then log(params) end
	local pcol = params.player_color
	assert(pcol,"***ERROR addDialAction(): missing player_color param")
	local dial_index = params.dial_index
	assert(dial_index, "***ERROR addDialAction(): missing dial_index param")
	local pointer_id = params.pointer_id
	assert(pointer_id, "***ERROR addDialAction(): missing pointer_id param")
	local player = GD.game.players[pcol]
	local dial_action = simpleDeepCopy(C.dial_actions[dial_index])
	assert(dial_action, "***ERROR udpateDialActions(): no action for index "..tostring(dial_index))
	for _,a in ipairs(dial_action.actions) do
		a.status = ""
	end
	player.dial_actions[pointer_id] = dial_action
	if player.dial_actions["pointer-1"] ~= nil and player.dial_actions["pointer-2"] ~= nil then
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		player_board.call("setState",{done=true})
	end
	updateDialUI(pcol)
end

--[[/////////////// DEVELOPMENTAL STUFF ///////////////////////]]

function testCityHouses(pcol, city_name)
	log("put selected houses in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(city_name.." center is "..tostring(center))
	local color_indexes = {Yellow = 0,Red = 0,Green = 0,Blue = 0,Purple = 0,}
	for _,o in ipairs(stuff) do
		local color = o.getName()
		color_indexes[color] = color_indexes[color] + 1
		local offset = Vector(C.city_house_offsets[color][color_indexes[color]].o)
		log("placing "..color.." object "..o.getGUID().." with offset "..tostring(color_indexes[color])..": "..tostring(offset))
		local pos = center - offset
		local rot = Vector(C.city_house_offsets[color][color_indexes[color]].r)
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function testCityPalaces(pcol, city_name)
	log("put selected houses in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	if #stuff > 7 then
		log("Only 7 palaces max allowed in a city")
		return
	end
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(center)
	for index,o in ipairs(stuff) do
		local offset = Vector(0,0,0)
		if index < 7 then offset = C.city_palace_offsets[index] end
		log("putting object "..o.getGUID().." in loc "..tostring(index)..", at offset "..tostring(offset))
		local pos = center - offset
		local rot = board.getRotation()
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function testCityPawns(pcol, city_name)
	log("put selected pawns in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	if #stuff > 5 then
		log("Only 5 pawns max allowed in a city")
		return
	end
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(center)
	for index,o in ipairs(stuff) do
		local offset = Vector(C.city_pawn_offsets[index])
		log("putting object "..o.getGUID().." in loc "..tostring(index)..", at offset "..tostring(offset))
		local pos = center - offset
		local rot = Vector(0,90,0)
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function getWorldPos(pcol)
	log("Getting positions of selected objects relative to world")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	local s=""
	for i,o in ipairs(stuff) do
    local p = o.getPosition()
		local t = tostring(i)..': '..o.getGUID()..': '..tostring(p)
		log(t)
		s = s .. t .. '\n'
	end
	if s ~= "" then
    Notes.setNotes(s)
  end
end

function getLTB(pcol)
  log("Getting positions of selected objects relative to board")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	--local board = getObjectFromGUID(C.board_guid)
	local board = getObjectFromGUID(C.board_guid)
  local s = ""
  for i,o in ipairs(stuff) do
    log("Processing object #"..tostring(i)..": "..o.getGUID())
    local p = board.positionToLocal(o.getPosition())
    -- local r = Vector(0,180,0)
		-- City house positions
		-- local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},r={'..r.x..','..r.y..','..r.z..'}},'
		local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},r={0,180,0}},'
    log(t)
    s = s .. t .. '\n'
  end
  if s ~= "" then
    Notes.setNotes(s)
  end
end

function getLTPB(pcol)
	log("Getting positions of selected objects relative to player board")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	local board = getObjectFromGUID(C.player_boards[pcol].g)
  local s = ""
  for i,o in ipairs(stuff) do
    log("Processing object #"..tostring(i)..": "..o.getGUID())
    local p = board.positionToLocal(o.getPosition())
		local r = board.getRotation()
		local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},},'
    log(t)
    s = s .. t .. '\n'
  end
  if s ~= "" then
    Notes.setNotes(s)
  end

end

function getOffsets()
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers.Agra
	center.y = 0
	log(center)
	local s = ""
	for i,loc in ipairs(C.ltb) do
		local pos = Vector(loc.p)
		pos.y = 0
		local o = center - pos
		-- local r = Vector(loc.r)
		-- local t = '{o={'..o.x..','..o.y..','..o.z..'},r={'..r.x..','..r.y..','..r.z..'}},'
		local t = '{o={'..o.x..','..o.y..','..o.z..'},r={0,180,0}}'
		log(t)
		s = s .. t .. '\n'
	end
	if s ~= "" then
		Notes.setNotes(s)
	end
end

require("tts-lib/utils")
require("tts-maharaja/Constants")
require("tts-maharaja/Network")
