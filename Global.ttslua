-- #include tts-maharaja/Global
--[[///////////////////////////////////////////////////////////////////////////////////////////////

	Maharaja
		TODO: credits

  --TODO:
    - lots of stuff
		-- load/save restore
		-- (opt) starting character auction
		-- UI and implementation for Governor track
		-- Yogi extra action functionality
		-- turn execution, detection and update dial actions
		-- move architect route detection, display
		-- respect verbosity setting

		probablyi a bunch more I'm not thinking of!z

///////////////////////////////////////////////////////////////////////////////////////////////////]]

env = {}
env.test = {}
env.test.trace = true
env.test.debug = true
env.test.in_dev = false
env.test.force_fresh_save = true
env.test.save_positions = true
env.test.auto_switch = true
-- env.test.players = {"Blue","Red","Yellow","Purple","Green",}
-- env.test.players = {"Yellow","Red","Blue","Purple",}
-- env.test.players = {"Yellow","Purple",}
env.test.players = {"Green","Red",}
-- env.test.players = {"Green","Red","Blue"}
-- env.test.players = {"Red","Green","Purple",}

env.game = {}
env.game.fill_delay = 2
env.game.use_help = true

GD = {}

--[[/////////////// Load Save /////////////////]]

--[[ *****************************
TTS Game Load
********************************]]
function onLoad(save_state)
	if env.test.force_fresh_save then saved_data = "" end
	if not(env.test.in_dev) then
		getObjectFromGUID(C.board_guid).interactable = false
		getObjectFromGUID(C.palace_object_guid).setInvisibleTo(Color.list)
		getObjectFromGUID(C.house_object_guid).setInvisibleTo(Color.list)
		for _,g in pairs(C.action_dials) do
			getObjectFromGUID(g).setInvisibleTo(Color.list)
		end
	end
	if (saved_data ~= "") then
    log("onLoad(): load with saved data")
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
    restoreGameState()
  else
		log("onLoad(): load with fresh state")
		GD.state = {}
		GD.state.global_UI = {}
		GD.state.board_UI = {}
		GD.game = {}
		GD.game.stage = "setup"
		GD.game.round = 1
		GD.env = {}
		GD.env.use_auction = false
		UI.setAttribute("opt_use_auction","isOn",GD.env.use_auction)
		GD.env.verbose = true
		UI.setAttribute("opt_verbose","isOn",GD.env.verbose)
		for _,g in pairs(C.player_pawns) do
			getObjectFromGUID(g).setLock(true)
		end
	end
	Wait.time(function() reloadUI(C.board_guid) end,5)
end

--[[ *****************************
HACK: reload an object's XML UI
********************************]]
function reloadUI(guid)
	if env.test.trace then log("reloadUI() guid: "..tostring(guid)) end
	local obj = getObjectFromGUID(guid)
	if obj ~= nil then obj.UI.setXml(obj.UI.getXml()) end
end

--[[ *****************************
Save game state
********************************]]
function onSave()
	local saved_data = JSON.encode(GD)
  if env.test.force_fresh_save then
    saved_data = ""
  end
  return saved_data
end

--[[ *****************************
Restore the game state.
TODO: implement
********************************]]
function restoreGameState()
	if env.test.trace then log("restoreGameState()") end
	log("TODO: restoreGameState()")
	--TODO: TEST THIS: rebuild the status display XML
	if GD.game.stage ~= "setup" then
		setupStatusPanel()
		updateGovernorTrack()
		updateStatusPanel()
	end

	--TODO: replay global UI setattributes

	--TODO: replay main board UI setattributes

	--NOTE: UI restore for all dials handled in dial onLoad()
	--NOTE: UI restore for all player boards handled in board onLoad()

	UI.setAttribute("status_info","visibility",GD.game.status_visibility)
end

--[[ ******************************
Wrapper function for global UI attributes.
Saves attribute update to be replayed on restore.
TODO: convert calls to use
*********************************]]
function UI_setAttribute(id, field, value)
  if env.test.trace2 then log("UI_setAttribute()") end
  assert(type(id) == "string", "UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "UI_setAttribute(): field must be a string")
  assert(value or value==false, "UI_setAttribute(): value missing")
  GD.states.global_UI[id.."|"..field] = value
  UI.setAttribute(id, field, value)
end

--[[ ******************************
Wrapper function for saving board UI attributes.
Saves attribute update to be replayed on restore.
TODO: convert calls to use
*********************************]]
function board_UI_setAttribute(id, field, value)
	if env.test.trace2 then log("board_UI_setAttribute()") end
	assert(type(id) == "string", "board_UI_setAttribute(): id must be a string")
	assert(type(field) == "string", "board_UI_setAttribute(): field must be a string")
	assert(value or value==false, "board_UI_setAttribute(): value missing")
	GD.states.board_UI[id.."|"..field] = value
	return getObjectFromGUID(C.board_guid).UI.setAttribute(id, field, value)
end

--[[/////////////// Event handlers /////////////////]]

--[[ *****************************
TODO: Thinking about these
********************************]]
function mouseOverCity(arg)
	log("mouse over")
	log(arg)
end
function mouseExitCity(arg)
	log("mouse exit")
	log(arg)
end
function mouseClickCity(arg)
	log("mouse click city")
	log(arg)
end

--[[ *****************************
Setup: Handler for start game options
********************************]]
function startOptionsBtn(player, value, id)
	if env.test.trace then log("startGameBtn() "..player.color..", "..id..": "..tostring(value)) end
	local setting = (value == 'True')
	UI.setAttribute(id, "isOn", setting)
	if id == "opt_use_auction" then
		broadcastToAll("Sorry, not yet imlemented")		--TODO: remove this when imlpemented
		UI.setAttribute(id, "isOn", false)
		return
		-- GD.env.use_auction = setting
	elseif id == "opt_verbose" then
		GD.env.verbose = setting
	else
		log("*** ERROR: startOptionsBtn() unknown id "..tostring(id))
	end
end

--[[ *****************************
Setup: A player clicked start game.
********************************]]
function startGameBtn(player, btn, id)
	if env.test.trace then log("startGameBtn() "..player.color) end
	if not(env.test.players) and #getSeatedPlayers() < 2 then
		broadcastToAll("At least 2 players needed to play")
		return
	end
	UI.setAttribute("startPanel","active",false)
	startGame()
end

--[[ *****************************
Player clicked a row on the Governor track
********************************]]
function governorClick(player, btn, id)
	if env.test.trace then log("governorClick() "..player.color..", id: "..tostring(id)) end
	if player.color ~= GD.game.current_player_color then return end
	if GD.game.players[player.color].governor_clicked then return end --guard double clicks
	GD.game.players[player.color].governor_clicked = true
	local track = GD.game.governor_track
	-- build a pending action and store current order in undo
	local row_clicked = tonumber(Split(id,'_')[2])
	local action = {
		key = "governor_track",
		player_color = pcol,	--TODO: need this?
		row_clicked = row_clicked,  --TODO: need this?
		undo = {
			restore_list = simpleDeepCopy(track),
		}
	}
	table.insert(GD.game.players[player.color].pending_actions, action)
	--find the data table index for the clicked row
	local index = -1
	for i=1,7 do
		if track[i].track_row == row_clicked then
			index = i
			break
		end
	end
	assert(index > 0,"***ERROR: bad track index")
	-- move down two (or one or zero) spots in track table, shift others up
	local temp = simpleDeepCopy(track[index])
	temp.track_row = temp.track_row - 2
	if temp.track_row < 1 then temp.track_row = 1 end
	temp.UI_row = temp.UI_row + 2
	if temp.UI_row > 7 then temp.UI_row = 7 end
	local new_index = index - 2
	if new_index < 1 then new_index = 1 end
	for i = index, new_index+1, -1 do
		track[i] = simpleDeepCopy(track[i-1])
		track[i].track_row = track[i-1].track_row + 1
		track[i].UI_row = track[i-1].UI_row - 1
	end
	track[new_index] = temp
	updateGovernorTrack()
	updateStatusPanel()
	governorButtons(false)
	getObjectFromGUID(C.action_dials[player.color]).call("setState",{state="complete_action",action_id="track"})
	getObjectFromGUID(C.player_boards[player.color]).call("setState",{undo=true})
end

--[[ *****************************
Handler for button clicks on player board
********************************]]
function playerBoardClick(player, btn, id)
	if env.test.trace then log("playerBoardClick(): "..player.color..", id = "..id) end
	local action = Split(id,'_')[1]
	if action == "done" then
		playerDone(player.color)
	elseif action == "undo" then
		playerUndo(player.color)
	elseif action == "extraAction" then
		extraAction(player.color)
	else
		log("*** ERROR: playerBoardClick(): unknown action id")
		return
	end
end

--[[ *****************************
Toggle the city status display for the player who clicked.
********************************]]
function statusClick(player, btn, id)
	if env.test.trace then log("statusClick() id: "..tostring(id)) end
	-- if env.test.debug then log(GD.game.status_visibility) end
	local players = Split(GD.game.status_visibility,'|')
	local index = indexOf(players, player.color)
	if index > 0 then
		table.remove(players,index)
	else
		table.insert(players,player.color)
	end
	GD.game.status_visibility = ""
	for _,pcol in ipairs(players) do
		if GD.game.status_visibility == "" then
			GD.game.status_visibility = pcol
		else
			GD.game.status_visibility = GD.game.status_visibility .."|"..pcol
		end
	end
	-- if env.test.debug then log("Setting vis to "..GD.game.status_visibility) end
	UI.setAttribute("status_info","visibility",GD.game.status_visibility)
end

--[[ *****************************
Handle dropping things on the main board.
House and palace drops off board are snapped back.
TODO: disable DEVELOPMENT stuff
********************************]]
function onObjectDrop(pcol, obj)
	if env.test.trace then log("onObjectDrop(): pcol "..pcol..", obj "..obj.getGUID()) end
	--/// DEV ///
	if env.test.save_positions then
		str = "Global: "
		str = str .. tostring(obj.getPosition())
		str = str .. "\nBoard: "
		str = str .. tostring(getObjectFromGUID(C.board_guid).positionToLocal(obj.getPosition()))
		Notes.setNotes(str)
	end
	--/// END DEV ///
	if GD.game.stage == "setup" then return end
	local type = obj.memo
	obj.setVelocity(Vector(0,0,0)) --in case player "throws it"
	if type == "character" then
		characterDrop(pcol, obj)
	elseif type == "palace" or type == "house" then
		local pos = obj.getPosition()
		local board = getObjectFromGUID(C.board_guid)
		local center = board.getBounds()["center"]
	  local size = board.getBounds()["size"]
		local snapback = false
		if pcol ~= GD.game.current_player_color then snapback = true
		elseif obj.getName() ~= pcol then snapback = true
	  elseif pos.x > center.x + (size.x/2) then snapback = true
	  elseif pos.x < center.x - (size.x/2) then snapback = true
	  elseif pos.z > center.z + (size.z/2) then snapback = true
	  elseif pos.z < center.z - (size.z/2) then snapback = true
		end
		if snapback then
			--TODO: consider use an array of GD.snaps for placed objects?  Use player board home loc if not in that list?
			obj.setPosition(getPlayerBoardLocation(obj))
			obj.setRotation(getObjectFromGUID(C.player_boards[obj.getName()]).getRotation())
			return
		end
		if type == "house" then
			houseDrop(pcol, obj)
		else
			palaceDrop(pcol, obj)
		end
	elseif type == "architect" then
		architectDrop(pcol, obj)
	else
		log("*** WARN: onObjectDrop() unknown object "..obj.getGUID())
		return
	end
end

function extraActionClick(obj, pcol, rclick)
	log("extraActionClick() "..obj.getName()..", "..pcol..", "..tostring(rclick))
end

--[[/////////////// Game Setup /////////////////////]]

--[[ *****************************
Randomly assign the 7 Governors to starting positions on the track.
********************************]]
function setupGovernorTrack()
	if env.test.trace then log("setupGovernorTrack()") end
	local temp = simpleDeepCopy(C.governors)
	local row = 0
	local ref = 7
	GD.game.governor_track = {}
	while #temp > 0 do
		local i = math.random(#temp)
		row = row + 1
		if row > 7 then
			log("*** ERROR: setupGovernorTrack() exceeded safety stop, too many rows")
			return
		end --safety
		table.insert(GD.game.governor_track,{city=temp[i].city,node=temp[i].node,track_row=row, UI_row=ref, scoring=false})
		table.remove(temp,i)
		ref = ref - 1
	end
	updateGovernorTrack()
end

--[[ *****************************
Update the board UI with Governor images on the track.
Assumes governor track data has been initialized.
********************************]]
function updateGovernorTrack()
	if env.test.trace then log("updateGovernorTrack()") end
	--set the governor images per gov track data table
	local board = getObjectFromGUID(C.board_guid)
	local filled = {}
	for i,entry in ipairs(GD.game.governor_track) do
		board.UI.setAttribute("gov_"..tostring(entry.track_row),"image",entry.city)
		table.insert(filled,entry.track_row)
	end
	--set remaining empty track spaces accordingly
	for row=1,17 do
		if not(contains(filled,row)) then
			if row > GD.game.round + 7 then
				board.UI.setAttribute("gov_"..tostring(row),"image","Gray-"..(row-7))
			else
				board.UI.setAttribute("gov_"..tostring(row),"image","Gray")
			end
		end
	end
end

--[[ *****************************
Setup: initialize the game
********************************]]
function startGame()
	if env.test.trace then log("startGame()") end
	-- GD.game.stage = "setup"
	GD.game.auction_characters = false --TODO: get this from start dialog
	setupGovernorTrack()
	setupNetwork()
	if not(setupPlayers()) then return end
	setupStatusPanel()
	UI.setAttribute("statusPanel","active","true")
	--for testing, set solo player to start player color
	local players = Player.getPlayers()
	if #players == 1 then
		if env.test.players and env.test.auto_switch then
			Player[players[1].color].changeColor(GD.game.current_player_color)
		end
	end
end

--[[ *****************************
Setup: setup the status UI for number of players
Assumes GD.game.player_order is established.
********************************]]
function setupStatusPanel()
	if env.test.trace then log("setupStatusPanel()") end
	local letters = {Yellow="Y",Red="R",Green="G",Blue="B",Purple="P",}
	local xml=UI.getXmlTable()
	local status_panel = getXmlElement("statusPanel",xml)
	local status_table = getXmlElement("status_table",status_panel)
	local columnWidths="100 40"
	local panel_width = 140
	--setup the header row
	local index = 3
	local player_columns = {}
	local header_row = getXmlElement("status_header_row",status_table)
	local header_cell = getXmlElement("status_h_template",header_row)
	for pcol,initial in pairs(letters) do
		if contains(GD.game.player_order,pcol) then
			table.insert(player_columns, pcol)
			local cell = simpleDeepCopy(header_cell)
			cell.attributes.id = "status_h_"..pcol
			local text = cell.children[1]
			text.attributes.id = "status_h_txt_"..pcol
			text.attributes.color = pcol
			text.attributes.text = initial
			header_row.children[index] = cell
			columnWidths = columnWidths.." 36"
			panel_width = panel_width + 36
			index = index + 1
		end
	end
	--setup the city rows
	local city_row = getXmlElement("status_row_template",status_table)
	local temp_row = simpleDeepCopy(city_row)
	local player_cell = getXmlElement("status_p_template",temp_row)
	status_table.children[2] = nil --wipe out the template so it can be replaced
	for i,gov in ipairs(GD.game.governor_track) do
		local row = simpleDeepCopy(temp_row)
		local ref = gov.UI_row
		log("creating row for child "..tostring(ref))
		row.attributes.id = "status_row_"..tostring(ref)
		local text = getXmlElement("status_city_name_template",row)
		text.attributes.id = "status_city_name_"..tostring(ref)
		text.attributes.text = gov.city
		local image = getXmlElement("status_city_image_template",row)
		image.attributes.id = "status_city_image_"..tostring(ref)
		image.attributes.image = gov.city
		for p,pcol in ipairs(player_columns) do
			local pcell = simpleDeepCopy(player_cell)
			local ptext = getXmlElement("status_p_text_template",pcell)
			ptext.attributes.id = "status_p_text_"..tostring(ref).."_"..pcol
			ptext.attributes.text = ""
			row.children[2+p] = pcell
		end
		table.insert(status_table.children,2,row) --always next after header, pushing rest downward
	end
	if env.test.debug then
		log("status table")
		-- log(status_table.children)
		for i,c in ipairs(status_table.children) do
			if i > 1 then
				log(tostring(i)..": id:"..c.attributes.id)
				log(c.children[2].children[1].attributes)
			end
		end
	end
	--reload the xml UI
	status_panel.attributes.width = tostring(panel_width)
	status_table.attributes.columnWidths = columnWidths
	UI.setXmlTable(xml)
end

--[[ *****************************
Setup: initialize network data
********************************]]
function setupNetwork()
	if env.test.trace then log("setupNetwork()") end
	GD.network = simpleDeepCopy(NETWORK)
	for i,node in ipairs(GD.network) do
		node.center = CENTERS[i]
		if node.type == "city" then
			node.houses = {}
			for _,pcol in pairs(C.table_colors) do
				node.houses[pcol] = {}
			end
			node.palaces = {}
			node.architects = {}
		elseif node.type == "village" then
			node.houses = {}
		end
	end
end

--[[ *****************************
Setup: initialize game for seated players
********************************]]
function setupPlayers()
	if env.test.trace then log("setupPlayers()") end
	local seated = getSeatedPlayers()
	if env.test.players ~= nil then
		seated = simpleDeepCopy(env.test.players)
	end
	GD.game.player_count = #seated
	if GD.game.player_count < 2 then
		broadcastToAll("2 or more players needed")
		return false
	end
	GD.game.player_order = {}
	for _,pcol in ipairs(C.table_colors) do
		if contains(seated,pcol) then table.insert(GD.game.player_order,pcol) end
	end
	GD.game.players = {}
	GD.game.status_visibility = "Pink"
	for _,pcol in ipairs(GD.game.player_order) do
		GD.game.players[pcol] = simpleDeepCopy(C.player_data)
		local player = GD.game.players[pcol]
		player.pawn_location = getObjectFromGUID(C.player_pawns[pcol]).getPosition()
		player.gold = 15
		player.extra_actions = 0
		getObjectFromGUID(C.player_pawns[pcol]).setLock(true)
		--initialize player pool
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		for i=1,12 do
			local pos = player_board.positionToWorld(C.player_board_pool_locations[i])
			table.insert(player.pool, i, {g=nil,p=pos})
		end
		GD.game.status_visibility = GD.game.status_visibility..'|'..pcol
	end
	UI.setAttribute("status_info","visibility",GD.game.status_visibility)
	GD.game.current_player = math.random(#GD.game.player_order)
	GD.game.current_player_color = GD.game.player_order[GD.game.current_player]
	broadcastToAll("Starting player will be "..GD.game.current_player_color)
	startLuaCoroutine(Global, "coroFillPlayerBoards")
	return true
end

--[[ *****************************
Setup: fill player boards with palaces and houses,
remove unused player objects and place unused palaces
Run as a coro with pauses between spawning objects.
********************************]]
function coroFillPlayerBoards()
	if env.test.trace then log("coroFillPlayerBoards(): START") end
	--private function to pause (yield) coro for a number of frames
	local pauseMe = function(frames)
		frames = frames or env.game.fill_delay
		local count = 0
		while count < frames do
			count = count + 1
			coroutine.yield(0)
		end
	end
	local house = getObjectFromGUID(C.house_object_guid)
	assert(house, "*** ERROR: coroFillPlayerBoards(): no house object")
	local palace = getObjectFromGUID(C.palace_object_guid)
	assert(palace, "*** ERROR: coroFillPlayerBoards(): no palace object")

	--remove unused player area objects
	local board = getObjectFromGUID(C.board_guid)
	local rot = board.getRotation()
	copy({palace})
	for _,pcol in ipairs(C.table_colors) do
		if GD.game.players[pcol] == nil then
			getObjectFromGUID(C.player_boards[pcol]).destruct()
			getObjectFromGUID(C.action_dials[pcol]).destruct()
			getObjectFromGUID(C.player_aids[pcol]).destruct()
			getObjectFromGUID(C.player_pawns[pcol]).destruct()
			--place unused player palaces in outer city palaces
			for name,city in pairs(C.cities) do
				local index = #GD.network[city.node].palaces + 1
				local pos = board.positionToWorld(GD.network[city.node].center - C.city_palace_offsets[index])
				local p = {position=pos}
				local obj = paste(p)[1]
				assert(obj, "*** ERROR: coroFillPlayerBoards(): failed to paste object")
				obj.setRotation(rot)
				obj.setColorTint(C.object_color_tints[pcol])
				obj.setName("Unused")
				obj.memo = "palace"
				obj.tooltip = false
				obj.interactable = false
				table.insert(GD.network[city.node].palaces, {g=obj.getGUID(), c=pcol, p=pos})
				pauseMe()
				Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
			end
		end
	end
	pauseMe(10)
	--fill seated player boards
	for _,pcol in ipairs(GD.game.player_order) do
		local player = GD.game.players[pcol]
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		assert(player_board, "*** ERROR: coroFillPlayerBoards(): no board object for color "..tostring(pcol))
		player_board.tooltip = false
		local rot = player_board.getRotation()
		copy({palace})
		for i,loc in ipairs(C.player_board_palace_locations) do
			local pos = player_board.positionToWorld(loc)
			local p = {position=pos}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "palace"
			obj.setDescription("Palace")
			table.insert(player.palaces, {g=obj.getGUID(),p=pos})
			pauseMe()
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		end
		copy({house})
		for i,loc in ipairs(C.player_board_quarry_locations) do
			local pos = player_board.positionToWorld(loc)
			local p = {position=pos}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "house"
			obj.setDescription("House")
			table.insert(player.quarry, {g=obj.getGUID(),p=pos})
			pauseMe()
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		end
		for i=5,8 do
			local p = {position=player.pool[i].p}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "house"
			obj.setDescription("House")
			player.pool[i].g = obj.getGUID()
			pauseMe()
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		end
		local dial = getObjectFromGUID(C.action_dials[pcol])
		assert(dial, "*** ERROR: coroFillPlayerBoards(): no dial object for color "..tostring(pcol))
		dial.tooltip = false
		dial.call("setState",{state="game_start"})
	end

	--setup for next game stage
	if GD.game.auction_characters then

		--TODO: setup for auction

	else
		--setup for character card selection
		for _,char in ipairs(C.characters) do
			getObjectFromGUID(char.g).setLock(false)
		end
		GD.game.stage = "select_starting_characters"
		GD.game.characters_selected = 0
		broadcastToAll(GD.game.current_player_color.." player select a character card then continue clockwise around table")
		local p = {dormant = false,done = false,undo = false,}
		p.help_text = "Select a character card then click Done."
		for _,pcol in ipairs(GD.game.player_order) do
			p.active = (pcol == GD.game.current_player_color)
			p.gold_coins = GD.game.players[pcol].gold
			p.extra_actions = GD.game.players[pcol].extra_actions
			local player_board = getObjectFromGUID(C.player_boards[pcol])
			player_board.call("setState",p)
		end
	end
	if env.test.trace then log("coroFillPlayerBoards(): EXIT") end
	return 1
end

--[[ *****************************
Load 6 starting houses into player Quarry after setup
********************************]]
function startingQuarry(pcol)
	if env.test.trace then log("startingQuarry(): "..pcol) end
	local quarry = GD.game.players[pcol].quarry
	local pool = GD.game.players[pcol].pool
	for i=1,6 do
		local index = 16 - i + 1
		local house = getObjectFromGUID(quarry[index].g)
		assert(house,"*** ERROR: startingQuarry() nil quarry house")
		house.setPosition(pool[i].p)
		quarry[index].g = nil
		pool[i].g = house.getGUID()
	end
end

--[[ *****************************
Move 2 houses from quarry
********************************]]
function quarryAction(pcol)
	if env.test.trace then log("startingQuarry(): "..pcol) end
	local player = GD.game.players[pcol]
	local quarry = player.quarry
	local pool = player.pool
	local success = false
	for i=1,2 do
		for p=1,12 do
			if not(pool[p].g) then
				for q=16,1,-1 do
					if quarry[q].g then
						getObjectFromGUID(quarry[q].g).setPosition(pool[p].p)
						pool[p].g = quarry[q].g
						quarry[q].g = nil
						success = true
						break --out of quarry loop
					end
				end
				break --out of pool loop
			end
		end
	end
	return success
end

--[[ *****************************
Finalize a starting character select action
Player has clicked "Done"
********************************]]
function setStartingCharacter(action)
	if env.test.trace then log("setStartingCharacter()") end
	if GD.game.stage ~= "select_starting_characters" then
		log(("*** ERROR: setStartingCharacter() invalid game stage")) --shouldn't happen
		return
	end
	local pcol = action.player_color
	GD.game.players[pcol].character_id = action.character_id
	GD.game.characters_selected = GD.game.characters_selected + 1
	if GD.game.characters_selected == GD.game.player_count then
		--All players selected a character, now setup game for initial house placement
		updateTurnOrder()
		setNextPlayer(FIRST)
		GD.game.stage = "initial_placement"
		broadcastToAll("Begin initial house placement")
		local p ={done=false,undo=false}
		p.help_text = "Place one starting house from Build Pool.\nOnly place on Villages."
		for pcol,pdata in pairs(GD.game.players) do
			for _,e in ipairs(pdata.pool) do
				if e.g then getObjectFromGUID(e.g).setLock(false) end
			end
			GD.game.players[pcol].init_placements = 4
			p.active = (pcol == GD.game.current_player_color)
			getObjectFromGUID(C.player_boards[pcol]).call("setState",p)
		end
		GD.game.players_init_placed = 0
		GD.game.init_placement = 4
	else
		getObjectFromGUID(C.player_boards[pcol]).call("setState")
		getObjectFromGUID(C.player_boards[setNextPlayer()]).call("setState", {active=true})
	end
end

--[[ *****************************
Finalize an initial house placement action
Player has clicked "Done"
********************************]]
function setInitialPlacement(action)
	if env.test.trace then log("setInitialPlacement()") end
	if GD.game.stage ~= "initial_placement" then
		log(("*** ERROR: setInitialPlacement() invalid game stage")) --shouldn't happen
		return
	end
	local obj = getObjectFromGUID(action.guid)
	local player = GD.game.players[action.player_color]
	removeFromPlayerBoard(obj)
	player.init_placements = player.init_placements - 1
	player.placed_houses[obj.getGUID()] = obj.getPosition()
	GD.game.players_init_placed = GD.game.players_init_placed + 1
	if GD.game.players_init_placed == GD.game.player_count then
		--reset for next round of placement until all 4 placed
		GD.game.players_init_placed = 0
		GD.game.init_placement = GD.game.init_placement - 1
	end
	if GD.game.init_placement == 0 then
		--End of placement, setup for first round
		for pcol,pdata in pairs(GD.game.players) do
			startingQuarry(pcol)
		end
		broadcastToAll("Begin First Round")
		GD.game.current_round = 0
		beginNextRound()
		return
	else
		getObjectFromGUID(C.player_boards[action.player_color]).call("setState")
		getObjectFromGUID(C.player_boards[setNextPlayer()]).call("setState",{active=true})
	end
end

--[[/////////// Game Play ///////////////////////]]

--[[ *****************************
TODO: document
********************************]]
function beginNextRound()
	if env.test.trace then log("beginNextRound()") end
	GD.game.current_round = GD.game.current_round + 1
	moveMaharaja()
	GD.game.remaining_round_players = {}
	GD.game.stage = "select_actions"
	for pcol,pdata in pairs(GD.game.players) do
		local dial = getObjectFromGUID(C.action_dials[pcol])
		dial.call("setState",{state="select_actions",reset=true})
		GD.game.players[pcol].has_actions = true --TODO: move this to "confirm" button?
		local txt = "Secretly choose turn actions and confirm with Done.\n"
		txt = txt .. "Player turns will begin once all have confirmed.\n"
		txt = txt .. "Until then selections can be modified."
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{active=true,done=false,undo=false,help_text=txt})
		table.insert(GD.game.remaining_round_players, pcol)
	end
end

--[[ *****************************
Process a dropped character card.
Result depends on game stage.
TODO: handle during player turn
********************************]]
function characterDrop(pcol, obj)
	if env.test.trace then log("characterDrop()") end
	local char_id = getCharacterId(obj.getGUID())
	local board = getObjectFromGUID(C.board_guid)
	if GD.game.stage == "select_starting_characters" then
		if pcol ~= GD.game.current_player_color then --ignore non active player
			obj.setPosition(C.characters[char_id].bank_pos)
			obj.setRotation(board.getRotation())
			return
		end
		if #GD.game.players[pcol].pending_actions > 0 then --only select one
			broadcastToColor("Character already selected", pcol)
			obj.setPosition(C.characters[char_id].bank_pos)
			obj.setRotation(board.getRotation())
			return
		end
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		local pos = player_board.positionToWorld(C.player_board_character_location)
		local rot = player_board.getRotation()
		obj.setPositionSmooth(pos, false, true)
		obj.setRotation(rot)
		Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		local action = {
			key = "select_starting_character",
			player_color = pcol,
			character_id = char_id,
			undo = {
				guid = obj.getGUID(),
				snapback = {pos=C.characters[char_id].bank_pos, rot=board.getRotation()},
			},
		}
		table.insert(GD.game.players[pcol].pending_actions, action)
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=true,undo=true})
	elseif GD.game.stage == "player_turn" then

		--TODO: implement this

	end
end

--[[ *****************************
Process a dropped house.
Result depends on game stage.
********************************]]
function houseDrop(pcol, obj)
	if env.test.trace then log("houseDrop()") end
	local board = getObjectFromGUID(C.board_guid)
	local color = obj.getName()
	local function snapBack()
		if isObjectPlaced(obj.getGUID()) then
			log("TODO: Handle placed obj snapback ***")
			--TODO: use array of GD.snaps for placed objects?
		else
			obj.setPosition(getPlayerBoardLocation(obj))
			obj.setRotation(getObjectFromGUID(C.player_boards[color]).getRotation())
		end
		return
	end
	local pos = obj.getPosition()
	pos.y = 0
	local index = closestNode(pos)
	log("nearest is id "..tostring(index)..", type "..GD.network[index].type..", name "..GD.network[index].name)
	if index < 1 then
		snapBack(obj)
		return
	end
	if GD.game.stage == "initial_placement" then
		local node = GD.network[index]
		if node.type == "village" then
			if isVillageFull(node) then
				snapBack()
				return
			end
			table.insert(node.houses,{g=obj.getGUID(),c=obj.getName()})
			local pos = board.positionToWorld(node.center)
			if GD.game.player_count > 2 then
				--TODO: set position of house relative to village center, remove HACK: VILLAGE_OFFSET (working pretty good)
				local pos_1 = node.center - VILLAGE_OFFSET
				local pos_2 = node.center + VILLAGE_OFFSET
				pos = board.positionToWorld(pos_1)
				if #node.houses == 1 then pos = board.positionToWorld(pos_2) end
			end
			pos.y = 1.5
			obj.setRotation(board.getRotation())
			obj.setPosition(pos)
			Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
			--add a pending action for this house placement
			local action = {
				key = "initial_placement",
				player_color = pcol,
				guid = obj.getGUID(),
				undo = {
					node_index = index,
					guid = obj.getGUID(),
					snapback = {pos=getPlayerBoardLocation(obj),rot=getObjectFromGUID(C.player_boards[pcol]).getRotation()}
				},
			}
			--show done and undo buttons
			table.insert(GD.game.players[pcol].pending_actions, action)
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=true,undo=true})
		elseif node.type == "city" then
			snapBack()
			return
		else
			snapBack()
			return
		end
	else

		log("TODO: handle house drop during play ***")

	end
end

--[[ ********* TODO: *************
Process a dropped palace.
********************************]]
function palaceDrop(pcol, obj)
	log("TODO: palaceDrop ****")
end

--[[ ********* TODO: *************
Process a dropped architect.
********************************]]
function architectDrop(pcol, obj)
	log("TODO: architectDrop ****")
end

--[[ *****************************
Start a player's action turn.
********************************]]
function startPlayerTurn(pcol)
	if env.test.trace then log("startPlayerTurn() for player "..tostring(pcol)) end
	local player = GD.game.players[pcol]
	assert(player,"Failed to locate player for color "..tostring(pcol))
	player.failed_actions = false
	player.pending_actions = {}
	if GD.env.verbose then printToAll("Starting turn for player "..pcol) end
	local dial = getObjectFromGUID(C.action_dials[pcol])
	Wait.condition(function() dial.call("setState",{state="player_turn"}) end,
		function() return(dial.resting) end, 5) --HACK: might be flipping from lock actions call so wait
	--unlock pawn
	getObjectFromGUID(C.player_pawns[pcol]).setLock(false)
	--set and/or execute bonus of character tile
	player.character_bonus = nil
	if player.character_id == 7 then
		player.extra_actions = player.extra_actions + 1
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{extra_actions=player.extra_actions})
		if GD.env.verbose then printToAll(pcol.." +1 extra action token for the Yogi") end
	elseif player.character_id == 6 then
		if env.test.debug then log("Setting player "..pcol.." discounted palace build cost to 9") end
		player.character_bonus = "build_palace_discount"
	elseif player.character_id == 5 then
		dial.call("setState",{state="free_action"})
		if env.test.debug then log("Setting player "..pcol.." free Architect travel") end
		player.character_bonus = "free_build_move"
	elseif player.character_id == 4 then
		if env.test.debug then log("Setting player "..pcol.." free Architect travel") end
		player.character_bonus = "free_travel"
	elseif player.character_id == 3 then
		if env.test.debug then log("Setting player "..pcol.." outer palace score == 2") end
		player.character_bonus = "outer_palace_scoring"
	elseif player.character_id == 2 then
		player.gold = player.gold + 1
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
		if GD.env.verbose then printToAll(pcol.." +1 gold for the Trader") end
	end
	--execute any immediate actions, set pawn, house, palace lock state based on actions selected
	local palace,pool,move,track,char = false,false,false,false,false
	for _,action in ipairs(player.dial_actions) do
		if action.action_id == "gold" then
			player.gold = player.gold + 2
			dial.call("setState",{state="complete_action",action_id="gold"})
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
			if GD.env.verbose then printToAll(pcol.." +2 gold for Coins action") end
		elseif action.action_id == "quarry" then
			--TODO: immediate quarry action
			if quarryAction(pcol) then
				dial.call("setState",{state="complete_action",action_id="quarry"})
				if GD.env.verbose then printToAll(pcol.." moves 2 houses into their Build Pool") end
			else
				dial.call("setState",{state="fail_action",action_id="quarry"})
				if GD.env.verbose then printToAll(pcol.." is unable to complete selected Quarry action!") end
				player.failed_actions = true
			end
		elseif action.action_id == "palace" then palace = true
		elseif action.action_id == "house" or action.action_id == "free" then pool = true
		elseif action.action_id == "move" or action.action_id == "free" then move = true
		elseif action.action_id == "track" then track = true
		elseif action.action_id == "character" then char = true
		end
	end
	if palace then unplayedPalacesLock(pcol, false) end
	if pool then buildPoolLock(pcol, false) end
	if move then placedHousesLock(pcol, false) end
	if track then governorButtons(true) end
	if char then charactersLock(pcol, false) end
	--enable player board for actions
	local txt = "Execute actions in any order.\n"
	txt = txt.."May move Architect at any time.\n"
	txt = txt.."All required actions must be executed.\n"
	txt = txt.."Penalty: All other players + 2 coins."
	for _,p in ipairs(GD.game.player_order) do
		local active = (p == pcol)
		getObjectFromGUID(C.player_boards[p]).call("setState",{active=active,done=active,undo=false,help_text=txt})
	end
end

--[[ *****************************
Process player Done click based on current game stage.
--For all entries in the player's pending action list:
	-- POP an entry off the LIFO stack
	-- finallize the pendign action, update data structures etc.
	-- remove the entry from the LIFO stack
	-- if more entries, repeat
********************************]]
function playerDone(pcol)
	if env.test.trace then log("playerDone(): "..pcol) end
	local player = GD.game.players[pcol]
	if GD.game.stage == "select_starting_characters" then  --Done during character selection
		local action = player.pending_actions[1]
		assert(action,"*** ERROR: missing starting character action")
		setStartingCharacter(action)
		if env.test.debug then log("Player "..pcol.." finalize "..action.key.." action") end
		table.remove(player.pending_actions, 1)
	elseif GD.game.stage == "initial_placement" then  --Done during initial placement
		local action = player.pending_actions[1]
		assert(action,"*** ERROR: missing initial placement action")
		setInitialPlacement(action)
		if env.test.debug then log("Player "..pcol.." finalize "..action.key.." action") end
		table.remove(player.pending_actions, 1)
	elseif GD.game.stage == "select_actions" then  --Done during action selection
			if player.choosing_extra_action then
				setExtraAction(pcol)
			else
			log("Player clicked Done during action selection")
			local p1,p2 = false,false
			for _,action in ipairs(player.dial_actions) do
				if action.dial_pointer == "pointer-1" then p1 = true end
				if action.dial_pointer == "pointer-2" then p2 = true end
			end
			if not(p1 and p2) then
				lob("*** WARN: playerDone() two player action selections have not been made")
				return
			end
			player.actions_set = true
			local all_set = true
			for _,pdata in pairs(GD.game.players) do
				if not(pdata.actions_set) then all_set = false end
			end
			if all_set then
				broadcastToAll("All players have set actions, starting player turns")
				for _,pcol in ipairs(GD.game.player_order) do
					getObjectFromGUID(C.action_dials[pcol]).call("setState",{state="actions_locked"})
					getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=false,help=false})
				end
				GD.game.stage = "player_turns"
				startPlayerTurn(setNextPlayer(FIRST))
			else
				local dial = getObjectFromGUID(C.action_dials[pcol])
				dial.call("setState",{state="actions_selected",modify=true})
				getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=false})
			end
		end
	elseif GD.game.stage == "player_turns" then --Done during other game stages
		if #player.pending_actions == 0 then
			log("*** WARN: playerDone() no actions to finalize for player "..pcol)
		end
		while #player.pending_actions > 0 do
			local index = #player.pending_actions
			local action = player.pending_actions[index]
			if action.key == "governor_track" then
				log("TODO: finalize track action")
				player.governor_clicked = false
				--TODO: anything else?
			elseif action.key == "coins" then
				--TODO: nothing to do here? coins given at start of turn
			elseif action.key == "character" then
				log("TODO: finalize character action")
			elseif action.key == "palace" then
				log("TODO: finalize palace action")
			elseif action.key == "quarry" then
				--TODO: nothing to do here? quarry executed at start of turn
			elseif action.key == "move" then
				log("TODO: finalize move action")
			elseif action.key == "house" then
				log("TODO: finalize house action")
			else
				log("*** ERROR: playerDone() unknown action key "..tostring(action.key))
				return
			end
			if env.test.debug then log("Player "..pcol.." finalize "..action.key.." action") end
			table.remove(player.pending_actions, index)
		end
		if player.failed_actions then
			--give other players +2 gold
			for color,player in pairs(GD.game.players) do
				if color ~= pcol then
					player.gold = player.gold + 2
					getObjectFromGUID(C.player_boards[color]).call("setState",{gold_coins=player.gold})
					if GD.env.verbose then printToAll(color.." recieves +2 gold") end
				end
			end
		else

			--TODO:
			-- if actions still to complete,  then
				-- show confirm dialog
				-- return

		end
		endTurn(pcol)
	else
		log("*** ERROR: unknown game stage")
	end
end

--[[ *****************************
Check for end of round & start a new one otherwise start next players turn
********************************]]
function endTurn(pcol)
	if env.test.trace then log("endTurn() "..tostring(pcol)) end
	local index = indexOf(GD.game.remaining_round_players,pcol)
	assert(index > 0,"***ERROR: could not locate player in remaining_round_players")
	table.remove(GD.game.remaining_round_players,index)
	if #GD.game.remaining_round_players == 0 then
		beginNextRound()
	else
		if GD.game.current_round == 10 then
			endGame()
			return
		end
		startPlayerTurn(setNextPlayer())
	end
end

--[[ *****************************
TODO: document
--POP an entry off the player's LIFO pending actions stack
--undo any placements, action effects, etc.
--remove the pending action entry
--disable player's done button
--if no remaining pending actinos, disable player's undo button
********************************]]
function playerUndo(pcol)
	if env.test.trace then log("playerUndo(): "..pcol) end
	local actions = GD.game.players[pcol].pending_actions
	if #actions == 0 then return end
	local action = actions[#actions]
	if env.test.debug then log("action to undo:");log(action) end
	if action.key == "select_starting_character" then
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
	elseif action.key == "initial_placement" then
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
		local node = GD.network[action.undo.node_index]
		if node.houses[1] and node.houses[1].g == action.guid then
			node.houses[1] = nil
		elseif node.houses[2] and node.houses[2].g == action.guid then
			node.houses[2] = nil
		else
			log("*** ERROR: playerUndo() unable to clear house "..action.guid.."from network node "..tostring(action.undo.node_index))
		end
	elseif action.key == "governor_track" then
		log("TESTING: undoing the gov track action")
		GD.game.governor_track = simpleDeepCopy(action.undo.restore_list)
		updateGovernorTrack()
		updateStatusPanel()
		governorButtons(true)
		getObjectFromGUID(C.action_dials[pcol]).call("setState",{state="undo_action",action_id="track"})
		GD.game.players[pcol].governor_clicked = false
	else
		log("*** ERROR: playerDone() unknown action key "..tostring(action.key))
		return
	end
	--remove entry and update player board UI
	table.remove(GD.game.players[pcol].pending_actions, index)
	if #GD.game.players[pcol].pending_actions == 0 then
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{undo=false})
	end
end

--[[ ********* TODO **************
TODO: document
********************************]]
function extraAction(pcol)
	if env.test.trace then log("extraAction(): "..pcol) end
	log("TODO: implement extraAction() <--------------------")
end

--[[ *****************************
TODO: implement and document
********************************]]
function moveMaharaja()
	if env.test.trace then log("moveMaharaja()") end
	-- move maha to next city position (1st in gov track table)
	local board = getObjectFromGUID(C.board_guid)
	local track = GD.game.governor_track
	local city = track[1].city
	local pos = board.positionToWorld(C.cities[city].maharaja_pos)
	local maha = getObjectFromGUID(C.maharaja_guid)
	maha.setLock(false)
	-- maha.setPositionSmooth(pos, false, true)
	maha.setPosition(pos)
	Wait.condition(function() maha.setLock(true) end, function() return(maha.resting) end, 2)
	-- move table 1st to 7th, shift others up
	local temp = simpleDeepCopy(track[1])
	temp.UI_row = track[7].UI_row
	temp.track_row = track[7].track_row + 1
	for i=2,7 do
		track[i-1] = simpleDeepCopy(track[i])
		track[i-1].UI_row = track[i-1].UI_row + 1
	end
	track[7] = temp
	-- update city status UI
	updateGovernorTrack()
	updateStatusPanel()
end

--[[ ********* TODO **************
TODO: implement and document
********************************]]
function endGame()
	if env.test.trace then log("endGame(): "..pcol) end
	log("TODO: implement endGame() <--------------------")
end

--[[/////////////// Support functions /////////////////////]]

--[[ *****************************
Set the locked state of a player's houses in the build pool
********************************]]
function buildPoolLock(pcol, locked)
	if env.test.trace then log("buildPoolLock()") end
	locked = locked or false
	for _,e in ipairs(GD.game.players[pcol].pool) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of a player's unplayed palaces
********************************]]
function unplayedPalacesLock(pcol, locked)
	if env.test.trace then log("unplayedPalacesLock()") end
	locked = locked or false
	for _,e in ipairs(GD.game.players[pcol].palaces) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of a player's placed houses
********************************]]
function placedHousesLock(pcol, locked)
	if env.test.trace then log("placedHousesLock()") end
	locked = locked or false
	for _,e in ipairs(GD.game.players[pcol].placed_houses) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of a palaces on a player board
Defaults to unlocked
********************************]]
function palacesLock(pcol, locked)
	locked = locked or false
	if env.test.trace then log("palacesLock() "..tostring(locked)) end
	for _,e in ipairs(GD.game.players[pcol].palaces) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of a player's build pool
Defaults to unlocked
********************************]]
function poolLock(pcol, locked)
	locked = locked or false
	if env.test.trace then log("poolLock() "..tostring(locked)) end
	for _,e in ipairs(GD.game.players[pcol].pool) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of all characters.
If pcol supplied, skip it.
Defaults to unlocked
********************************]]
function charactersLock(pcol, locked)
	locked = locked or false
	pcol = pcol or "none"
	if env.test.trace then log("charactersLock() player: "..tostring(pcol)..", locked = "..tostring(locked)) end
	local player = getObjectFromGUID(pcol)
	for id,char in ipairs(C.characters) do
		if not(player) or player.character_id ~= id then
			getObjectFromGUID(char.g)setLock(locked)
		end
	end
end

--[[ *****************************
TODO: document
********************************]]
function updateStatusPanel()
	if env.test.trace then log("updateStatusPanel()") end
	--update city names and images from GD.game.governor_track
	for i,gov in ipairs(GD.game.governor_track) do
		UI.setAttribute("status_city_name_"..gov.UI_row, "text", gov.city)
		UI.setAttribute("status_city_image_"..gov.UI_row, "image", gov.city)
	end
	--update player scores per city
	log("TODO: update status panel UI with player city scores")
end

--[[ *****************************
Remove an object from player board data.
********************************]]
function removeFromPlayerBoard(obj)
	if env.test.trace then log("removeFromPlayerBoard()") end
	local player = GD.game.players[obj.getName()]
	assert(player,"*** ERROR: removeFromPlayerBoard() could not locate player data")
	if obj.memo == "palace" then
		for i,data in ipairs(player.palaces) do
			if data.g == obj.getGUID() then
				-- table.remove(player.palaces, i)
				player.palaces[i].g = nil
				return
			end
		end
	else
		for i,data in ipairs(player.pool) do
			if data.g == obj.getGUID() then
				-- table.remove(player.pool, i)
				player.pool[i].g = nil
				return
			end
		end
	end
	log("*** WARN: could not find object "..obj.getGUID().." in "..obj.getName().." data")
end

--[[ ********* TODO ??? **************
--TODO: thinking about this,
********************************]]
function isObjectPlaced(guid)
	return false
end

--[[ *********** TODO ??? ******************
TODO: need this in a fn? Used only once?
********************************]]
function isVillageFull(node)
	if GD.game.player_count == 2 and #node.houses == 1 then return true
	elseif GD.game.player_count > 2 and #node.houses == 2 then return true end
	return false
end

--[[ *****************************
Return the snap back playerboard location for an object.
Playerboard determined from object name(color))
********************************]]
function getPlayerBoardLocation(obj)
	local color = obj.getName()
	for _,d in ipairs(GD.game.players[color].pool) do
		if d.g == obj.getGUID() then return d.p end
	end
	for _,d in ipairs(GD.game.players[color].palaces) do
		if d.g == obj.getGUID() then return d.p end
	end
	for _,d in ipairs(GD.game.players[color].quarry) do
		if d.g == obj.getGUID() then return d.p end
	end
end

--[[ *****************************
Update game player order sorted by current player character IDs
TODO: actually update and update UI
********************************]]
function updateTurnOrder()
	if env.test.trace then log("updateTurnOrder()") end
	--sort player order by character ID
	local new_order = nil
	for pcol,pdata in pairs(GD.game.players) do
		if new_order == nil then
			new_order = {pcol}
		else
			for i,player_color in ipairs(new_order) do
				if pdata.character_id < GD.game.players[player_color].character_id then
					table.insert(new_order, i, pcol)
					break
				elseif i == #new_order then
					table.insert(new_order, pcol)
					break
				end
			end
		end
	end
	GD.game.player_order = simpleDeepCopy(new_order)
	if env.test.debug then
		log("New player order sorted by char ID:")
		log(GD.game.player_order)
	end
	for i,pcol in ipairs(GD.game.player_order) do
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		player_board.call("setState",{turn_order=i})
	end
end

--[[ *****************************
Set the next active player.
Clockwise from current player if selecting initial characters.
Uses order sorted by character ID in other stages of play.
Returns color of current player
********************************]]
function setNextPlayer(first)
	first = first or false
	if env.test.trace then log("setNextPlayer()") end
	local old_color = GD.game.current_player_color
	if first then
		GD.game.current_player = 1
	elseif GD.game.stage == "select_starting_characters" then
		local next = GD.game.current_player + 1
		if next > #GD.game.player_order then next = 1 end
		GD.game.current_player = next
	else
		if GD.game.stage == "initial_placement" then
			--find first player in order that needs to place this round of placements
			for i,pcol in ipairs(GD.game.player_order) do
				if GD.game.players[pcol].init_placements == GD.game.init_placement then
					GD.game.current_player = i
					break
				end
			end
		else
			--find first player in order that has actions
			for i,pcol in ipairs(GD.game.player_order) do
				if GD.game.players[pcol].has_actions then
					GD.game.current_player = i
					break
				end
			end
		end
	end
	GD.game.current_player_color = GD.game.player_order[GD.game.current_player]
	broadcastToAll("Current player now "..GD.game.current_player_color)
	if env.test.players and env.test.auto_switch then
		if old_color != GD.game.current_player_color then
			Player[old_color].changeColor(GD.game.current_player_color)
		end
	end
	return GD.game.current_player_color
end

--[[ *****************************
Locate the closest network node to the position.
TODO: be smarter about city radius vs village radius.
As is the radius is equal so dropping in a city edge
might detect as a nearby village.  Minor thing.
********************************]]
function closestNode(pos)
	if env.test.trace then log("closestNode()") end
	local board = getObjectFromGUID(C.board_guid)
	local nearest_node = -1
	local shortest_dist = nil
	for i,node in ipairs(GD.network) do
		local dist = Vector.sqrDistance(pos, board.positionToWorld(node.center))
		if shortest_dist then
			if dist < shortest_dist then
				shortest_dist = dist
				nearest_node = i
			end
		else
			shortest_dist = dist
			nearest_node = i
		end
	end
	return nearest_node
end

--[[ *****************************
Lookup and return the id for a character card guid
Returns -1 if not found (log an error)
********************************]]
function getCharacterId(guid)
	for id,char in ipairs(C.characters) do
		if char.g == guid then
			return id
		end
	end
	log("*** ERROR: getCharacterId(): no character card found for guid "..tostring(guid))
	return -1
end

--[[ *****************************
TODO: implement and document
********************************]]
function governorButtons(on)
	on = on or false
	if env.test.trace then log("enableGovernorButtons() "..tostring(on)) end
	local board = getObjectFromGUID(C.board_guid)
	for _,gov in ipairs(GD.game.governor_track) do
		local id = "gov_"..tostring(gov.track_row)
		if on then
			log("Turn button on for image in row "..id)
			board.UI.setClass(id ,"gImg_")
		else
			log("Turn button off for image in row "..id)
			board.UI.setClass(id,"gImg")
		end
	end
	Wait.frames(function() reloadUI(C.board_guid) end, 60)
end

--[[/////////////// External call functions /////////////////////]]

--[[ ***************************
Called from player dial during player action selection.
params:
	- command:
			- Set: Update player's data with selected action(s), enable Done if both pointers are set.
			- Clear: remove player action data, disable Done (dial modify button clicked)
		player_color: The player color.
		actions: The list of actions for an update (command==set)
********************************]]
function updatePlayerActionSelection(params)
	if env.test.trace then log("updatePlayerActionSelection()") end
	if env.test.debug then log(params) end
	local pcol = params.player_color
	assert(pcol,"updatePlayerActionSelection(): missing player color")
	if params.command == "clear" then
		GD.game.players[pcol].actions_set = false
		GD.game.players[pcol].dial_actions = {}
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		player_board.call("setState",{done=false})
	elseif params.command == "update" then
		assert(params,"updatePlayerActionSelection(): missing params")
		assert(pcol,"updatePlayerActionSelection(): missing player color")
		assert(params.actions,"updatePlayerActionSelection(): missing action list")
		GD.game.players[pcol].dial_actions = simpleDeepCopy(params.actions)
		--enable done button for player if both actions are set
		local p1,p2 = false,false
		for _,action in ipairs(GD.game.players[pcol].dial_actions) do
			if action.dial_pointer == "pointer-1" then p1 = true
			elseif action.dial_pointer == "pointer-2" then p2 = true
			end
		end
		if p1 and p2 then
			local player_board = getObjectFromGUID(C.player_boards[pcol])
			player_board.call("setState",{done=true})
		end
	else
		log("*** ERROR: unknown command parameter: "..tostring(params.command))
		return
	end
end

--[[/////////////// DEVELOPMENTAL STUFF ///////////////////////]]

function testCityHouses(pcol, city_name)
	log("put selected houses in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(city_name.." center is "..tostring(center))
	local color_indexes = {Yellow = 0,Red = 0,Green = 0,Blue = 0,Purple = 0,}
	for _,o in ipairs(stuff) do
		local color = o.getName()
		color_indexes[color] = color_indexes[color] + 1
		local offset = Vector(C.city_house_offsets[color][color_indexes[color]].o)
		log("placing "..color.." object "..o.getGUID().." with offset "..tostring(color_indexes[color])..": "..tostring(offset))
		local pos = center - offset
		local rot = Vector(C.city_house_offsets[color][color_indexes[color]].r)
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function testCityPalaces(pcol, city_name)
	log("put selected houses in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	if #stuff > 7 then
		log("Only 7 palaces max allowed in a city")
		return
	end
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(center)
	for index,o in ipairs(stuff) do
		local offset = Vector(0,0,0)
		if index < 7 then offset = C.city_palace_offsets[index] end
		log("putting object "..o.getGUID().." in loc "..tostring(index)..", at offset "..tostring(offset))
		local pos = center - offset
		local rot = board.getRotation()
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function testCityPawns(pcol, city_name)
	log("put selected pawns in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	if #stuff > 5 then
		log("Only 5 pawns max allowed in a city")
		return
	end
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(center)
	for index,o in ipairs(stuff) do
		local offset = Vector(C.city_pawn_offsets[index])
		log("putting object "..o.getGUID().." in loc "..tostring(index)..", at offset "..tostring(offset))
		local pos = center - offset
		local rot = Vector(0,90,0)
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function getWorldPos(pcol)
	log("Getting positions of selected objects relative to world")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	local s=""
	for i,o in ipairs(stuff) do
    local p = o.getPosition()
		local t = tostring(i)..': '..o.getGUID()..': '..tostring(p)
		log(t)
		s = s .. t .. '\n'
	end
	if s ~= "" then
    Notes.setNotes(s)
  end
end

function getLTB(pcol)
  log("Getting positions of selected objects relative to board")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	--local board = getObjectFromGUID(C.board_guid)
	local board = getObjectFromGUID(C.board_guid)
  local s = ""
  for i,o in ipairs(stuff) do
    log("Processing object #"..tostring(i)..": "..o.getGUID())
    local p = board.positionToLocal(o.getPosition())
    -- local r = Vector(0,180,0)
		-- City house positions
		-- local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},r={'..r.x..','..r.y..','..r.z..'}},'
		local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},r={0,180,0}},'
    log(t)
    s = s .. t .. '\n'
  end
  if s ~= "" then
    Notes.setNotes(s)
  end
end

function getLTPB(pcol)
	log("Getting positions of selected objects relative to player board")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	local board = getObjectFromGUID(C.player_boards[pcol].g)
  local s = ""
  for i,o in ipairs(stuff) do
    log("Processing object #"..tostring(i)..": "..o.getGUID())
    local p = board.positionToLocal(o.getPosition())
		local r = board.getRotation()
		local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},},'
    log(t)
    s = s .. t .. '\n'
  end
  if s ~= "" then
    Notes.setNotes(s)
  end

end

function getOffsets()
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers.Agra
	center.y = 0
	log(center)
	local s = ""
	for i,loc in ipairs(C.ltb) do
		local pos = Vector(loc.p)
		pos.y = 0
		local o = center - pos
		-- local r = Vector(loc.r)
		-- local t = '{o={'..o.x..','..o.y..','..o.z..'},r={'..r.x..','..r.y..','..r.z..'}},'
		local t = '{o={'..o.x..','..o.y..','..o.z..'},r={0,180,0}}'
		log(t)
		s = s .. t .. '\n'
	end
	if s ~= "" then
		Notes.setNotes(s)
	end
end

require("tts-lib/utils")
require("tts-maharaja/Constants")
require("tts-maharaja/Network")
