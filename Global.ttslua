--[[==========================================================================================
TTS mod for Maharaja
	by David Veach, 2023

NOTE: this mod is private and for my personal use only.  No permission has been given to publish publically.

Credits
	Maharaja: The game of palace building in india
	Authors: Wolfgang Kramer and Michael Kiesling
	Artist Franz Vohwinkel
	Year released: 2004
	Publisher: 	Phalanx Games B.V.
							Phalanx Games Deutschland
							Asmodee
							KDS Distribuzione (Italy)
							Mayfair Games

BGG url:  https://boardgamegeek.com/boardgame/9440/maharaja-game-palace-building-india

*** MVP FEATURES ***

	--TODO: TEST lots of stuff.  Like doubling track action, doubling character trade action.  etc.

*** OTHER STUFF ***

	--TODO: implement route sorting on opponent selection (button in header of dialog)

	--TODO: (maybe) during action selection, don't show dial pointers until an action is clicked ??  (minor)
	--TODO: (maybe) unlock only last house in pool (and last palace).  Check after each drop, unlock another if more actions.
	--TODO: (maybe) lock things (pool, placed houses etc.) after action if no more actions of that type.
	--TODO: (maybe?) convert playerboards to tile with jpeg vs token with png.  Takes too long to load.

	--Code cleanup, refactoring
	--TODO: Get rid of turn_action.index. Rather use turn_action table entry reference in pending_action? Cleaner but is this ok for JSON save encode?
	--TODO: Get rid of getPlacedObjectSnap().  Just reference player (obj color) placed object (object type) table directly by obj guid.
					Objects know their color and type.  Use that.  Architect snap also easily referenced in player data for it's color.

*** BUGs ***

	****BUG: (saw more than once but repro not yet idenfied) duplicates in player.placed_palaces table.
	****BUG: phantom palace in city node.  Can't repro yet.


*** Stuff that is done ***

	**BUG: FIXED TESTING Sadhu bonus not reflected in City Scoring Status until player hits done.  Is counted in city scoring after done.
	****BUG: FIXED TESTING when moving a house from a village (and maybe city?) need to remove table entry, don't set it to nil.  Breaks ipairs.
	****BUG: FIXED TESTING NASTY gaps in track are not handled correctly when moving governor involves the gap.
	***BUG: FIXED TESTING only enable button on track rows with a governor in it.  Empty rows (gaps) shold not have buttons.
	***BUG: FIXED TESTING Double track action does not work, need to keep buttons enabled if more track actions in turn_actions
	**BUG: FIXED TESTING help text still shows action selection when player turns stage starts
	*****BUG: FIXED TESTING Free action needs to either a move or a build.  Currently just a move.
	**BUG FIXED TESTING character bank is not unlocked when player has to choose a replacement.
	***BUG character cards are going to the wrong spot in bank on exchange.
	****BUG: FIXED TESTING don't allow any other action while route picker dialog is showing.  Disable everything until route selected (or canceled)
	****BUG: FIXED TESTING when moving house from a village (and maybe city?) need to empty the node in pending action.  Restore it in undo.
	****BUG: FIXED TESTING handle dropping things in same city/village where already placed (house, palace, architect).  Don't trigger another move/build action.
	****BUG: FIXED TESTING city snap back uses board rotation, need to add saved rotation in player placed houses and use it on snapBack for house drop
	****BUG: FIXED TESTING Handle more than 6 houses of a color in a city
	**BUG FIXED TESTING if 8 cities in route, last one is cut off in dialog button text
	***BUG FIXED TESTING palaces are not locked after placing
	**BUG; FIXED TESTING when building house in city, don't pick city/village option if city only is avaialbe in unused turn actions (see TODO on asking player)
	***BUG: FIXED TESTING character free action not being removed from turn_actions on exchanging away Builder character
	***BUG: FIXED TESTING replacing character does not immediately update benefit.  eg: replacing with Sadhus (#3) in a swap just before scoring
	**BUG: FIXED TESTING Need to lock everything, disable track buttons, etc. when extra action is clicked.  Unlock when done to match turn actions.
	--TODO: DONE TESTING refactored character bonus assignment.  messy.  check for bugs.
	--TODO: DONE TESTING add verbose game prints for undo actions
	--TODO: DONE TESTING final scoring dialog
	--TODO: DONE TESTING allow player to choose if free action should be used vs paid action. Idea: make it clickable to signify preference?
	--TODO: DONE TESTING add player prefs dialog.
	--TODO: DONE TEST end game

==========================================================================================]]

env = {}
env.test = {}
env.test.trace = false
env.test.debug = false
env.test.in_dev = false
env.test.force_fresh_save = false
env.test.save_positions = true
env.test.auto_switch = true
-- env.test.players = {"Blue","Red","Yellow","Purple","Green",}
-- env.test.players = {"Yellow","Red","Blue","Purple",}
-- env.test.players = {"Yellow","Purple",}
-- env.test.players = {"Green","Blue",}
env.test.players = {"Green","Red","Blue"}

env.game = {}
env.game.fill_delay = 1
env.game.use_help = true
env.game.auto_select_zero_route = true
env.game.auto_select_unique_cheapest_route = false  --TODO: not working yet to enable

GD = {}

--[[/////////////// Load Save /////////////////]]

--[[ *****************************
TTS Game Load
********************************]]
function onLoad(saved_data)
	-- if true then return end --for testing global UI stuff
	if env.test.force_fresh_save then saved_data = "" end
	--Initialize stuff
	if not(env.test.in_dev) then
		getObjectFromGUID(C.board_guid).interactable = false
		getObjectFromGUID(C.palace_object_guid).setInvisibleTo(Color.list)
		getObjectFromGUID(C.house_object_guid).setInvisibleTo(Color.list)
	end
	UI.setAttribute("penalty_dialog_pnl","visibility","Pink")
	UI.setAttribute("penalty_dialog_pnl","active","true")
	UI.setAttribute("replace_done_pnl","visibility","Pink")
	UI.setAttribute("replace_undo_pnl","visibility","Pink")
	UI.setAttribute("replace_character_pnl","active",false)
	--Reload saved data or if fresh load initialize everything
	if (saved_data ~= "") then
    log("onLoad(): load with saved data")
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
		if GD.game.stage ~= "setup" then  --HACK: don't show dialog if not restoring an active game.
			UI.setAttribute("restore_dialog_pnl", "active", true)
		end
    Wait.frames(function() restoreGameState() end, 10)
  else
		log("onLoad(): load with fresh state")
		GD.state = {}
		GD.state.global_UI = {}
		GD.state.board_UI = {}
		GD.game = {}
		GD.game.stage = "setup"
		GD.game.round = 1
		GD.game.city_scores = {}
		GD.game.maharaja_node = 8
		for name,_ in pairs(C.cities) do
			GD.game.city_scores[name] = {}
		end
		GD.env = {}
		GD.env.max_route_rows = 20
		GD.env.use_auction = false
		UI_setAttribute("opt_use_auction","isOn",GD.env.use_auction)
		GD.env.verbose = true
		UI_setAttribute("opt_verbose","isOn",GD.env.verbose)
		for _,g in pairs(C.player_pawns) do
			getObjectFromGUID(g).setLock(true)
		end
		GD.game.status_visibility = false
		UI_setAttribute("status_info","visibility",GD.game.status_visibility)
		UI_setAttribute("startPanel","active",true)
	end
end

--[[ *****************************
HACK: reload an object's XML UI
********************************]]
function reloadUI(guid)
	if env.test.trace then log("reloadUI() guid: "..tostring(guid)) end
	if guid then
		local obj = getObjectFromGUID(guid)
		if obj ~= nil then
			if env.test.debug then log("reloading object UI for "..obj.getName()..", guid "..tostring(guid)) end
			obj.UI.setXml(obj.UI.getXml())
		else
			log("***WARN: reloadUI() unable to get object for "..tostring(guid))  --DEBUG LOGGING
		end
	else
		UI.setXml(UI.getXml())
	end
end

--[[ *****************************
Save game state
********************************]]
function onSave()
	local saved_data = ""
  if not(env.test.force_fresh_save) then
		saved_data = JSON.encode(GD)
  end
  return saved_data
end

--[[ *****************************
Restore the game state.
TODO: implement
********************************]]
function restoreGameState()
	if env.test.trace then log("restoreGameState()") end
	if GD.game.stage ~= "setup" then
		setupGlobalUI()
		updateGovernorTrack()
		for pcol,player in pairs(GD.game.players) do
			updateDialUI(pcol)
		end
		setGovernorButtons(GD.state.governor_buttons)
	end
	Wait.time(function()
		--[[ replay saved global UI setAttributes --]]
		if env.test.debug then log("replay saved global UI setAttributes") end
	  for key,value in pairs(GD.state.global_UI) do
	    local id = Split(key, '|')[1]
	    local field = Split(key, '|')[2]
	    local success = UI.setAttribute(id, field, value)
	    if not(success) and env.test.debug then
	      log("ERROR: restoreGameState(): Unable to setAttribute for global UI "..field.." on id "..id.." to "..tostring(value))
	    end
	  end
		--[[ replay saved board UI setAttributes --]]
	  if env.test.debug then log("replay saved board UI setAttributes") end
	  local board = getObjectFromGUID(C.board_guid)
	  for key,value in pairs(GD.state.board_UI) do
	    local id = Split(key, '|')[1]
	    local field = Split(key, '|')[2]
			local success = board.UI.setAttribute(id, field, value)
	    if not(success) and env.test.debug then
	      log("ERROR: restoreGameState(): Unable to setAttribute for board UI "..field.." on id "..id.." to "..tostring(value))
	    end
	  end
		UI.setAttribute("status_info","visibility",GD.game.status_visibility)
		UI.setAttribute("restore_dialog_pnl","active",false)
	end, 1)
end

--[[ ******************************
Wrapper function for global UI attributes.
Saves attribute update to be replayed on restore.
TODO: convert calls to use
*********************************]]
function UI_setAttribute(id, field, value)
  if env.test.trace2 then log("UI_setAttribute()") end
  assert(type(id) == "string", "UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "UI_setAttribute(): field must be a string")
  assert(value or value==false, "UI_setAttribute(): value missing")
  GD.state.global_UI[id.."|"..field] = value
  UI.setAttribute(id, field, value)
end

--[[ ******************************
Wrapper function for saving board UI attributes.
Saves attribute update to be replayed on restore.
TODO: convert calls to use
*********************************]]
function board_UI_setAttribute(id, field, value)
	if env.test.trace2 then log("board_UI_setAttribute()") end
	assert(type(id) == "string", "board_UI_setAttribute(): id must be a string")
	assert(type(field) == "string", "board_UI_setAttribute(): field must be a string")
	assert(value or value==false, "board_UI_setAttribute(): value missing")
	GD.state.board_UI[id.."|"..field] = value
	return getObjectFromGUID(C.board_guid).UI.setAttribute(id, field, value)
end

--[[/////////////// Event handlers /////////////////]]

--[[ *****************************
Setup: Handler for start game options
********************************]]
function startOptionsBtn(player, value, id)
	if env.test.trace then log("startGameBtn() "..player.color..", "..id..": "..tostring(value)) end
	local setting = (value == 'True')
	UI_setAttribute(id, "isOn", setting)
	if id == "opt_use_auction" then
		broadcastToAll("Sorry, not yet imlemented")		--TODO: remove this when imlpemented
		UI_setAttribute(id, "isOn", false)
		return
		-- GD.env.use_auction = setting
	elseif id == "opt_verbose" then
		GD.env.verbose = setting
		UI_setAttribute(id, "isOn", value)
	else
		log("*** ERROR: startOptionsBtn() unknown id "..tostring(id))
	end
end

--[[ *****************************
Setup: A player clicked start game.
********************************]]
function startGameBtn(player, btn, id)
	if env.test.trace then log("startGameBtn() "..player.color) end
	if not(env.test.players) and #getSeatedPlayers() < 2 then
		broadcastToAll("At least 2 players needed to play")
		return
	end
	UI_setAttribute("startPanel","active",false)
	Wait.frames(function() startGame() end, 10)
end

--[[ *****************************
Player clicked a row on the Governor track
********************************]]
function governorClick(player, btn, id)
	if env.test.trace then log("governorClick() "..player.color..", id: "..tostring(id)) end
	if GD.game.select_route_dialog then log("Ignoring: route selection dialog open"); return end
	if player.color ~= GD.game.current_player_color then return end
	if GD.game.players[player.color].governor_clicked then return end --guard double clicks
	GD.game.players[player.color].governor_clicked = true
	local track = GD.game.governor_track
	-- build a pending action and store current order in undo
	local row_clicked = tonumber(Split(id,'_')[2])
	local pending_action = {
		key = "track",
		player_color = pcol,	--TODO: need this?
		row_clicked = row_clicked,  --TODO: need this?
		undo = {
			restore_list = simpleDeepCopy(track),
		}
	}
	local turn_action = getAvailableAction(player.color, "track")
	if not(turn_action) then
		log("***ERROR: governorClick() could not locate a turn action") --DEBUG
	else
		pending_action.action_index = turn_action.index
		turn_action.status = "Done"
		table.insert(GD.game.players[player.color].pending_actions, pending_action)
		--build a model of the entire board track (including empty spaces)
		local board_track = {}
		local gov = 1
		for i=1,17 do
			if gov <= 7 and i == track[gov].track_row then
				table.insert(board_track, simpleDeepCopy(track[gov]))
				gov = gov + 1
			else
				table.insert(board_track, {"empty"})
			end
		end
		--move clicked governor down two spots in board track and shift spots inbetween up
		local tmp = simpleDeepCopy(board_track[row_clicked])
		local target_row = row_clicked - 2
		if target_row < 1 then target_row = 1 end  --not paast the end
		for i = row_clicked, target_row+1, -1 do
			board_track[i] = simpleDeepCopy(board_track[i-1])
		end
		board_track[target_row] = tmp
		--rebuild the governor_track data table from board track
		local temp = {}
		local index = 0
		local ui_row = 7
		for i=1,17 do
			if board_track[i].city then
				index = index + 1
				board_track[i].track_row = i
				board_track[i].UI_row = ui_row
				table.insert(temp, board_track[i])
				ui_row = ui_row - 1
			end
			if index == 7 then break end
		end
		GD.game.governor_track = temp
		--update the displays
		updateGovernorTrack()
		updateStatusPanel()
		updateDialUI(player.color)
		getObjectFromGUID(C.player_boards[player.color]).call("setState",{undo=true})
		if not(getAvailableAction(player.color, "track")) then
			setGovernorButtons(false)
		else
			--player has another track action, re-enable buttons and disable debounce
			setGovernorButtons(true)
			Wait.frames(function()
				GD.game.players[player.color].governor_clicked = false
			end, 60)
		end
	end
end

--[[ *****************************
Handler for button clicks on player board
********************************]]
function playerBoardClick(player, btn, id)
	if env.test.trace then log("playerBoardClick(): "..player.color..", id = "..id) end
	local board_color = Split(id,'_')[1]
	if player.color ~= board_color then return end
	local action = Split(id,'_')[2]
	if action == "done" then
		playerDone(player.color)
	elseif action == "undo" then
		playerUndo(player.color)
	elseif action == "extraAction" then
		extraAction(player.color)
	else
		log("*** ERROR: playerBoardClick(): unknown action id")
		return
	end
end

--[[ *****************************
Toggle the city status display for the player who clicked.
********************************]]
function statusClick(player, btn, id)
	if env.test.trace then log("statusClick() id: "..tostring(id)) end
	-- if env.test.debug then log(GD.game.status_visibility) end
	local players = Split(GD.game.status_visibility,'|')
	local index = indexOf(players, player.color)
	if index > 0 then
		table.remove(players,index)
	else
		table.insert(players,player.color)
	end
	GD.game.status_visibility = ""
	for _,pcol in ipairs(players) do
		if GD.game.status_visibility == "" then
			GD.game.status_visibility = pcol
		else
			GD.game.status_visibility = GD.game.status_visibility .."|"..pcol
		end
	end
	-- if env.test.debug then log("Setting vis to "..GD.game.status_visibility) end
	UI_setAttribute("status_info","visibility",GD.game.status_visibility)
end

--[[ *****************************
Handler for clicks in the player preferences dialog.
Overloaded to handle both button clicks and toggle settings.
********************************]]
function prefsOptionClick(player, value, id)
	if env.test.trace then log("prefsOptionClick() "..player.color..", value: "..tostring(value)..", id: "..tostring(id)) end
	local plr = GD.game.players[player.color]
	local action = Split(id,'_')[2]
	local setting = (value == 'True')
	log("action: "..tostring(action))
	if action == "togglePrefs" then
		plr.prefs.show = not(plr.prefs.show)
		if plr.prefs.show then
			UI_setAttribute(player.color.."_prefs_panel","visibility", "Pink|"..player.color)
		else
			UI_setAttribute(player.color.."_prefs_panel","visibility", "Pink")
		end
	elseif action == "close" then
		UI_setAttribute(player.color.."_prefs_panel","visibility", "Pink")
		plr.prefs.show = false
	elseif action == "zeroCostRoute" then
		UI_setAttribute(id, "isOn", setting)
		plr.prefs.auto_select_zero_route = setting
	elseif action == "uniqeLeastCostRoute" then
		UI_setAttribute(id, "isOn", setting)
		plr.prefs.auto_select_unique_cheapest_route = setting
	else
		log("***ERROR: prefsOptionClick() Unknown action")
	end
end

--[[ *****************************
Handle dropping things on the main board.
House and palace drops off board are snapped back.
TODO: disable DEVELOPMENT stuff
********************************]]
function onObjectDrop(pcol, obj)
	if env.test.trace then log("onObjectDrop(): pcol "..pcol..", obj "..obj.getGUID()) end
	--/// DEV ///
	if env.test.save_positions then
		str = "Global: "
		str = str .. tostring(obj.getPosition())
		str = str .. "\nBoard: "
		str = str .. tostring(getObjectFromGUID(C.board_guid).positionToLocal(obj.getPosition()))
		Notes.setNotes(str)
	end
	--/// END DEV ///
	if GD.game.stage == "setup" then return end
	local type = obj.memo
	obj.setVelocity(Vector(0,0,0)) --in case player "throws it"
	if type == "character" then
		characterDrop(pcol, obj)
	elseif type == "palace" or type == "house" or type == "architect" then
		local snapback = false
		local pos = obj.getPosition()
		local board = getObjectFromGUID(C.board_guid)
		local center = board.getBounds()["center"]
	  local size = board.getBounds()["size"]
		if pcol ~= GD.game.current_player_color then snapback = true
		elseif obj.getName() ~= pcol then snapback = true
	  elseif pos.x > center.x + (size.x/2) then snapback = true
	  elseif pos.x < center.x - (size.x/2) then snapback = true
	  elseif pos.z > center.z + (size.z/2) then snapback = true
	  elseif pos.z < center.z - (size.z/2) then snapback = true
		end
		if GD.game.select_route_dialog then log("Ignoring: route selection dialog open"); snapback = true end
		if snapback then
			if type == "architect" then
				local snap = getPlacedObjectSnap(obj.getGUID())
				assert(snap, "***ERROR: onObjectDrop() no snap position found")
				obj.setPosition(snap)
			else
				local snap = getPlayerBoardLocation(obj)
				if snap then
					obj.setPosition(snap)
					obj.setRotation(getObjectFromGUID(C.player_boards[obj.getName()]).getRotation())
				else
					if type == "house" then
						local pos,rot = getPlacedObjectSnap(obj.getGUID())
						assert(pos, "***ERROR: onObjectDrop() no snap position found for house")
						if not(rot) then rot = board.getRotation() end
						obj.setRotation(rot)
						obj.setPosition(pos)
					else
						snap = getPlacedObjectSnap(obj.getGUID())
						assert(snap, "***ERROR: onObjectDrop() no snap position found")
						obj.setPosition(snap)
						obj.setRotation(board.getRotation())
					end
				end
			end
			return
		end
		if type == "house" then
			houseDrop(pcol, obj)
		elseif type == "palace" then
			palaceDrop(pcol, obj)
		else
			architectDrop(pcol, obj)
		end
	else
		log("*** WARN: onObjectDrop() unknown object "..obj.getGUID())
		return
	end
end

--[[ ***************************
Handle click on the extra action token.
Enable extra action selection on the player dial.
********************************]]
function extraActionToken(obj, pcol, rclick)
	if env.test.trace then log("extraActionToken() "..obj.getName()..", "..pcol..", "..tostring(rclick)) end
	if GD.game.select_route_dialog then log("Ignoring: route selection dialog open"); return end
	if pcol ~= obj.getName() then return end
	--enable extra action selection on player dial and disable Done/Undo buttons
	local player = GD.game.players[pcol]
	player.extra_actions = player.extra_actions - 1
	obj.call("setState",{done=false,undo=false,extra_actions=player.extra_actions,extra_button=false})
	local dial = getObjectFromGUID(C.action_dials[pcol])
	dial.call("enableExtraActionButtons")
	updateLockStates(pcol, true)
	getObjectFromGUID(C.player_pawns[pcol]).setLock(true)
end

--[[ *****************************
End turn with required actions penalty dialog.
If 'Cancel', return to turn actions.
if 'OK' then set failed status on remaining actions and end turn.
********************************]]
function penaltyDialogBtn(player, btn, id)
	log("penaltyDialogBtn() "..player.color..", "..tostring(id))
	if player.color ~= GD.game.current_player_color then return end
	local command = Split(id,'_')[3]
	if env.test.debug then log("action is "..tostring(command)) end
	if command == "ok" then
		for _,action in ipairs(GD.game.players[player.color].turn_actions) do
			if action.status ~= "Done" then action.status = "Failed" end
		end
		updateDialUI(player.color)
		playerDone(player.color)
	elseif command == "cancel" then
		--noop
	else
		log("***ERROR: unknown command")
		return
	end
	UI_setAttribute("penalty_dialog_pnl","visibility","Pink")
end

--[[ *****************************
Handler for modify button click (back of dial).
Flip dial face up and set state back to action selection.
Enable done button on player board.
********************************]]
function dialModifyClick(player, btn, id)
	if env.test.trace then log("dialModifyClick(): id="..tostring(id)) end
	GD.game.players[player.color].actions_set = false
	local dial = getObjectFromGUID(C.action_dials[player.color])
	dial.call("hideMe")
	dial.call("enableDialButtons")
	if dial.is_face_down then dial.call("flipMe") end
	getObjectFromGUID(C.player_boards[player.color]).call("setState",{done=true,undo=false})
end

--[[ *****************************
Handle player click on replace character dialog
If 'Done', finalize the selection in playerDone().
if 'Undo' undo the selection in playerUndo().
********************************]]
function replaceCharDialogBtn(player, btn, id)
	if env.test.trace then log("replaceCharDialogBtn(): player "..player.color..", id="..tostring(id)) end
	local command = Split(id,'_')[3]
	log("command = "..tostring(command))
	local plr = GD.game.players[player.color]
	local pending_action,pending_index
	for i,a in ipairs(plr.pending_actions) do
		if a.key == "replace" then
			pending_action = a
			pending_index = i
			break
		end
	end
	if not(pending_action) then
		log("***ERROR: replaceCharDialogBtn() no pending action")  --DEBUG
		return
	end
	if command == "done" then
		charactersLock("all", true)
		plr.character_id = pending_action.character_id
		setCharacterBonus(player.color, false)
		plr.replace_character = false
		table.remove(plr.pending_actions,pending_index)
		updateDialUI(player.color)
		UI_setAttribute("replace_character_pnl","active",false)
		UI_setAttribute("replace_done_pnl","visibility","Pink")
		UI_setAttribute("replace_undo_pnl","visibility","Pink")
		--unlock mutex, check for round end or advance to next player in round
		GD.game.wait_for_character_replace = false
		if GD.env.verbose then printToAll(player.color.." replaces stolen character") end
		updateTurnOrder()
		if #GD.game.remaining_round_players == 0 then
			finishCurrentRound()
		else
			startPlayerTurn(setNextPlayer())
		end
	elseif command == "undo" then
		-- playerUndo(player.color)
		local obj = getObjectFromGUID(pending_action.undo.guid)
		obj.setPosition(pending_action.undo.snapback.pos)
		obj.setRotation(pending_action.undo.snapback.rot)
		obj.setLock(false)
		plr.replace_character = true
		table.remove(plr.pending_actions,pending_index)
		UI_setAttribute("replace_undo_pnl","visibility","Pink")
	else
		log("*** ERROR replaceCharDialogBtn() unknown command")
	end
end

--[[ ********** TODO: sort by opp ***********
Handle player click on route selector dialog
Click on a route selects that route for payout for architect move.
TODO: click on opponent in header sorts routes by cost to that opponent.
********************************]]
function routeSelectClick(player, btn, id)
	if env.test.trace then log("statusClick() "..player.color..", id: "..tostring(id)) end
	if player.color ~= GD.game.current_player_color then return end
	local plr = GD.game.players[player.color]
	if id == "routes_dialog_cancel" then
		--cancel pending action (basically undo the pending action and clear it)
		assert(#plr.pending_actions > 0, "***ERROR: No "..player.color.." pending actions during route selection")
		local pending = plr.pending_actions[#plr.pending_actions]
		assert(pending.key == "architect","***ERROR: Incorrect "..player.color.." pending action key during route selection")
		log("pending action:");log(pending)
		local return_pos = pending.undo.snapback.pos
		local old_node = pending.undo.snapback.old_node
		local pawn = getObjectFromGUID(pending.guid)
		pawn.setLock(false)
		pawn.setPosition(return_pos)
		plr.architect_location.current_node = old_node
		plr.architect_location.snap_pos = return_pos
		updateCityScores()
		table.remove(plr.pending_actions, #plr.pending_actions)
		if #plr.pending_actions > 0 then
			getObjectFromGUID(C.player_boards[player.color]).call("setState",{done=true, undo=true})
		else
			getObjectFromGUID(C.player_boards[player.color]).call("setState",{done=true, undo=false})
		end
	elseif Split(id,'_')[2] == "hdr" then

		log("TODO: sort routes by opp")
		return

	elseif Split(id,'_')[1] == "route" then
		local index = tonumber(Split(id,'_')[2])
		local route = plr.route_table[index]
		assert(#plr.pending_actions > 0, "***ERROR: No "..player.color.." pending actions during route selection")
		local pending = plr.pending_actions[#plr.pending_actions]
		assert(pending.key == "architect","***ERROR: Incorrect "..player.color.." pending action key during route selection")
		if route.total_cost > plr.gold then
			--shouldn't happen if routes are being pruned but handle just in case
			if GD.env.verbose then broadcastToColor("Not enough gold", player.color) end
			return
		end
		pending.route_cost = route.total_cost
		if route.total_cost > 0 then
			plr.gold = plr.gold - route.total_cost
			for color,cost in pairs(route.costs) do
				local opp = GD.game.players[color]
				opp.gold = opp.gold + cost
				getObjectFromGUID(C.player_boards[color]).call("setState",{gold_coins=opp.gold})
				if GD.env.verbose then printToAll(player.color.." pays "..color.." "..tostring(cost).." gold") end
			end
			pending.costs = simpleDeepCopy(route.costs)
		end
		getObjectFromGUID(C.player_boards[player.color]).call("setState",{gold_coins=plr.gold})
		getObjectFromGUID(C.player_boards[player.color]).call("setState",{done=true, undo=true})
		if GD.env.verbose then printToAll(player.color.." moves Architect for "..tostring(route.total_cost).." gold") end
		getObjectFromGUID(C.player_boards[player.color]).call("setState",{done=true, undo=true})
	end
	UI_setAttribute("routes_dialog_pnl","active",false)
	GD.game.select_route_dialog = false
end

function freeActionBtnClick(player, btn, id)
	if env.test.trace then log("freeActionBtnClick(): id="..tostring(id)) end
	if player.color ~= GD.game.current_player_color then return end
	GD.game.players[player.color].prefer_free_action = not(GD.game.players[player.color].prefer_free_action)
	updateDialUI(player.color)
end

--[[/////////////// Game Setup /////////////////////]]

--[[ *****************************
Randomly assign the 7 Governors to starting positions on the track.
********************************]]
function setupGovernorTrack()
	if env.test.trace then log("setupGovernorTrack()") end
	local temp = simpleDeepCopy(C.governors)
	local row = 0
	local ref = 7
	GD.game.governor_track = {}
	while #temp > 0 do
		local i = math.random(#temp)
		row = row + 1
		if row > 7 then
			log("*** ERROR: setupGovernorTrack() exceeded safety stop, too many rows")
			return
		end --safety
		table.insert(GD.game.governor_track,{city=temp[i].city,node=temp[i].node,track_row=row, UI_row=ref, scoring=false})
		table.remove(temp,i)
		ref = ref - 1
	end
	updateGovernorTrack(false)
end

--[[ *****************************
Update the board UI with Governor images on the track.
Assumes governor track data has been initialized.
********************************]]
function updateGovernorTrack(update_status)
	if env.test.trace then log("updateGovernorTrack()") end
	local update_status = update_status or true
	for row=1,17 do
		if row > 7 then
			board_UI_setAttribute("gov_"..tostring(row),"image","Gray-"..(row-7))
		else
			board_UI_setAttribute("gov_"..tostring(row),"image","Gray")
		end
	end
	for i,entry in ipairs(GD.game.governor_track) do
		board_UI_setAttribute("gov_"..tostring(entry.track_row),"image",entry.city)
	end
	if update_status then updateStatusPanel() end
end

--[[ *****************************
Setup: initialize the game
********************************]]
function startGame()
	if env.test.trace then log("startGame()") end
	-- GD.game.stage = "setup"
	GD.game.auction_characters = false --TODO: get this from start dialog
	setupGovernorTrack()
	setupNetwork()
	if not(setupPlayers()) then return end
	setupGlobalUI()
	UI_setAttribute("statusPanel","active","true")
	--for testing, set solo player to start player color
	local players = Player.getPlayers()
	if #players == 1 then
		if env.test.players and env.test.auto_switch then
			Player[players[1].color].changeColor(GD.game.current_player_color)
		end
	end
end

--[[ *****************************
Setup: setup the status UI for number of players
Assumes GD.game.player_order is established.
********************************]]
function setupGlobalUI()
	if env.test.trace then log("setupGlobalUI()") end
	local letters = {Yellow="Y",Red="R",Green="G",Blue="B",Purple="P",}
	local xml=UI.getXmlTable()

	--[[ Setup the City Scoring Status dialog]]
	local status_panel = getXmlElement("statusPanel",xml)
	local status_table = getXmlElement("status_table",status_panel)
	local columnWidths="120 40 36"
	local panel_width = 120 + 40 + 36
	--setup the header row
	local index = 3
	local player_columns = {}
	local header_row = getXmlElement("status_header_row",status_table)
	local header_cell = getXmlElement("status_h_template",header_row)
	for pcol,initial in pairs(letters) do
		if contains(GD.game.player_order,pcol) then
			table.insert(player_columns, pcol)
			local cell = simpleDeepCopy(header_cell)
			cell.attributes.id = "status_h_"..pcol
			local text = cell.children[1]
			text.attributes.id = "status_h_txt_"..pcol
			text.attributes.color = pcol
			text.attributes.text = initial
			header_row.children[index] = cell
			columnWidths = columnWidths.." 36"
			panel_width = panel_width + 36
			index = index + 1
		end
	end
	--setup the player preferences dialogs
	local status = getXmlElement("statusPanel",xml)
	local plr_prefs = simpleDeepCopy(status.children[2])
	table.remove(status.children[2])
	for _,pcol in ipairs(GD.game.player_order) do
		local prefs = simpleDeepCopy(plr_prefs)
		prefs.attributes.id = pcol.."_prefs_panel"
		prefs.attributes.visibility = "Pink"
		prefs.attributes.active = true
		local e = getXmlElement("pref_zeroCostRoute_opt",prefs)
		e.attributes.id = pcol.."_zeroCostRoute_opt"
		e = getXmlElement("pref_uniqeLeastCostRoute_opt",prefs)
		e.attributes.id = pcol.."_uniqeLeastCostRoute_opt"
		table.insert(status.children, prefs)
	end
	--setup the city rows
	local city_row = getXmlElement("status_row_template",status_table)
	local temp_row = simpleDeepCopy(city_row)
	local player_cell = getXmlElement("status_p_template",temp_row)
	status_table.children[2] = nil --this is ok, table.insert below will handle the nil entry
	for i,gov in ipairs(GD.game.governor_track) do
		local row = simpleDeepCopy(temp_row)
		local ref = gov.UI_row
		row.attributes.id = "status_row_"..tostring(ref)
		local text = getXmlElement("status_city_name_template",row)
		text.attributes.id = "status_city_name_"..tostring(ref)
		text.attributes.text = gov.city
		local image = getXmlElement("status_city_image_template",row)
		image.attributes.id = "status_city_image_"..tostring(ref)
		image.attributes.image = gov.city
		for p,pcol in ipairs(player_columns) do
			local pcell = simpleDeepCopy(player_cell)
			local ptext = getXmlElement("status_p_text_template",pcell)
			ptext.attributes.id = "status_p_text_"..tostring(ref).."_"..pcol
			ptext.attributes.text = ""
			row.children[2+p] = pcell
		end
		table.insert(status_table.children,2,row) --always next after header, pushing rest downward
	end
	if env.test.debug then
		for i,c in ipairs(status_table.children) do
			if i > 1 then
				log(tostring(i)..": id:"..c.attributes.id)
				log(c.children[2].children[1].attributes)
			end
		end
	end
	status_panel.attributes.width = tostring(panel_width)
	status_table.attributes.columnWidths = columnWidths
	--[[Setup the Route Picker dialog]]
	local routes_dialog_pnl = getXmlElement("routes_dialog_pnl",xml)
	local w = 120 + 40 + 36 + (#GD.game.player_order * 36) - 6
	routes_dialog_pnl.attributes.width = tostring(w)
	local routes_main_tbl = getXmlElement("routes_main_tbl", routes_dialog_pnl)
	local s = "120 40 36"
	for i=1,#GD.game.player_order do s = s .. " 36" end
	routes_main_tbl.attributes.columnWidths = s
	--setup header row
	local header_row = getXmlElement("routes_header_row", routes_main_tbl)
	local header_cell = simpleDeepCopy(getXmlElement("routes_h_template", header_row))
	table.remove(header_row.children, 3)
	local player_columns = {}
	local index = 3
	for pcol,initial in pairs(letters) do
		if contains(GD.game.player_order,pcol) then
			table.insert(player_columns, pcol)
			local cell = simpleDeepCopy(header_cell)
			cell.attributes.id = "routes_h_"..pcol
			local btn = cell.children[1]
			btn.attributes.id = "route_hdr_"..pcol.."_btn"
			local txt = btn.children[1]
			txt.attributes.color = pcol
			txt.attributes.text = initial
			table.insert(header_row.children, index, cell)
			index = index + 1
		end
	end
	--setup route data rows
	local route_tbl = getXmlElement("route_tbl", routes_main_tbl)
	local row_template = simpleDeepCopy(getXmlElement("route_n_row_template",route_tbl))
	table.remove(route_tbl.children,1)
	for i=1,GD.env.max_route_rows do
		local row = simpleDeepCopy(row_template)
		row.attributes.id = "route_"..tostring(i).."_row"
		row.attributes.active = false
		local btn = getXmlElement("route_n_btn_template", row)
		btn.attributes.id = "route_"..tostring(i).."_btn"
		local txt = getXmlElement("route_n_total_cost_template", row)
		txt.attributes.id = "route_"..tostring(i).."_total_cost"
		txt.attributes.text = "0"
		local total_txt = getXmlElement("route_n_btn_txt_template", row)
		total_txt.attributes.id = "route_"..tostring(i).."_btn_txt"
		total_txt.attributes.text = "Route "..tostring(i)
		local cell_template = simpleDeepCopy(getXmlElement("route_n_pcol_cost_template", row))
		table.remove(row.children, 3)
		for p,pcol in ipairs(player_columns) do
			local cell = simpleDeepCopy(cell_template)
			cell.attributes.id = "route_"..tostring(i).."_"..pcol.."_cost"
			local txt = cell.children[1]
			txt.attributes.id = "route_"..tostring(i).."_"..pcol.."_cost_txt"
			txt.attributes.text = ""
			table.insert(row.children, cell)
		end
		table.insert(route_tbl.children, row)
	end
	UI.setXmlTable(xml)
end

--[[ *****************************
Setup: initialize game for seated players
********************************]]
function setupPlayers()
	if env.test.trace then log("setupPlayers()") end
	local seated = getSeatedPlayers()
	if env.test.players ~= nil then
		seated = simpleDeepCopy(env.test.players)
	end
	GD.game.player_count = #seated
	if GD.game.player_count < 2 then
		broadcastToAll("2 or more players needed")
		return false
	end
	GD.game.player_order = {}
	for _,pcol in ipairs(C.table_colors) do
		if contains(seated,pcol) then table.insert(GD.game.player_order,pcol) end
	end
	GD.game.players = {}
	GD.game.status_visibility = "Pink"
	for _,pcol in ipairs(GD.game.player_order) do
		reloadUI(C.player_boards[pcol])
		GD.game.players[pcol] = simpleDeepCopy(C.player_data)
		local player = GD.game.players[pcol]
		player.architect_location = {
			current_node = 38,
			dest_node = -1,
			snap_pos = getObjectFromGUID(C.player_pawns[pcol]).getPosition(),
		}
		player.gold = 15  --TODO: extra gold if auction character selection order?
		player.extra_actions = 0
		player.turn_actions = {}
		player.pending_actions = {}
		player.actions_set = false
		player.free_action = nil
		player.prefer_free_action = false
		player.pointers = {}
		player.prefs = {}
		player.prefs.show = false
		player.prefs.auto_select_zero_route = env.game.auto_select_zero_route
		player.prefs.auto_select_unique_cheapest_route = env.game.auto_select_unique_cheapest_route
		getObjectFromGUID(C.player_pawns[pcol]).setLock(true)
		--initialize player pool
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		for i=1,12 do
			local pos = player_board.positionToWorld(C.player_board_pool_locations[i])
			table.insert(player.pool, i, {g=nil,p=pos})
		end
		GD.game.status_visibility = GD.game.status_visibility..'|'..pcol
		--initialize the city scores table
		for name,_ in pairs(C.cities) do
			GD.game.city_scores[name][pcol] = 0
		end
	end
	UI_setAttribute("status_info","visibility",GD.game.status_visibility)
	GD.game.current_player = math.random(#GD.game.player_order)
	GD.game.current_player_color = GD.game.player_order[GD.game.current_player]
	broadcastToAll("Starting player will be "..GD.game.current_player_color)
	startLuaCoroutine(Global, "coroFillPlayerBoards")
	return true
end

--[[ *****************************
Setup: fill player boards with palaces and houses,
remove unused player objects and place unused palaces
Run as a coro with pauses between spawning objects.
********************************]]
function coroFillPlayerBoards()
	if env.test.trace then log("coroFillPlayerBoards(): START") end
	--private function to pause (yield) coro for a number of frames
	local pauseMe = function(frames)
		frames = frames or env.game.fill_delay
		local count = 0
		while count < frames do
			count = count + 1
			coroutine.yield(0)
		end
	end
	local house = getObjectFromGUID(C.house_object_guid)
	assert(house, "***ERROR: coroFillPlayerBoards(): no house object")
	local palace = getObjectFromGUID(C.palace_object_guid)
	assert(palace, "***ERROR: coroFillPlayerBoards(): no palace object")
	--remove unused player area objects
	local board = getObjectFromGUID(C.board_guid)
	local rot = board.getRotation()
	copy({palace})
	for _,pcol in ipairs(C.table_colors) do
		if GD.game.players[pcol] == nil then
			getObjectFromGUID(C.player_boards[pcol]).destruct()
			getObjectFromGUID(C.action_dials[pcol]).destruct()
			getObjectFromGUID(C.player_aids[pcol]).destruct()
			getObjectFromGUID(C.player_pawns[pcol]).destruct()
			--place unused player palaces in outer city palaces
			for name,city in pairs(C.cities) do
				local index = #GD.network[city.node].palaces + 1
				local pos = board.positionToWorld(GD.network[city.node].center - C.city_palace_offsets[index])
				local p = {position=pos}
				local obj = paste(p)[1]
				assert(obj, "*** ERROR: coroFillPlayerBoards(): failed to paste object")
				obj.setRotation(rot)
				obj.setColorTint(C.object_color_tints[pcol])
				obj.setName("Unused")
				obj.memo = "palace"
				obj.tooltip = false
				obj.interactable = false
				table.insert(GD.network[city.node].palaces, {g=obj.getGUID(),c=pcol,})
				pauseMe()
				waitLock(obj)
			end
		end
	end
	pauseMe(10)
	--fill seated player boards
	for _,pcol in ipairs(GD.game.player_order) do
		local player = GD.game.players[pcol]
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		assert(player_board, "*** ERROR: coroFillPlayerBoards(): no board object for color "..tostring(pcol))
		player_board.tooltip = false
		local rot = player_board.getRotation()
		copy({palace})
		for i,loc in ipairs(C.player_board_palace_locations) do
			local pos = player_board.positionToWorld(loc)
			local p = {position=pos}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "palace"
			obj.setDescription("Palace")
			table.insert(player.palaces, {g=obj.getGUID(),p=pos})
			pauseMe()
			waitLock(obj)
		end
		copy({house})
		for i,loc in ipairs(C.player_board_quarry_locations) do
			local pos = player_board.positionToWorld(loc)
			local p = {position=pos}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "house"
			obj.setDescription("House")
			table.insert(player.quarry, {g=obj.getGUID(),p=pos})
			pauseMe()
			waitLock(obj)
		end
		for i=5,8 do
			local p = {position=player.pool[i].p}
			local obj = paste(p)[1]
			obj.setRotation(rot)
			obj.setColorTint(C.object_color_tints[pcol])
			obj.setName(pcol)
			obj.memo = "house"
			obj.setDescription("House")
			player.pool[i].g = obj.getGUID()
			pauseMe()
			waitLock(obj)
		end
		local dial = getObjectFromGUID(C.action_dials[pcol])
		assert(dial, "*** ERROR: coroFillPlayerBoards(): no dial object for color "..tostring(pcol))
		dial.tooltip = false
		dial.call("disableDialButtons")
		dial.call("showMe")
	end
	--setup for next game stage
	if GD.game.auction_characters then

		--TODO: setup for auction

	else
		--setup for character card selection
		for _,char in ipairs(C.characters) do
			getObjectFromGUID(char.g).setLock(false)
		end
		GD.game.stage = "select_starting_characters"
		GD.game.characters_selected = 0
		broadcastToAll(GD.game.current_player_color.." player select a character card then continue clockwise around table")
		local p = {dormant = false,done = false,undo = false,}
		p.help_text = "Select a character card then click Done."
		for _,pcol in ipairs(GD.game.player_order) do
			p.active = (pcol == GD.game.current_player_color)
			p.gold_coins = GD.game.players[pcol].gold
			p.extra_actions = GD.game.players[pcol].extra_actions
			local player_board = getObjectFromGUID(C.player_boards[pcol])
			player_board.call("setState",p)
		end
	end
	board_UI_setAttribute("governor_panel", "active", true)
	reloadUI(C.board_guid)
	if env.test.trace then log("coroFillPlayerBoards(): EXIT") end
	return 1
end

--[[ *****************************
Load 6 starting houses into player Quarry after setup
********************************]]
function startingQuarry(pcol)
	if env.test.trace then log("startingQuarry(): "..pcol) end
	local quarry = GD.game.players[pcol].quarry
	local pool = GD.game.players[pcol].pool
	for i=1,6 do
		local index = 16 - i + 1
		local house = getObjectFromGUID(quarry[index].g)
		assert(house,"*** ERROR: startingQuarry() nil quarry house")
		house.setPosition(pool[i].p)
		quarry[index].g = nil
		pool[i].g = house.getGUID()
	end
end

--[[ *****************************
Move 2 houses from quarry
********************************]]
function quarryAction(pcol)
	if env.test.trace then log("startingQuarry(): "..pcol) end
	local player = GD.game.players[pcol]
	local quarry = player.quarry
	local pool = player.pool
	-- local success = false
	local count = 0
	for i=1,2 do
		for p=1,12 do
			if not(pool[p].g) then
				for q=16,1,-1 do
					if quarry[q].g then
						getObjectFromGUID(quarry[q].g).setPosition(pool[p].p)
						pool[p].g = quarry[q].g
						quarry[q].g = nil
						-- success = true			--BUG: this doesn't fail if only one is able to be moved.  FIX: Count moved and check == 2 insted
						count = count + 1
						break --out of quarry loop
					end
				end
				break --out of pool loop
			end
		end
	end
	-- return success
	return count == 2
end

--[[ *****************************
Finalize a starting character select action
Player has clicked "Done"
********************************]]
function setStartingCharacter(action)
	if env.test.trace then log("setStartingCharacter()") end
	if GD.game.stage ~= "select_starting_characters" then
		log(("*** ERROR: setStartingCharacter() invalid game stage")) --shouldn't happen
		return
	end
	local pcol = action.player_color
	GD.game.players[pcol].character_id = action.character_id
	GD.game.characters_selected = GD.game.characters_selected + 1
	if GD.game.characters_selected == GD.game.player_count then
		--All players selected a character, now setup game for initial house placement
		for id,char in ipairs(C.characters) do
			getObjectFromGUID(char.g).setLock(true)
		end
		updateTurnOrder()
		setNextPlayer(FIRST)
		GD.game.stage = "initial_placement"
		broadcastToAll("Begin initial house placement")
		local p ={done=false,undo=false}
		p.help_text = "Place one starting house from Build Pool.\nOnly place on Villages."
		for pcol,pdata in pairs(GD.game.players) do
			for _,e in ipairs(pdata.pool) do
				if e.g then getObjectFromGUID(e.g).setLock(false) end
			end
			GD.game.players[pcol].init_placements = 4
			p.active = (pcol == GD.game.current_player_color)
			getObjectFromGUID(C.player_boards[pcol]).call("setState",p)
		end
		GD.game.players_init_placed = 0
		GD.game.init_placement = 4
	else
		getObjectFromGUID(C.player_boards[pcol]).call("setState")
		getObjectFromGUID(C.player_boards[setNextPlayer()]).call("setState", {active=true})
	end
end

--[[ *****************************
Finalize an initial house placement action
Player has clicked "Done"
********************************]]
function setInitialPlacement(action)
	if env.test.trace then log("setInitialPlacement()") end
	if GD.game.stage ~= "initial_placement" then
		log(("*** ERROR: setInitialPlacement() invalid game stage")) --shouldn't happen
		return
	end
	local obj = getObjectFromGUID(action.guid)
	local player = GD.game.players[action.player_color]
	removeFromPlayerBoard(obj)
	player.init_placements = player.init_placements - 1
	player.placed_houses[obj.getGUID()] = {node=action.undo.node_index, pos=obj.getPosition(), rot=obj.getRotation()}
	GD.game.players_init_placed = GD.game.players_init_placed + 1
	if GD.game.players_init_placed == GD.game.player_count then
		--reset for next round of placement until all 4 placed
		GD.game.players_init_placed = 0
		GD.game.init_placement = GD.game.init_placement - 1
	end
	if GD.game.init_placement == 0 then
		--End of placement, setup for first round
		for pcol,pdata in pairs(GD.game.players) do
			startingQuarry(pcol)
		end
		broadcastToAll("Begin First Round")
		GD.game.current_round = 0
		beginNextRound()
		return
	else
		getObjectFromGUID(C.player_boards[action.player_color]).call("setState")
		getObjectFromGUID(C.player_boards[setNextPlayer()]).call("setState",{active=true})
	end
end

--[[/////////// Game Play ///////////////////////]]

--[[ *****************************
TODO: document
********************************]]
function beginNextRound()
	if env.test.trace then log("beginNextRound()") end
	GD.game.current_round = GD.game.current_round + 1
	if GD.env.verbose then broadcastToAll("Beginning round "..tostring(GD.game.current_round).." of max 10") end
	moveMaharaja()
	GD.game.remaining_round_players = {} ---HACK: is there a better way to do this?
	updateTurnOrder()
	GD.game.stage = "select_actions"
	for pcol,player in pairs(GD.game.players) do
		player.has_actions = true
		player.actions_set = false
		player.turn_actions = {}
		player.pointers = {}
		if player.free_action then
			player.free_action.status = ""
			updateDialUI(pcol)
		end
		setCharacterBonus(pcol, false)   --TODO: is this needed here?
		local dial = getObjectFromGUID(C.action_dials[pcol])
		dial.call("reset")
		dial.call("enableDialButtons")
		dial.call("hideMe")
		if dial.is_face_down then dial.call("flipMe") end
		local txt = "Secretly choose turn actions and confirm with Done.\n"  --TODO: make a constant?
		txt = txt .. "Player turns will begin once all have confirmed.\n"
		txt = txt .. "Until then selections can be modified."
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{active=true,done=false,undo=false,help_text=txt})
		table.insert(GD.game.remaining_round_players, pcol)
	end
end

--[[ *****************************
Process a dropped character card.
Result depends on game stage.
********************************]]
function characterDrop(pcol, obj)
	if env.test.trace then log("characterDrop()") end
	local char_id = getCharacterId(obj.getGUID())
	local board = getObjectFromGUID(C.board_guid)
	local player = GD.game.players[pcol]
	--///////// Local Functions //////////
	local function snapBack(obj)
		local pos,rot
		for color,pdata in pairs(GD.game.players) do
			if char_id == pdata.character_id then
				local player_board = getObjectFromGUID(C.player_boards[color])
				pos = player_board.positionToWorld(C.player_board_character_location)
				rot = player_board.getRotation()
			end
		end
		if not(pos) then pos = C.characters[char_id].bank_pos end
		if not(rot) then rot = board.getRotation() end
		obj.setPositionSmooth(pos, false, true)
		obj.setRotation(rot)
		return
	end
	--/////////////////////////////////
	if GD.game.select_route_dialog then log("Ignoring: route selection dialog open"); snapBack(obj); return end
	if pcol ~= GD.game.current_player_color and not(player.replace_character) then snapBack(obj) return end
	if GD.game.stage == "select_starting_characters" then
		if #GD.game.players[pcol].pending_actions > 0 then
			if GD.env.verbose then broadcastToColor("Character already selected", pcol) end
			snapBack(obj)
			return
		end
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		local pos = player_board.positionToWorld(C.player_board_character_location)
		local rot = player_board.getRotation()
		obj.setPositionSmooth(pos, false, true)
		obj.setRotation(rot)
		waitLock(obj)
		-- Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
		local pending_action = {
			key = "select_starting_character",
			player_color = pcol,
			character_id = char_id,
			undo = {
				guid = obj.getGUID(),
				snapback = {pos=C.characters[char_id].bank_pos, rot=board.getRotation()},
			},
		}
		table.insert(player.pending_actions, pending_action)
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=true,undo=true})
	elseif GD.game.stage == "player_turns" then
		if char_id == player.character_id then
			log("TESTING: snap back own character and ignore")
			snapBack(obj)
			return
		end
		if player.replace_character then
			--this player is selecting a new character after being stolen
			local player_board = getObjectFromGUID(C.player_boards[pcol])
			obj.setPositionSmooth(player_board.positionToWorld(C.player_board_character_location), false, true)
			obj.setRotation(player_board.getRotation())
			waitLock(obj)
			-- Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
			local pending_action = {
				key = "replace",
				player_color = pcol,
				character_id = char_id,
				undo = {
					guid = obj.getGUID(),
					snapback = {pos=C.characters[char_id].bank_pos, rot=board.getRotation()},
				},
			}
			table.insert(player.pending_actions, pending_action)
			player.replace_character = false
			UI_setAttribute("replace_done_pnl","visibility",pcol)
			UI_setAttribute("replace_undo_pnl","visibility",pcol)
			updateCityScores()
		else
			if getAvailableAction(pcol, "exchange") == nil then
				if GD.env.verbose then broadcastToColor("No more exchange actions", pcol) end
				snapBack(obj)
				return
			end
			local curr_id = player.character_id
			local curr_guid = C.characters[curr_id].g
			if curr_guid ~= obj.getGUID() then
				local opponent = ""
				local opp_char_id = -1
				for color,opp in pairs(GD.game.players) do
					if color != pcol then
						if opp.character_id == char_id then
							opponent = color
							opp_char_id = opp.character_id
							break
						end
					end
				end
				local pending_action = {
					key = "exchange",
					player_color = pcol,
					character_id = char_id,
					old_char_id = curr_id,
					opponent = opponent,
					opp_char_id = opp_char_id,
					undo = {
						new_guid = obj.getGUID(),
						snapback = {pos=C.characters[char_id].bank_pos, rot=board.getRotation()},
						old_guid = curr_guid,
					},
				}
				if opponent == "" then
					pending_action.bank = true
				else
					pending_action.bank = false
					pending_action.opp_char_id = opp_char_id
					local opp_board =  getObjectFromGUID(C.player_boards[opponent])
					pending_action.undo.snapback.pos = opp_board.positionToWorld(C.player_board_character_location)
					pending_action.undo.snapback.rot = opp_board.getRotation()
				end
				local turn_action = getAvailableAction(pcol, "exchange")
				if turn_action then
					player.character_id = char_id
					setCharacterBonus(pcol)
					pending_action.action_index = turn_action.index
					local player_board = getObjectFromGUID(C.player_boards[pcol])
					local current = getObjectFromGUID(curr_guid)
					current.setPosition(C.characters[curr_id].bank_pos)
					current.setRotation(board.getRotation())
					obj.setPositionSmooth(player_board.positionToWorld(C.player_board_character_location), false, true)
					obj.setRotation(player_board.getRotation())
					waitLock(obj)
					-- Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
					table.insert(player.pending_actions, pending_action)
					getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=true,undo=true})
					turn_action.status = "Done"
					updateDialUI(pcol)
					local txt = pcol.." exchanges character "
					if opponent == "" then txt = txt .. "with bank"
					else txt = txt .. "with "..opponent end
					if GD.env.verbose then printToAll(txt) end
					updateCityScores()
				else
					log("ERROR: characterDrop() unexpected: unable to locate unused exchange action for player "..tostring(pcol)) --DEBUG
					snapBack(obj)
				end
			end
		end
	else
		log("***ERROR: characterDrop() invalid game stage")
	end
end

--[[ *****************************
Process a dropped house.
Result depends on game stage.
********************************]]
function houseDrop(pcol, obj)
	if env.test.trace then log("houseDrop()") end
	local board = getObjectFromGUID(C.board_guid)
	local player = GD.game.players[pcol]
	local color = obj.getName()

	--/////// local functions ///////
	--[[TODO: document]]
	local function snapBack(obj)
		if env.test.trace then log("snapBack() "..tostring(obj)) end
		local pos,rot = getPlacedObjectSnap(obj.getGUID())
		if pos then
			obj.setPosition(pos)
			if rot then
				obj.setRotation(rot)
			else
				obj.setRotation(getObjectFromGUID(C.board_guid).getRotation())
			end
		else
			obj.setPosition(getPlayerBoardLocation(obj))
			obj.setRotation(getObjectFromGUID(C.player_boards[color]).getRotation())
		end
	end
	--[[TODO: document]]
	local function placeVillageHouse(obj, node)
		if env.test.trace then log("placeVillageHouse() "..tostring(obj)..", node "..tostring(node.id)) end
		-- if env.test.debug then log(node) end
		table.insert(node.houses,{g=obj.getGUID(),c=obj.getName()})
		local pos = board.positionToWorld(Vector(node.center))
		if GD.game.player_count > 2 then
			local pos_1 = Vector(node.center) - Vector(VILLAGE_OFFSET)
			local pos_2 = Vector(node.center) + Vector(VILLAGE_OFFSET)
			pos = board.positionToWorld(pos_1)
			if #node.houses == 1 then pos = board.positionToWorld(pos_2) end
		end
		pos.y = 1.5
		obj.setRotation(board.getRotation())
		obj.setPosition(pos)
		waitLock(obj)
		-- Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
	end
	--[[TODO: document]]
	local function placeCityHouse(obj, node)
		if env.test.trace then log("placeCityHouse() "..tostring(obj)..", node "..tostring(node.id)) end
		local color = obj.getName()
		local center = GD.network[node.id].center
		local index = #node.houses[color] + 1
		--handle > 6 houses in a city for a color. Stack them.
		local y = 1
		if index > 18 then index = index - 18; y = 2.2
		elseif index > 12 then index = index - 12; y = 1.7
		elseif index > 6 then index = index - 6; y = 1.2
		end
		local offset = Vector(C.city_house_offsets[color][index].o)
		local pos = Vector(center) - offset
		local rot = Vector(C.city_house_offsets[color][index].r)
		pos.y = y
		obj.setRotationSmooth(rot, false, true)
		obj.setPositionSmooth(board.positionToWorld(pos), false, true)
		table.insert(node.houses[color],obj.getGUID())
		waitLock(obj)
		-- Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 2)
	end
	--//////////////////////////////////

	local pos = obj.getPosition()
	pos.y = 0
	local node_index = closestNode(pos)
	if env.test.debug then log("nearest is id "..tostring(node_index)..", type "..GD.network[node_index].type..", name "..GD.network[node_index].name) end
	if node_index < 1 then
		snapBack(obj)
		return
	end
	local node = GD.network[node_index]
	if GD.game.stage == "initial_placement" then
		if node.type == "village" then
			if isVillageFull(node) then
				snapBack(obj)
				return
			end
			placeVillageHouse(obj,node)
			local pending_action = {
				key = "initial_placement",
				player_color = pcol,
				guid = obj.getGUID(),
				undo = {
					node_index = node_index,
					guid = obj.getGUID(),
					snapback = {
						pos=getPlayerBoardLocation(obj),
						rot=getObjectFromGUID(C.player_boards[pcol]).getRotation(),
					}
				},
			}
			table.insert(player.pending_actions, pending_action)
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=true,undo=true})
		elseif node.type == "city" then
			snapBack(obj)
		else
			snapBack(obj)
		end
	else
		if node.type == "village" or node.type == "city" then
			--check if obj already placed in location
			if node.type == "city" then
				for pcol,placed in pairs(node.houses) do
					if indexOf(placed, obj.getGUID()) > 0 then
						log("ignoring drop in same location already placed") 													--DEBUG LOGGING
						snapBack(obj)
						return
					end
				end
			elseif node.type == "village" then
				for _,e in ipairs(node.houses) do  --TODO: just use indexOf() here?
					if e.g == obj.getGUID() then
						log("ignoring drop in same location already placed") 													--DEBUG LOGGING
						snapBack(obj)
						return
					end
				end
			else
				snapBack(obj)
			end
			local pending_action = {
				key = "move",
				action_index = -1,
				is_free = false,
				location = node.type,
				player_color = pcol,
				guid = obj.getGUID(),
				undo = {
					node_index = node_index,
					guid = obj.getGUID(),
					snapback = {}
				},
			}
			local pos,rot = getPlacedObjectSnap(obj.getGUID())
			pending_action.undo.snapback = {pos=pos, rot=rot}
			if not(pending_action.undo.snapback.pos) then --this house coming from player's pool
				pending_action.undo.snapback.pos = getPlayerBoardLocation(obj)
				pending_action.undo.snapback.rot = getObjectFromGUID(C.player_boards[pcol]).getRotation()
 				pending_action.key = "build"
			end
			local turn_action
			if node.type == "city" then
				turn_action = getAvailableAction(pcol, pending_action.key)
				if not(turn_action) then turn_action = getAvailableAction(pcol, pending_action.key) end
			else
				turn_action = getAvailableAction(pcol, pending_action.key, true) --special case: true == must be a city/village action
			end
			if turn_action then
				pending_action.action_index = turn_action.index
				pending_action.is_free = (turn_action.id == "free")
			else
				snapBack(obj)
				if GD.env.verbose then broadcastToColor("No more "..pending_action.key.." actions", pcol) end
				return
			end
			if not(pending_action.is_free) and pending_action.key == "build" and player.gold < 1 then
				snapBack(obj)
				if GD.env.verbose then broadcastToColor("Not enough gold", pcol) end
				return
			end
			if node.type == "village" then
				if isVillageFull(node) then
					snapBack(obj)
					return
				else
					placeVillageHouse(obj,node)
					if pending_action.key == "move" then
						updateCityScores()
					end
				end
			else
				if player.architect_location.current_node == node_index then
					placeCityHouse(obj, node)
					if pending_action.key == "move" then
						updateCityScores()  --may have moved from and to a city, update all
					else
						updateCityScores(node)
					end
				else
					snapBack(obj)
					if GD.env.verbose then broadcastToColor("Architect must be present in the city", pcol) end
					return
				end
			end
			if pending_action.key == "build" then
				if pending_action.is_free then
					if GD.env.verbose then printToAll(pcol.." builds a house for free") end
				else
					player.gold = player.gold - 1
					getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
					if GD.env.verbose then printToAll(pcol.." builds a house for 1 gold") end
				end
			else
				if GD.env.verbose then printToAll(pcol.." moves a house") end
				--remove house from old node, add old_node restore to undo
				pending_action.undo.old_node = player.placed_houses[obj.getGUID()].node
				local old_node = GD.network[pending_action.undo.old_node]
				if old_node.type == "city" then
					local i = indexOf(old_node.houses[pcol], obj.getGUID())
					if i > 0 then table.remove(old_node.houses[pcol], i)
					else
						log("***ERROR: playerUndo() unable to clear house "..obj.getGUID().." from network node "..tostring(pending_action.undo.old_node))
					end
					updateCityScores()
				elseif old_node.type == "village" then
					--BUG don't use nil, use table.remove
					if old_node.houses[1] and old_node.houses[1].g == obj.getGUID() then
						-- old_node.houses[1] = nil
						table.remove(old_node.houses,1)
					elseif old_node.houses[2] and old_node.houses[2].g == obj.getGUID() then
						-- old_node.houses[2] = nil
						table.remove(old_node.houses,2)
					else
						log("*** ERROR: playerUndo() unable to clear house "..obj.getGUID().." from network node "..tostring(pending_action.undo.old_node))
						return
					end
				end
			end
			turn_action.status = "Done"
			updateDialUI(pcol)
			table.insert(player.pending_actions, pending_action)
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{undo=true})
		else
			snapBack(obj)
		end
	end
end

--[[ *****************************
Process a dropped palace.
********************************]]
function palaceDrop(pcol, obj)
	if env.test.trace then log("palaceDrop()") end
	local board = getObjectFromGUID(C.board_guid)
	local player = GD.game.players[pcol]
	local color = obj.getName()

	--/////// local functions ///////
	--[[TODO: document]]
	local function snapBack(obj)
		obj.setPosition(getPlayerBoardLocation(obj))
		obj.setRotation(getObjectFromGUID(C.player_boards[color]).getRotation())
	end
	--[[TODO: document]]
	local function placePalace(obj, node)
		local color = obj.getName()
		local center = GD.network[node.id].center
		local rot = board.getRotation()
		local pos = center
		if node.center_palace then
			local index = #node.palaces + 1
			local offset = Vector(C.city_palace_offsets[index])
			pos = Vector(center) - offset
			log("placing "..color.." palace "..obj.getGUID().." in node "..tostring(node.id))
			table.insert(node.palaces,{g=obj.getGUID(),c=color,})
		else
			log("placing "..color.." palace "..obj.getGUID().." with offset in node "..tostring(node.id).." center")
			node.center_palace = {g=obj.getGUID(),c=color,}
		end
		pos.y = 1.5
		obj.setRotationSmooth(rot, false, true)
		obj.setPositionSmooth(board.positionToWorld(pos), false, true)
		waitLock(obj)
	end
	--//////////////////////////////////

	local pos = obj.getPosition()
	pos.y = 0
	local node_index = closestNode(pos)
	if node_index < 1 then
		snapBack(obj)
		return
	end
	local node = GD.network[node_index]
	if node.type ~= "city" then
		snapBack(obj)
		return
	end
	local pending_action = {
		key = "palace",
		action_index = -1,
		player_color = pcol,
		guid = obj.getGUID(),
		undo = {
			node_index = node_index,
			guid = obj.getGUID(),
			snapback = {
				pos=getPlayerBoardLocation(obj),
				rot=getObjectFromGUID(C.player_boards[color]).getRotation(),
			},
		},
	}
	local turn_action = getAvailableAction(pcol, "palace")
	if not(turn_action) then
		snapBack(obj)
		if GD.env.verbose then broadcastToColor("No more palace actions", pcol) end
		return
	end
	pending_action.action_index = turn_action.index
	local cost = 12
	if player.character_id == 6 then cost = 9 end
	if player.gold < cost then
		snapBack(obj)
		if GD.env.verbose then broadcastToColor("Not enough gold", pcol) end
		return
	end
	if player.architect_location.current_node == node_index then
		placePalace(obj, node)
		updateCityScores(node)
		player.gold = player.gold - cost
		pending_action.cost = cost
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
		turn_action.status = "Done"
		updateDialUI(pcol)
		table.insert(player.pending_actions, pending_action)
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{undo=true})
		if GD.env.verbose then printToAll(pcol.." places a palace for "..tostring(cost).." gold") end
	else
		snapBack(obj)
		if GD.env.verbose then broadcastToColor("Architect must be present in the city", pcol) end
	end
end

--[[ ****************************
Process a dropped architect.
Place in player city location, snap back if not city.
Calculate route(s) from origin, display chooser if needed.
Setup pending architect move action.
********************************]]
function architectDrop(pcol, obj)
	if env.test.trace then log("architectDrop(): "..pcol..", "..tostring(obj)) end
	local board = getObjectFromGUID(C.board_guid)
	local player = GD.game.players[pcol]
	local color = obj.getName()
	local function snapback(obj)
		local pos = player.architect_location.snap_pos
		assert(pos, "***ERROR: architectDrop() invalid snap back position")
		obj.setPosition(pos)
	end
	if color ~= pcol then snapback(obj) end
	local pos = obj.getPosition()
	local node_index = closestNode(pos)
	if node_index < 1 then
		snapBack(obj)
		return
	end
	local node = GD.network[node_index]
	if node.type ~= "city" then
		snapback(obj)
		return
	end
	if node_index == player.architect_location.current_node then
		snapback(obj)
		return
	end
	--check if latest pending action is an uncompleted architect, disallow if so
	if #player.pending_actions > 0 then
		local pending = player.pending_actions[#player.pending_actions]
		if pending.key == "architect" and pending.route_cost < 0 then
			if GD.env.verbose then broadcastToColor("Complete pending architect move first", pcol) end
			snapback(obj)
			return
		end
	end
	--position pawn on city location
	local lpos = Vector(node.center) - Vector(C.city_pawn_offsets[pcol])
	obj.setPosition(board.positionToWorld(lpos))
	--update costs of the paths for this player color
	updatePathTable(pcol)
	--build the route table
	local start_id = player.architect_location.current_node
	local dest_id = node_index
	local tmp = buildRouteTable(start_id, dest_id)
	if #tmp == 0 then --no valid route
		log("No valid route from node "..tostring(start_id).." to node "..dest_id)
		snapback(obj)
		return
	end
	local routes = {}
	for i,e in ipairs(tmp) do  --calculate route costs
		local route = {}
		route.total_cost = 0
		route.length = 0
		local cities = ""
		for _,c in ipairs(e.seen) do
			cities = cities .." "..tostring(c)
		end
		route.cities = cities
		local costs = {}
		for _,p in ipairs(e.paths) do
			route.length = route.length + 1
			for color,cost in pairs(GD.path_table[p].cost) do
				route.total_cost = route.total_cost + cost
				if costs[color] ~= nil then
					costs[color] = costs[color] + cost
				else
					costs[color] = cost
				end
			end
		end
		route.costs = simpleDeepCopy(costs)
		table.insert(routes,simpleDeepCopy(route))
	end
	local zero_route = false
	--skip all of this route processing if monk
	local free_route = false
	if player.character_id == 4 then
		free_route = true
	else
		local tmp = {}
		for i,route in ipairs(routes) do
			if route.total_cost <= player.gold then
				table.insert(tmp, route)
			else
				if env.test.debug then log("Route too expensive "..tostring(i)..": "..route.cities) end
			end
		end
		routes = tmp
		if #routes == 0 then
			if env.test.debug then log("All routes from node "..tostring(start_id).." to node "..dest_id.." cost more than player "..pcol.." gold") end
			if GD.env.verbose then broadcastToColor("Not enough gold", pcol) end
			snapback(obj)
			return
		end
		-- keep just one (the shortest) free route
		local shortest
		for i,route in ipairs(routes) do
			if route.total_cost == 0 then
				if shortest == nil then
					zero_route = true
					shortest = {id=i, length=route.length}
				elseif route.length < shortest.length then
					if routes[shortest.id] then routes[shortest.id].total_cost = -1 end
					shortest.id = i
					shortest.len = route.length
				else
					route.total_cost = -1
					if env.test.debug then log("removing duplicate 0 cost route "..route.cities) end
				end
			end
		end
		--remove duplicates (where all color costs are same, route length does not matter)
		for i,route in ipairs(routes) do
			if route.total_cost > 0 then
				for j,r in ipairs(routes) do
					if r.total_cost > 0 then
						local same = true
						for color,cost in pairs(route.costs) do
							if not(r[color]) or r[color].cost ~= cost then same = false; break end
						end
						if same then
							routes[j].total_cost = -1
							if env.test.debug then log("removing duplicate cost route "..route.cities) end
						end
					end
				end
			end
		end
		--now remove all routes that have been pruned (total_cost == -1)
		local temp = {}
		for i,route in ipairs(routes) do
			if route.total_cost >= 0 then table.insert(temp, route) end
		end
		routes = temp
	end
	--Setup the architect move action
	local pending_action = {
		key = "architect",
		player_color = pcol,
		guid = obj.getGUID(),
		route_cost = -1,
		undo = {
			node_index = node_index,
			guid = obj.getGUID(),
			snapback = {
				pos = player.architect_location.snap_pos,
				old_node = player.architect_location.current_node,
			},
		},
	}
	player.route_table = routes
	sortRoutes(pcol)
	player.architect_location.current_node = node_index
	player.architect_location.snap_pos = obj.getPosition()
	updateCityScores()
	-- local free_route = false
	-- if player.character_id == 4 then free_route = true
	if not(free_route) and zero_route and player.prefs.auto_select_zero_route then free_route = true end
	--display route dialog if approprite or just auto select the free move
	if free_route then
		if GD.env.verbose then printToAll(pcol.." pays 0 gold to move Architect") end
		pending_action.route_cost = 0
		table.insert(player.pending_actions, pending_action)
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{undo=true})
		return
	elseif player.prefs.auto_select_unique_cheapest_route then
		if #player.route_table == 1 or player.route_table[1].total_cost ~= player.route_table[2].total_cost then
			local route = player.route_table[1]
			pending_action.route_cost = route.total_cost
			player.gold = player.gold - route.total_cost
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
			for color,cost in pairs(route.costs) do
				local opp = GD.game.players[color]
				opp.gold = opp.gold + cost
				getObjectFromGUID(C.player_boards[color]).call("setState",{gold_coins=opp.gold})
				if GD.env.verbose then printToAll(pcol.." pays "..color.." "..tostring(cost).." gold") end
			end
			if GD.env.verbose then printToAll(pcol.." pays "..tostring(route.total_cost).." gold to move Architect") end
			pending_action.costs = simpleDeepCopy(route.costs)
			table.insert(player.pending_actions, pending_action)
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{undo=true})
			return
		end
	end
	table.insert(player.pending_actions, pending_action)
	getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=false, undo=false})
	GD.game.select_route_dialog = true
	updateRouteDialog(pcol)
end

--[[ *****************************
Start a player's action turn.
********************************]]
function startPlayerTurn(pcol)
	if env.test.trace then log("startPlayerTurn() for player "..tostring(pcol)) end
	local player = GD.game.players[pcol]
	assert(player,"Failed to locate player for color "..tostring(pcol))
	player.pending_actions = {}
	if GD.env.verbose then printToAll("Starting turn for player "..pcol) end
	local dial = getObjectFromGUID(C.action_dials[pcol])
	Wait.condition(
		function()
			dial.call("disableDialButtons")
			dial.call("disableBackButton")
			dial.call("showMe")
			if dial.is_face_down then dial.call("flipMe") end
		end,
		function() return(dial.resting) end, 5) --HACK: might be flipping from lock actions call so wait
	getObjectFromGUID(C.player_pawns[pcol]).setLock(false)
	--set and/or execute bonus of character tile
	if player.character_bonus == "+1_extra_action" then
			player.extra_actions = player.extra_actions + 1
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{extra_actions=player.extra_actions, extra_button=true})
			if GD.env.verbose then printToAll(pcol.." +1 extra action token for the Yogi") end
	elseif player.character_bonus == "+1_gold" then
			player.gold = player.gold + 1
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
			if GD.env.verbose then printToAll(pcol.." +1 gold for the Trader") end
	end
	--execute any immediate turn actions, set pawn, house, palace lock state based on actions selected
	local palace,pool,move,track,char = false,false,false,false,false
	for _,action in pairs(player.turn_actions) do
		if action.id == "gold" then
			player.gold = player.gold + 2
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
			if GD.env.verbose then printToAll(pcol.." +2 gold for Coins action") end
			action.status = "Done"
			updateDialUI(pcol)
		elseif action.id == "quarry" then
			if quarryAction(pcol) then
				if GD.env.verbose then printToAll(pcol.." moves 2 houses into their Build Pool") end
				action.status = "Done"
				updateDialUI(pcol)
			else
				if GD.env.verbose then printToAll(pcol.." is unable to complete selected Quarry action!") end
				action.status = "Failed"
				updateDialUI(pcol)
			end
		elseif action.id == "palace" then palace = true
		elseif action.id == "build" then pool = true
		elseif action.id == "move" then move = true
		elseif action.id == "track" then track = true
		elseif action.id == "exchange" then char = true
		end
	end
	if player.free_action then pool,move = true,true end
	if palace then unplayedPalacesLock(pcol, false) end
	if pool then buildPoolLock(pcol, false) end
	if move then placedHousesLock(pcol, false) end
	if track then setGovernorButtons(true) end
	if char then charactersLock(pcol, false) end
	--enable player board for actions
	local state = {undo=false,}
	state.active = true
	state.done = true
	state.extra_actions = GD.game.players[pcol].extra_actions
	state.extra_button = state.extra_actions > 0
	local txt = "Execute actions in any order.\n" 			--TODO: make this a constant?
	txt = txt.."May move Architect at any time.\n"
	txt = txt.."All required actions must be executed.\n"
	state.help_text = txt..C.character_bonus_descriptions[player.character_id]
	getObjectFromGUID(C.player_boards[pcol]).call("setState",state)
	for _,p in ipairs(GD.game.player_order) do
		if p ~= pcol then getObjectFromGUID(C.player_boards[p]).call("setState") end --set everyone else inactive
	end
end

--[[ *****************************
Process player Done click based on current game stage.
--For all entries in the player's pending action list:
	-- POP an entry off the LIFO stack
	-- finallize the pendign action, update data structures etc.
	-- remove the entry from the LIFO stack
	-- if more entries, repeat
********************************]]
function playerDone(pcol)
	if env.test.trace then log("playerDone(): "..pcol) end
	local player = GD.game.players[pcol]
	if GD.game.stage == "select_starting_characters" then  --Done during character selection
		local action = player.pending_actions[1]
		assert(action,"*** ERROR: missing starting character action")
		setStartingCharacter(action)
		if env.test.debug then log("Player "..pcol.." finalize "..action.key.." action") end
		table.remove(player.pending_actions, 1)
	elseif GD.game.stage == "initial_placement" then  --Done during initial placement
		local action = player.pending_actions[1]
		assert(action,"*** ERROR: missing initial placement action")
		setInitialPlacement(action)
		if env.test.debug then log("Player "..pcol.." finalize "..action.key.." action") end
		table.remove(player.pending_actions, 1)
	elseif GD.game.stage == "select_actions" then  --Done during action selection
		if player.choosing_extra_action then
			setExtraAction(pcol)
		else
			log("Player clicked Done during action selection")   --TODO: LOGGING
			player.actions_set = true
			local all_set = true
			for _,pdata in pairs(GD.game.players) do
				if not(pdata.actions_set) then all_set = false; break end
			end
			if all_set then
				broadcastToAll("All players have set actions, starting player turns")
				for _,pcol in ipairs(GD.game.player_order) do
					local dial = getObjectFromGUID(C.action_dials[pcol])
					dial.call("disableBackButton")
					if not(dial.is_face_down) then dial.call("flipMe") end
					getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=false,help=false})
				end
				GD.game.stage = "player_turns"
				startPlayerTurn(setNextPlayer(FIRST))
			else
				local dial = getObjectFromGUID(C.action_dials[pcol])
				dial.call("enableBackButton")
				dial.call("disableDialButtons")
				if not(dial.is_face_down) then dial.call("flipMe") end
				getObjectFromGUID(C.player_boards[pcol]).call("setState",{done=false})
			end
		end
	elseif GD.game.stage == "player_turns" then --Done during other game stages
		if #player.pending_actions == 0 then
			log("*** WARN: playerDone() no actions to finalize for player "..pcol) --DEBUG
		end
		if failedActions(pcol) then
			if GD.env.verbose then broadcastToAll(pcol.." did not complete all required actions!") end
			for color,player in pairs(GD.game.players) do
				if color ~= pcol then
					player.gold = player.gold + 2
					getObjectFromGUID(C.player_boards[color]).call("setState",{gold_coins=player.gold})
					if GD.env.verbose then printToAll(color.." recieves +2 penalty gold") end
				end
			end
		elseif hasRequiredActions(pcol) then
			UI_setAttribute("penalty_dialog_pnl","visibility","Pink|"..pcol)
			return
		end
		while #player.pending_actions > 0 do
			local index = #player.pending_actions
			local action = player.pending_actions[index]
			if env.test.debug then log("Player "..pcol.." finalize "..action.key.." action") end  --DEBUG
			if action.key == "track" then
				player.governor_clicked = false
			elseif action.key == "gold" then
				--noop
			elseif action.key == "exchange" then
				if action.bank then
					updateTurnOrder()
				else
					--lock game progression and show confirmation dialog for replace character
					GD.game.wait_for_character_replace = true
					local opp = GD.game.players[action.opponent]
					opp.replace_character = true
					UI_setAttribute("replace_done_pnl","visibility","Pink")
					UI_setAttribute("replace_undo_pnl","visibility","Pink")
					UI_setAttribute("replace_character_txt","text",action.opponent)
					UI_setAttribute("replace_character_txt","color",action.opponent)
					UI_setAttribute("replace_character_pnl","active",true)
				end
				if player.character_id == 3 then
					updateCityScores()
					updateStatusPanel()
				end
			elseif action.key == "palace" then
				log("adding palace "..tostring(action.guid).." to "..pcol.." placed_palaces")
				table.insert(player.placed_palaces, action.guid)
				if #player.placed_palaces == 7 then
					if not(GD.game.game_end_this_round) then
						GD.game.game_end_this_round = true
						broadcastToAll("Player "..pcol.." has built their 7th Palace.")
						broadcastToAll("Game will end after scoring current city!")
					end
				end
				unplayedPalacesLock(pcol, false)
			elseif action.key == "quarry" then
				--noop
			elseif action.key == "move" then
				local obj = getObjectFromGUID(action.guid)
				player.placed_houses[obj.getGUID()] = {node=action.undo.node_index, pos=obj.getPosition(), rot=obj.getRotation(),}
				placedHousesLock(pcol, false)
			elseif action.key == "build" then
				local obj = getObjectFromGUID(action.guid)
				removeFromPlayerBoard(obj)
				player.placed_houses[obj.getGUID()] = {node=action.undo.node_index, pos=obj.getPosition(), rot=obj.getRotation(),}
				buildPoolLock(pcol, false)
			elseif action.key == "architect" then
					--TODO noop??
			elseif action.key == "extra_action" then
					--TODO: noop??
			else
				log("*** ERROR: playerDone() unknown action key "..tostring(action.key)) --DEBUG
				return
			end
			table.remove(player.pending_actions, index)
		end
		endTurn(pcol)
	else
		log("*** ERROR: unknown game stage")
	end
end

--[[ *****************************
Check for end of round & start a new one otherwise start next players turn
********************************]]
function endTurn(pcol)
	if env.test.trace then log("endTurn() "..tostring(pcol)) end
	--clear out all player turn data`
	local player = GD.game.players[pcol]
	player.has_actions = false
	player.turn_actions = {}
	player.pointers = {}
	player.pending_actions = {}
	getObjectFromGUID(C.player_pawns[pcol]).setLock(true)
	unplayedPalacesLock(pcol, true)
	buildPoolLock(pcol, true)
	placedHousesLock(pcol, true)
	setGovernorButtons(false)
	if GD.game.wait_for_character_replace then
		charactersLock("bank", false)
	else
		charactersLock(pcol, true)
	end
	--update round and check for end of round or end of game
	local index = indexOf(GD.game.remaining_round_players,pcol)
	assert(index > 0,"***ERROR: could not locate player in remaining_round_players")
	table.remove(GD.game.remaining_round_players,index)
	if not(GD.game.wait_for_character_replace) then
		if #GD.game.remaining_round_players == 0 then
			finishCurrentRound()
		else
			startPlayerTurn(setNextPlayer())
		end
	else
		if GD.env.verbose then broadcastToAll("Waiting on a player to select a replacement character") end
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{active=false,done=false,undo=false})
	end
end

--[[ ****************************
Score the current city, check for endgame and advance to next round if not.
********************************]]
function finishCurrentRound()
	if env.test.trace then log("finishCurrentRound()") end
	local city = GD.game.governor_track[7].city
	if GD.env.verbose then printToAll("End of round "..tostring(GD.game.current_round)) end
	scoreCity(city)
	if GD.game.current_round == 10 or GD.game.game_end_this_round then  --TODO: may move to city scoring results dialog ack???
		endGame()
	else
		beginNextRound()
	end
end

--[[ *****************************
TODO: document
--POP an entry off the player's LIFO pending actions stack
--undo any placements, action effects, etc.
--remove the pending action entry
--disable player's done button
--if no remaining pending actinos, disable player's undo button
TODO: add verbose prints of what action is undone
********************************]]
function playerUndo(pcol)
	if env.test.trace then log("playerUndo(): "..pcol) end
	local player = GD.game.players[pcol]
	local function resetAction(pcol, action)
		if action.is_free then           --TODO: discreet free build/move action
			player.free_action.status = ""
		else
			for _,a in pairs(GD.game.players[pcol].turn_actions) do		--TODO: if a.index always matches turn_actions array index, is loop necessary? not sure it always does.
				if a.index == action.action_index then a.status = ""; break end
			end
		end
	end
	local actions = player.pending_actions
	if #actions == 0 then return end
	local action = actions[#actions]
	if env.test.debug then log("action to undo:");log(action) end
	if action.key == "select_starting_character" then
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
	elseif action.key == "initial_placement" then
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
		local node = GD.network[action.undo.node_index]
		if node.houses[1] and node.houses[1].g == action.guid then
			--BUG don't use nil, use table.remove
			-- node.houses[1] = nil
			table.remove(node.houses,1)
		elseif node.houses[2] and node.houses[2].g == action.guid then
			-- node.houses[2] = nil
			table.remove(node.houses,2)
		else
			log("*** ERROR: playerUndo() unable to clear house "..action.guid.."from network node "..tostring(action.undo.node_index))
		end
	elseif action.key == "track" then
		GD.game.governor_track = simpleDeepCopy(action.undo.restore_list)
		updateGovernorTrack()
		setGovernorButtons(true)
		resetAction(pcol, action)
		updateDialUI(pcol)
		player.governor_clicked = false
		action.status = ""
	elseif action.key == "build" then
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
		local node = GD.network[action.undo.node_index]
		if node.type == "city" then
			local i = indexOf(node.houses[pcol], action.guid)
			if i > 0 then
				table.remove(node.houses[pcol], i)
			else --DEBUG
				log("***ERROR: playerUndo() unable to clear house "..action.guid.." from network node "..tostring(action.undo.node_index))  --DEBUG
				return
			end
			updateCityScores(node)
			updateStatusPanel()
		else
			--BUG don't use nil, use table.remove
			if node.houses[1] and node.houses[1].g == action.guid then
				-- node.houses[1] = nil
				table.remove(node.houses,1)
			elseif node.houses[2] and node.houses[2].g == action.guid then
				-- node.houses[2] = nil
				table.remove(node.houses,2)
			else
				log("*** ERROR: playerUndo() unable to clear house "..action.guid.." from network node "..tostring(action.undo.node_index))  --DEBUG
				return
			end
		end
		resetAction(pcol, action)
		if not(action.is_free) then
			player.gold = player.gold + 1
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
		end
		updateDialUI(pcol)
	elseif action.key == "exchange" then
		local new = getObjectFromGUID(action.undo.new_guid)
		local old = getObjectFromGUID(action.undo.old_guid)
		new.setPosition(action.undo.snapback.pos)
		new.setRotation(action.undo.snapback.rot)
		new.setLock(false)
		local player_board = getObjectFromGUID(C.player_boards[action.player_color])
		old.setPosition(player_board.positionToWorld(C.player_board_character_location))
		old.setRotation(player_board.getRotation())
		old.setLock(false)
		player.character_id = action.old_char_id
		setCharacterBonus(pcol, false)
		--handle case character had immediate effects
		if action.character_id == 2 then
			player.gold = player.gold - 1
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
		elseif action.character_id == 7 then
			player.extra_actions = player.extra_actions - 1
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{extra_actions=player.extra_actions})
		end
		resetAction(pcol, action)
		updateDialUI(pcol)
	elseif action.key == "move" then
		local obj = getObjectFromGUID(action.undo.guid)
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
		--restore old node
		local old_node = GD.network[action.undo.old_node]
		if old_node.type == "city" then
			table.insert(old_node.houses[obj.getName()], obj.getGUID())
		else
			table.insert(old_node.houses,{g=obj.getGUID(), c=obj.getName()})
		end
		--remove from current node
		local node = GD.network[action.undo.node_index]
		if node.type == "city" then
			local i = indexOf(node.houses[pcol], action.guid)
			if i > 0 then table.remove(node.houses[pcol], i)
			else
				log("***ERROR: playerUndo() unable to clear house "..action.guid.." from network node "..tostring(action.undo.node_index))  --DEBUG
				return
			end
		else
			--BUG don't set to nil, breaks ipairs, use table.remove
			if node.houses[1] and node.houses[1].g == action.guid then
				-- node.houses[1] = nil
				table.remove(node.houses, 1)
			elseif node.houses[2] and node.houses[2].g == action.guid then
				-- node.houses[2] = nil
				table.remove(node.houses, 2)
			else
				log("*** ERROR: playerUndo() unable to clear house "..action.guid.." from network node "..tostring(action.undo.node_index))  --DEBUG
				return
			end
		end
		updateCityScores()
		resetAction(pcol, action)
		updateDialUI(pcol)
	elseif action.key == "architect" then
		local return_pos = action.undo.snapback.pos
		local old_node = action.undo.snapback.old_node
		local pawn = getObjectFromGUID(action.guid)
		pawn.setLock(false)
		pawn.setPosition(return_pos)
		player.architect_location.current_node = old_node
		player.architect_location.snap_pos = return_pos
		updateCityScores()
		if action.route_cost > 0 then
			for color,cost in pairs(action.costs) do
				local opp = GD.game.players[color]
				opp.gold = opp.gold - cost
				getObjectFromGUID(C.player_boards[color]).call("setState",{gold_coins=opp.gold})
			end
			player.gold = player.gold + action.route_cost
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
		end
	elseif action.key == "palace" then
		local obj = getObjectFromGUID(action.guid)
		assert(obj, "***ERROR: no object for palace on undo")
		obj.setPosition(action.undo.snapback.pos)
		obj.setRotation(action.undo.snapback.rot)
		obj.setLock(false)
		local node = GD.network[action.undo.node_index]
		log("undo place palace for node "..tostring(action.undo.node_index))
		if node.center_palace and node.center_palace.g == action.guid then
			log("setting node center_palace to nil")
			node.center_palace = nil
		else
			for i,e in ipairs(node.palaces) do
				if e.g == action.guid then
					log("removing "..tostring(action.guid).." from node.palaces index "..tostring(i))
					table.remove(node.palaces, i)
					break
				end
			end
		end
		resetAction(pcol, action)
		player.gold = player.gold + action.cost
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
		updateDialUI(pcol)
		updateCityScores(node)
	elseif action.key == "extra_action" then
		--give back the token
		player.extra_actions = player.extra_actions + 1
		local state = {extra_actions=player.extra_actions, extra_button=true}
		for _,action_id in ipairs(action.undo) do
			if action_id == "gold" then
				player.gold = player.gold - 2
				state.gold_coins = player.gold
			elseif aaction_id == "quarry" then
				local quarry = player.quarry
				local pool = player.pool
				for i=1,2 do
					for p=12,1,-1 do
						if pool[p].g then
							for q=1,16 do
								if not(quarry[q].g) then
									getObjectFromGUID(pool[p].g).setPosition(quarry[q].p)
									quarry[q].g = pool[p].g
									pool[p].g = nil
									break --out of quarry loop
								end
							end
							break --out of pool loop
						end
					end
				end
			elseif action_id == "palace" then
				unplayedPalacesLock(pcol, true)
			elseif action_id == "build" then
				buildPoolLock(pcol, true)
			elseif action_id == "move" then
				placedHousesLock(pcol, true)
			elseif action_id == "track" then
				setGovernorButtons(false)
			elseif action_id == "exchange" then
				charactersLock(pcol, true)
			end
		end
		--remove any turn actions added by the extra action and update UIs
		getObjectFromGUID(C.player_boards[pcol]).call("setState",state)
		local temp = {}
		for i,a in ipairs(player.turn_actions) do
			if a.pointer_id ~= "pointer-extra" then table.insert(temp,a) end
		end
		player.turn_actions = temp
		for i,a in ipairs(player.turn_actions) do a.index = i end  --fixup index
		updateDialUI(pcol)
		local dial = getObjectFromGUID(C.action_dials[pcol])
		dial.call("removeExtraActionPointer")
	else
		log("*** ERROR: playerUndo() unknown action key "..tostring(action.key))
		return
	end
	--remove entry and update player board UI
	if GD.env.verbose then printToAll(pcol.." undo "..action.key.." action") end
	table.remove(player.pending_actions, index)
	if #player.pending_actions == 0 then
		getObjectFromGUID(C.player_boards[pcol]).call("setState",{undo=false})
	end
end

--[[ *****************************
TODO: implement and document
********************************]]
function moveMaharaja()
	if env.test.trace then log("moveMaharaja()") end
	-- move maha to next city position (1st in gov track table)
	local board = getObjectFromGUID(C.board_guid)
	local track = GD.game.governor_track
	local city = track[1].city
	GD.game.maharaja_node = track[1].node
	local pos = board.positionToWorld(C.cities[city].maharaja_pos)
	local maha = getObjectFromGUID(C.maharaja_guid)
	maha.setLock(false)
	maha.setPosition(pos)
	waitLock(maha)
	-- Wait.condition(function() maha.setLock(true) end, function() return(maha.resting) end, 2)
	-- move table 1st to 7th, shift others up
	local temp = simpleDeepCopy(track[1])
	temp.UI_row = track[7].UI_row
	temp.track_row = track[7].track_row + 1
	for i=2,7 do
		track[i-1] = simpleDeepCopy(track[i])
		track[i-1].UI_row = track[i-1].UI_row + 1
	end
	track[7] = temp
	updateGovernorTrack()
end

--[[ ********* TODO rank all players *******************
Player with most palaces built wins.
FIrst tie breaker is most gold.
Second tie breaker is lowest character ID.
--TODO rank all players and show a dialog of final rank
********************************]]
function endGame()
	if env.test.trace then log("endGame()") end
	-- most palaces built.
	local winners, most_palaces = {}, 0
	for pcol,player in pairs(GD.game.players) do
		if #player.placed_palaces > most_palaces then
			most_palaces = #player.placed_palaces; winners = {pcol}
		elseif #player.placed_palaces == most_palaces then
			if #winners == 0 then winners = {pcol} else table.insert(winners, pcol) end
		end
	end
	local tie_breaker
	--first tie breaker if needed
	if #winners > 1 then
		tie_breaker = "most gold"
		local temp, most_gold = {}, 0
		for _,pcol in ipairs(winners) do
			if GD.game.players[pcol].gold > most_gold then most_gold = GD.game.players[pcol].gold; temp = {pcol}
			elseif GD.game.players[pcol].gold == most_gold then table.insert(temp, pcol) end
		end
		winners = temp
	end
	--second tie breaker if needed
	if #winners > 1 then
		tie_breaker = "lowest character number"
		local lowest_id, winner = 99, nil
		for _,pcol in ipairs(winners) do
			if GD.game.players[pcol].character_id < lowest_id then winner = pcol end
		end
		winners = {winner}
	end
	--announce winner
	local winner = winners[1]
	local palaces = #GD.game.players[winner].placed_palaces
	local txt = tostring(winner).." wins the game with "..tostring(palaces).." palaces."
	if tie_breaker then txt = txt .." Tie breaker is "..tie_breaker end
	broadcastToAll(txt)
	UI.setAttribute("end_game_winner_txt","text",tostring(winner))
	UI.setAttribute("end_game_winner_txt","color",tostring(winner))
	local rank = rankPlayers()
	for i=1,5 do
		if rank[i] then
			UI.setAttribute("end_row_"..tostring(i).."_player","text",rank[i].color)
			UI.setAttribute("end_row_"..tostring(i).."_player","color",rank[i].color)
			UI.setAttribute("end_row_"..tostring(i).."_palaces","text",tostring(rank[i].palaces))
			UI.setAttribute("end_row_"..tostring(i).."_gold","text",tostring(rank[i].gold))
			UI.setAttribute("end_row_"..tostring(i).."_charid","text",tostring(rank[i].id))
			UI.setAttribute("end_row_"..tostring(i),"active",true)
		else
			UI.setAttribute("end_row_"..tostring(i),"active",false)
		end
	end
	UI.setAttribute("end_game_pnl","active",true)

	--disable all buttons, everything
	for _,pcol in ipairs(GD.game.player_order) do
		getObjectFromGUID(C.player_boards[pcol]).call("setState", {active=false,done=false,undo=false,extra_button=false,})
		buildPoolLock(pcol, true)
		unplayedPalacesLock(pcol, true)
		placedHousesLock(pcol, true)
	end
	charactersLock("all", true)
	setGovernorButtons(false)

	log("TODO: rank all players and show a dialog with final ranking")
end

--[[ ****************************
Bubble sort the players for final end game ranking.
Sort first by #palaces placed.
Sort second (first tiebreaker) by most gold.
Sort third (second tiebreaker) by lowest character ID.
Returns a sorted array of players {color, pdata}.
********************************]]
function rankPlayers()
	if env.test.trace then log("rankPlayers()") end
	local rank = {}
	--sort by palaces placed
	for color,player in pairs(GD.game.players) do
		local data = {
			color=color,
			palaces=#player.placed_palaces,
			gold=player.gold,
			id=player.character_id,
		}
		if #rank == 0 then
			table.insert(rank, data)
		else
			local add = true
			for i,e in ipairs(rank) do
				if data.palaces > e.palaces then
					table.insert(rank, i, data)
					add = false
					break
				elseif data.palaces == e.palaces then
					if data.gold > e.gold then
						table.insert(rank, i, data)
						add = false
						break
					elseif data.gold == e.gold then
						if data.character_id < e.character_id then
							table.insert(rank, i, data)
							add = false
							break
						end
					end
				end
			end
			if add then
				table.insert(rank, data)
			end
		end
	end
	return rank
end

--DEBUG functions for testing for phantom palaces
function testPhantomPalaces()
	for i,n in ipairs(GD.network) do
		if n.palaces then
			if n.center_palace ~= nil then
				local found = false
				log("checking center "..tostring(n.center_palace.g))
				for i,g in ipairs(GD.game.players[n.center_palace.c].placed_palaces) do
					if n.center_palace.g == g then found = true end
				end
				if not(found) then
					log("Found phantom palace "..tostring(e.g).." at network node center "..tostring(i))
				end
			end
			for j,e in ipairs(n.palaces) do
				if GD.game.players[e.c] ~= nil 	then
					log("checking "..tostring(e.g))
					local found = false
					for i,g in ipairs(GD.game.players[e.c].placed_palaces) do
						if e.g == g then found = true end
					end
					if not(found) then
						log("Found phantom palace "..tostring(e.g).." at network node "..tostring(i))
					end
				end
			end
		end
	end
end

function testPlacedPalaces(pcol)
	log("testing player "..tostring(pcol).." for phantom placed palaces")
	for i,g in ipairs(GD.game.players[pcol].placed_palaces) do
		local found = false
		for i,n in ipairs(GD.network) do
			if n.palaces then
				for j,e in ipairs(n.palaces) do
					if e.g == g then found = true end
				end
				if n.center_palace ~= nil then
					if n.center_palace.g == g then found = true end
				end
			end
			if found then break end
		end
		if not(found) then
			log("********** "..pcol.." placed palace "..tostring(g).." not found in network! ***************")
		end
	end
end

--[[/////////////// Support functions /////////////////////]]

--[[ ****************************
Calculate gold payouts for all players with presence in the city.
********************************]]
function scoreCity(city)
	if env.test.trace then log("doCityScoring(): "..tostring(city)) end
	local scores = GD.game.city_scores[city]
	if env.test.debug then
		log("scores for city:")
		log(scores)
	end
	if GD.env.verbose then printToAll("Scoring city: "..tostring(city)) end
	local places = {}
	local player_list = simpleDeepCopy(GD.game.player_order)
	--cull players with 0 score
	for pcol,score in pairs(scores) do
		if score == 0 then
			table.remove(player_list, indexOf(player_list,pcol))
			if GD.env.verbose then printToAll(pcol.." has no presence in city, recieves 0 gold") end
		end
	end
	--rank players by score in city
	local safety = 5
	while #player_list > 0 and safety > 0 do
		local highest = {score=0, player=""}
		for pcol,score in pairs(scores) do
			if contains(player_list, pcol) then
				if score > highest.score then
					highest.score = score
					highest.player = pcol
				elseif score == highest.score then
					if GD.game.players[pcol].character_id < GD.game.players[highest.player].character_id then
						highest.player = pcol
					end
				end
			end
		end
		table.insert(places, highest)
		local index = indexOf(player_list, highest.player)
		table.remove(player_list, index)
		safety = safety - 1
	end
	if #places == 0 then
		log("Handle case nobody scored anything")
		if GD.env.verbose then printToAll("No players recieve gold for city scoring") end
		return
	end
	--hand out money based on score ranking
	local index = 0
	local payouts = C.city_payouts[#GD.game.player_order]
	for i,place in ipairs(places) do
		local pay = payouts[i]
		local player = GD.game.players[place.player]
		player.gold = player.gold + pay
		getObjectFromGUID(C.player_boards[place.player]).call("setState",{gold_coins=player.gold})
		if GD.env.verbose then printToAll(place.player.." recieves "..tostring(pay).." gold for city scoring") end
	end
	--monopoly bonus
	if #places == 1 then
		local place = places[1]
		local player = GD.game.players[place.player]
		player.gold = player.gold + 5
		getObjectFromGUID(C.player_boards[place.player]).call("setState",{gold_coins=player.gold})
		if GD.env.verbose then printToAll(place.player.." recieves 5 gold for city monopoly bonus") end
	end

	--TODO: show a results dialog ???  or is game log enough?
end

--[[ ******** TODO: sort on opp ************
Bubble sort the route table from least expensive to most.
Primary sort index is total cost for route
TODO: use opp cost (when supplied) as secondary sort index
********************************]]
function sortRoutes(pcol, opp)
	if env.test.trace then log("sortRoutes() "..tostring(pcol)) end
	assert(pcol, "***ERROR: missing player color")
	local opp = opp or "none"
	if env.test.debug then log("using opponent "..opp.." for secondary index") end
	local player = GD.game.players[pcol]
	local routes = player.route_table
	assert(routes, "***ERROR: no route table for player "..pcol)
	local sorted = {}
	for i,route in ipairs(routes) do
		if #sorted == 0 then
			table.insert(sorted, route)
		else
			local found = false
			for j,e in ipairs(sorted) do
				if route.total_cost < e.total_cost then
					table.insert(sorted, j, route)
					found = true
					break
				elseif route.total_cost == e.total_cost then
					if opp == "none" then
						table.insert(sorted, j, route)
						found = true
						break
					else
						--TODO: check opp
					end
				end
			end
			if not(found) then table.insert(sorted, route) end
		end
	end
	player.route_table = sorted
end

--[[ *****************************
Update the route dialog with latest route table for player and display it
********************************]]
function updateRouteDialog(pcol)
	if env.test.trace then log("updateRouteDialog() "..tostring(pcol)) end
	assert(pcol, "***ERROR: missing player color")
	local player = GD.game.players[pcol]
	local routes = player.route_table
	assert(routes, "***ERROR: no route table for player "..pcol)
	--clear all rows first and deactivate
	for i=1,GD.env.max_route_rows do
		UI_setAttribute("route_"..tostring(i).."_row","active",false)
		UI_setAttribute("route_"..tostring(i).."_total_cost","text","0")
		for _,color in ipairs(GD.game.player_order) do
			UI_setAttribute("route_"..tostring(i).."_"..color.."_cost_txt","text","")
		end
	end
	--fill rows from player's route table
	for i,route in ipairs(routes) do
		local r = tostring(i)
		UI_setAttribute("route_"..r.."_btn_txt","text",route.cities)
		for _,color in ipairs(GD.game.player_order) do
			if route.costs[color] then
				UI_setAttribute("route_"..r.."_"..color.."_cost_txt","text",tostring(route.costs[color]))
			else
				UI_setAttribute("route_"..r.."_"..color.."_cost_txt","text","")
			end
		end
		UI_setAttribute("route_"..r.."_total_cost","text",tostring(route.total_cost))
		UI_setAttribute("route_"..r.."_row","active",true)
	end
	UI_setAttribute("routes_dialog_title_player","text",pcol)
	UI_setAttribute("routes_dialog_title_player","color",pcol)
	UI_setAttribute("routes_dialog_pnl","active",true)
end

--[[ *****************************
Set the character bonus based on current character ID.
If character is Builder (#5) then add a free build action
execute: if true then any immediate character bonuse is executed.
********************************]]
function setCharacterBonus(pcol, execute)
	if execute == nil then execute = true end
	if env.test.trace then log("setCharacterBonus() "..tostring(pcol)..", execute: "..tostring(execute)) end
	local player = GD.game.players[pcol]
	assert(player.character_id and player.character_id > 0 and player.character_id <= 7, "***ERROR: setCharacterBonus(): Invalid character id")
	player.character_bonus = nil
	if player.character_id == 7 then
		player.character_bonus = "+1_extra_action"
		if execute then
			player.extra_actions = player.extra_actions + 1
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{extra_actions=player.extra_actions, extra_button=true})
			if GD.env.verbose then printToAll(pcol.." +1 extra action token for the Yogi") end
		end
	end
	if player.character_id == 6 then player.character_bonus = "build_palace_discount" end
	if player.character_id == 5 then
		if not(player.free_action) then
			player.free_action = {
				id="free",
		    label="Free Build/Move House",
				status = "",
				pointer_id = "", --TODO: get rid of this?
				free = true,  --TODO: get rid of this?
			}
		end
		if execute then
			buildPoolLock(pcol, false)
			placedHousesLock(pcol, false)
		end
		player.character_bonus = "free_build_move"
	else
		player.free_action = nil
	end
	if player.character_id == 4 then player.character_bonus = "free_travel" end
	if player.character_id == 3 then player.character_bonus = "outer_palace_scoring" end
	if player.character_id == 2 then
		player.character_bonus = "+1_gold"
		if execute then
			player.gold = player.gold + 1
			getObjectFromGUID(C.player_boards[pcol]).call("setState",{gold_coins=player.gold})
			if GD.env.verbose then printToAll(pcol.." +1 gold for the Trader") end
		end
	end
	local txt = "Execute actions in any order.\n"			--TODO: make this a constant?
	txt = txt.."May move Architect at any time.\n"
	txt = txt.."All required actions must be executed.\n"
	txt = txt..C.character_bonus_descriptions[player.character_id]
	getObjectFromGUID(C.player_boards[pcol]).call("setState",{help_text=txt})
	updateDialUI(pcol)
end

--[[ *****************************
TODO: need this in a fn?
********************************]]
function failedActions(pcol)
	if env.test.trace then log("failedActions() "..tostring(pcol)) end
	for _,action in ipairs(GD.game.players[pcol].turn_actions) do
		if action.status == "Failed" then return true end
	end
	return false
end

--[[ *****************************
Check to see if a player has any unfinished required actions.
Return true if any, false if not.
********************************]]
function hasRequiredActions(pcol)
	if env.test.trace then log("hasRequiredActions() "..tostring(pcol)) end
	for id,action in pairs(GD.game.players[pcol].turn_actions) do
		if action.status == "" then return true end
	end
	return false
end

--[[ *****************************
Search player turn actions for an unfinished action of specified action key.
key: aaction_key to search for
HACK: village: (Optional) for build actions only, if true, must be a city/village action.  Default false.
Return reference to a player turn action.  Nil if none found.
********************************]]
function getAvailableAction(pcol, key, village)
	local village = village or false
	if env.test.trace then log("getAvailableAction() "..tostring(pcol)..", key: "..tostring(key)..", village: "..tostring(village)) end
	local player = GD.game.players[pcol]
	if key == "build" then
		if player.prefer_free_action and player.free_action and player.free_action.status == "" then
			--has free action and wants it first, so give it
			return player.free_action
		else
			if village then  --action must not be city_required
				for _,action in ipairs(player.turn_actions) do
					if action.id == key and action.status == "" and not(action.city_required) then return action end
				end
			else --is a city, search for either
				for _,action in ipairs(player.turn_actions) do
					if action.id == key and action.status == "" and action.city_required then return action end
				end
				for _,action in ipairs(player.turn_actions) do
					if action.id == key and action.status == "" then return action end
				end
			end
			--didn't find a turn action, try free action
			if player.free_action and player.free_action.status == "" then return player.free_action end
		end
	elseif key == "move" then
		if player.prefer_free_action and player.free_action and player.free_action.status == "" then
			return player.free_action
		else
			for _,action in ipairs(player.turn_actions) do
				if action.id == key and action.status == "" then return action end
			end
		end
		--didn't find a turn action, try free action
		if player.free_action and player.free_action.status == "" then return player.free_action end
	else --not a build or move, just search for a matching key that is available
		for _,action in ipairs(player.turn_actions) do
			if action.id == key and action.status == "" then return action end
		end
	end
	return nil
end

--[[ *****************************
Set the locked state of a player's houses in the build pool
********************************]]
function buildPoolLock(pcol, locked)
	if env.test.trace then log("buildPoolLock()") end
	locked = locked or false
	for _,e in ipairs(GD.game.players[pcol].pool) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of a player's unplayed palaces
********************************]]
function unplayedPalacesLock(pcol, locked)
	if env.test.trace then log("unplayedPalacesLock()") end
	locked = locked or false
	for _,e in ipairs(GD.game.players[pcol].palaces) do
		if e.g then getObjectFromGUID(e.g).setLock(locked) end
	end
end

--[[ *****************************
Set the locked state of a player's placed houses
********************************]]
function placedHousesLock(pcol, locked)
	if env.test.trace then log("placedHousesLock()") end
	locked = locked or false
	for g,_ in pairs(GD.game.players[pcol].placed_houses) do
		local o = getObjectFromGUID(g)
		if o then
			o.setLock(locked)
		else
			log("***ERROR: unable to unlock placed house for "..tostring(g))
		end
	end
end

--[[ *****************************
Set the locked state of all characters.
pcol: player color or "bank".  HACK: overloaded parameter
	if pcol supplied, skip it.  Defaults to "none"
	if == "bank" then only affect tiles in the bank.
locked: Defaults to unlocked
********************************]]
function charactersLock(pcol, locked)
	locked = locked or false
	pcol = pcol or "none"
	if env.test.trace then log("charactersLock() "..tostring(pcol)..", locked = "..tostring(locked)) end
	if pcol == "bank" then
		for id,char in ipairs(C.characters) do
			local bank = true
			for _,player in pairs(GD.game.players) do
				if player.character_id == id then bank = false; break end
			end
			if bank then getObjectFromGUID(char.g).setLock(locked) end
		end
	else
		local player = getObjectFromGUID(pcol)
		for id,char in ipairs(C.characters) do
			if not(player) or player.character_id ~= id then
				getObjectFromGUID(char.g).setLock(locked)
			end
		end
	end
end

--[[ ***************************
For a given network node (that is a city) update the
City score for each player
********************************]]
function updateCityScores(node)
	if env.test.trace then log("updateCityScores()") end
	local function updateScores(node)
		assert(node.type == "city", "***ERROR: updateCityScores() node "..tostring(node.id).." is not a city")
		for _,pcol in ipairs(GD.game.player_order) do
			local score = #node.houses[pcol]
			if GD.game.players[pcol].architect_location.current_node == node.id then score = score + 1 end
			for _,palace in pairs(node.palaces) do
				if palace.c == pcol then
					if GD.game.players[pcol].character_id == 3 then
						score = score + 2
					else
						score = score + 1
					end
				end
			end
			if node.center_palace then
				if node.center_palace.c == pcol then score = score + 3 end
			end
			GD.game.city_scores[node.name][pcol] = score
		end
	end
	if node then
		updateScores(node)
	else
		for name,city in pairs(C.cities) do
			updateScores(GD.network[city.node])
		end
	end
	updateStatusPanel()
end

--[[ ***************************
Update city names and images from GD.game.governor_track
Update corresponding player score for each associated city
********************************]]
function updateStatusPanel()
	if env.test.trace then log("updateStatusPanel()") end
	for i,gov in ipairs(GD.game.governor_track) do
		UI_setAttribute("status_city_name_"..gov.UI_row, "text", gov.city)
		UI_setAttribute("status_city_image_"..gov.UI_row, "image", gov.city)
		if gov.node == GD.game.maharaja_node then
			UI_setAttribute("status_city_name_"..gov.UI_row, "color", "rgb(1,1,0)")
			UI_setAttribute("status_city_name_"..gov.UI_row, "fontStyle", "BoldAndItalic")
		else
			UI_setAttribute("status_city_name_"..gov.UI_row, "color", "white")
			UI_setAttribute("status_city_name_"..gov.UI_row, "fontStyle", "Normal")
		end
		local scores = GD.game.city_scores[gov.city]
		for pcol,score in pairs(scores) do
			if score > 0 then
				UI_setAttribute("status_p_text_"..tostring(gov.UI_row).."_"..pcol,"text",tostring(score))
			else
				UI_setAttribute("status_p_text_"..tostring(gov.UI_row).."_"..pcol,"text","")
			end
		end
	end
end

--[[ *****************************
Remove an object from player board data.
********************************]]
function removeFromPlayerBoard(obj)
	if env.test.trace then log("removeFromPlayerBoard()") end
	local player = GD.game.players[obj.getName()]
	assert(player,"*** ERROR: removeFromPlayerBoard() could not locate player data")
	if obj.memo == "palace" then
		for i,data in ipairs(player.palaces) do
			if data.g == obj.getGUID() then
				player.palaces[i].g = nil
				return
			end
		end
	else
		for i,data in ipairs(player.pool) do
			if data.g == obj.getGUID() then
				player.pool[i].g = nil
				return
			end
		end
	end
	log("*** WARN: could not find object "..obj.getGUID().." in "..obj.getName().." data")
end

--[[ *****************************
Search players placed object list for this guid.
Use obj.memo to determine type, return snap for type.
Return snap pos for obj guid if found
For placed houses, a tuple of pos,rot is returned
Returns nil if nothing found for guid matching type.
********************************]]
function getPlacedObjectSnap(guid)
	if env.test.trace then log("getPlacedObjectSnap()") end
	local obj = getObjectFromGUID(guid)
	assert(obj, "***ERROR: getPlacedObjectSnap() unable to get object ref")
	for _,pcol in ipairs(GD.game.player_order) do
		local player = GD.game.players[pcol]
		if obj.memo == "house" then
			if player.placed_houses[guid] then
				local snap = player.placed_houses[guid]
				return snap.pos, snap.rot
			end
		elseif obj.memo == "palace" then
			return player.placed_palaces[guid]
		elseif obj.memo == "architect" then
			if obj.getName() == pcol then
				return GD.game.players[pcol].architect_location.snap_pos
			end
		end
	end
end

--[[ *****************************
Return true if a Village is full per number of plaayers
and number of houses placed in the village.
TODO: need this in a fn? Used only once?
********************************]]
function isVillageFull(node)
	if GD.game.player_count == 2 and #node.houses == 1 then return true
	elseif GD.game.player_count > 2 and #node.houses == 2 then return true end
	return false
end

--[[ *****************************
Return the snap back playerboard location for an object.
Playerboard determined from object name(color))
********************************]]
function getPlayerBoardLocation(obj)
	if env.test.trace then log("getPlayerBoardLocation() "..tostring(obj.getGUID())) end
	local color = obj.getName()
	for _,d in ipairs(GD.game.players[color].pool) do
		if d.g == obj.getGUID() then return d.p end
	end
	for _,d in ipairs(GD.game.players[color].palaces) do
		if d.g == obj.getGUID() then return d.p end
	end
	for _,d in ipairs(GD.game.players[color].quarry) do
		if d.g == obj.getGUID() then return d.p end
	end
	if env.test.debug then log("getPlayerBoardLocation(): Nothing found on player board") end
	return nil
end

--[[ *****************************
Update game player order sorted by current player character IDs
TODO: actually update and update UI
********************************]]
function updateTurnOrder()
	if env.test.trace then log("updateTurnOrder()") end
	--sort player order by character ID
	local new_order
	for pcol,pdata in pairs(GD.game.players) do
		if new_order == nil then
			new_order = {pcol}
		else
			for i,player_color in ipairs(new_order) do
				if pdata.character_id < GD.game.players[player_color].character_id then
					table.insert(new_order, i, pcol)
					break
				elseif i == #new_order then
					table.insert(new_order, pcol)
					break
				end
			end
		end
	end
	GD.game.player_order = simpleDeepCopy(new_order)
	if env.test.debug then
		log("New player order sorted by char ID:")
		log(GD.game.player_order)
	end
	for i,pcol in ipairs(GD.game.player_order) do
		local player_board = getObjectFromGUID(C.player_boards[pcol])
		player_board.call("setState",{turn_order=i})
	end
end

--[[ *****************************
Set the next active player.
Clockwise from current player if selecting initial characters.
Uses order sorted by character ID in other stages of play.
Returns color of current player
********************************]]
function setNextPlayer(first)
	first = first or false
	if env.test.trace then log("setNextPlayer()") end
	local old_color = GD.game.current_player_color
	if first then
		GD.game.current_player = 1
	elseif GD.game.stage == "select_starting_characters" then
		local next = GD.game.current_player + 1
		if next > #GD.game.player_order then next = 1 end
		GD.game.current_player = next
	else
		if GD.game.stage == "initial_placement" then
			--find first player in order that needs to place this round of placements
			for i,pcol in ipairs(GD.game.player_order) do
				if GD.game.players[pcol].init_placements == GD.game.init_placement then
					GD.game.current_player = i
					break
				end
			end
		else
			--find first player in order that has actions
			for i,pcol in ipairs(GD.game.player_order) do
				if GD.game.players[pcol].has_actions then
					GD.game.current_player = i
					break
				end
			end
		end
	end
	GD.game.current_player_color = GD.game.player_order[GD.game.current_player]
	broadcastToAll("Current player now "..GD.game.current_player_color)
	if env.test.players and env.test.auto_switch then
		if old_color != GD.game.current_player_color then
			Player[old_color].changeColor(GD.game.current_player_color)
		end
	end
	return GD.game.current_player_color
end

--[[ *****************************
Locate the closest network node to the position.
TODO: be smarter about city radius vs village radius.
As is the radius is equal so dropping in a city edge
might detect as a nearby village.  Minor thing.
********************************]]
function closestNode(pos)
	if env.test.trace then log("closestNode()") end
	assert(pos, "***ERROR: closestNode() missing pos")
	local board = getObjectFromGUID(C.board_guid)
	local nearest_node = -1
	local shortest_dist
	for i,node in ipairs(GD.network) do
		local dist = Vector.sqrDistance(pos, board.positionToWorld(node.center))
		if shortest_dist then
			if dist < shortest_dist then
				shortest_dist = dist
				nearest_node = i
			end
		else
			shortest_dist = dist
			nearest_node = i
		end
	end
	return nearest_node
end

--[[ *****************************
Lookup and return the id for a character card guid
Returns -1 if not found (log an error)
********************************]]
function getCharacterId(guid)
	for id,char in ipairs(C.characters) do
		if char.g == guid then
			return id
		end
	end
	log("*** ERROR: getCharacterId(): no character card found for guid "..tostring(guid))
	return -1
end

--[[ *****************************
TODO: implement and document
********************************]]
function setGovernorButtons(on)
	on = on or false
	if env.test.trace then log("enableGovernorButtons() "..tostring(on)) end
	local board = getObjectFromGUID(C.board_guid)
	for i=1,17 do
		local id = "gov_"..tostring(i)
		if on then
			local occupied = false
			for _,gov in ipairs(GD.game.governor_track) do
				if i == gov.track_row then board.UI.setClass(id ,"gImg_"); occupied=true; break end
			end
			if not(occupied) then board.UI.setClass(id,"gImg") end
		else
			board.UI.setClass(id,"gImg")
		end
	end
	Wait.frames(function() reloadUI(C.board_guid) end, 30)
	GD.state.governor_buttons = on
end

--[[ *****************************
Update the dial UI for a player with player's current action state
********************************]]
function updateDialUI(pcol)
	if env.test.trace then log("updateDialUI() "..tostring(pcol)) end
	local player = GD.game.players[pcol]
	local dial = getObjectFromGUID(C.action_dials[pcol])
	for i=1,6 do
		dial.UI.setAttribute("row_action_"..tostring(i),"active",false)
	end
	local row = 0
	for _,action in ipairs(player.turn_actions) do
			row = row + 1
			dial.UI.setAttribute("action_text_"..tostring(row), "text", action.label)
			dial.UI.setAttribute("action_text_"..tostring(row), "color", "rgb(1,1,0)")
			dial.UI.setAttribute("row_action_"..tostring(row), "active", true)
			dial.UI.setAttribute("status_text_"..tostring(row), "text", action.status)
			if action.status == "Done" then
				dial.UI.setAttribute("action_text_"..tostring(row), "color", "Gray")
			elseif action.status == "Incomplete" then
				dial.UI.setAttribute("action_text_"..tostring(row), "color", "Gray")
				dial.UI.setAttribute("status_text_"..tostring(row), "color", "Red")
			end
	end
	--TODO: change '_7' to '_free' in xml ids
	if player.free_action then
		dial.UI.setAttribute("action_text_7", "text", "Build/Move a house for free")  --TODO: don't need?
		dial.UI.setAttribute("action_text_7", "color", "rgb(1,1,0)")
		dial.UI.setAttribute("row_action_7", "active", true)
		if player.free_action.status == "" then
			if player.prefer_free_action then
				dial.UI.setAttribute("free_action_btn_txt", "text", "Use First")
			else
				dial.UI.setAttribute("free_action_btn_txt", "text", "Use Last")
			end
			dial.UI.setAttribute("free_action_btn", "active", true)
			dial.UI.setAttribute("status_text_7", "text", "")   --TODO: don't need?
			dial.UI.setAttribute("status_text_7", "active", false)
		else
			dial.UI.setAttribute("free_action_btn", "active", false)
			dial.UI.setAttribute("status_text_7", "active", true)
			dial.UI.setAttribute("status_text_7", "text", "Done")   --TODO: don't need?
			dial.UI.setAttribute("action_text_7", "color", "Gray")
		end
	else
		dial.UI.setAttribute("row_action_7", "active", false)
	end
end

--[[ *****************************
Set set supplied lock state on objects respective to turn actions for player
pcol: the player color
state; Boolean, lock state: true to lock, false to unlock.
********************************]]
function updateLockStates(pcol, state)
	if env.test.trace then log("updateLockStates() "..pcol..", "..tostring(state)) end
	local player = GD.game.players[pcol]
	for _,a in ipairs(player.turn_actions) do
		if a.id == "palace" then
			unplayedPalacesLock(pcol, state)
		elseif a.id == "build" then
			buildPoolLock(pcol, state)
		elseif a.id == "move" then
			placedHousesLock(pcol, state)
		elseif a.id == "track" then
			setGovernorButtons(state)
		elseif a.id == "exchange" then
			charactersLock(pcol, state)
		end
	end
end

--[[/////////////// External call functions /////////////////////]]

--[[ ****************************
Called from player dial.
Handles when player clicks 'Set' or 'Cancel' extra action button.
********************************]]
function dialExtraAction(params)
	if env.test.trace then log("dialExtraAction()") end
	assert(params, "***ERROR: dialExtraAction(): missing params")
	assert(params.action,"***ERROR: dialExtraAction(): missing param 'action'")
	assert(params.player_color,"***ERROR: dialExtraAction(): missing param 'player_color'")
	local player = GD.game.players[params.player_color]
	local player_board = getObjectFromGUID(C.player_boards[params.player_color])
	if params.action == "set" then
		--TODO: confirm button was clicked, Set shouldn't even be shown if not?
		local pending_action = {
			key = "extra_action",
			undo = {}
		}
		for _,a in ipairs(player.turn_actions) do
			if a.pointer_id == "pointer-extra" then
				local action_id = a.id
				--execute any action effects
				if action_id == "gold" then
					player.gold = player.gold + 2
					player_board.call("setState",{gold_coins=player.gold})
					if GD.env.verbose then printToAll(params.player_color.." +2 gold for Coins action") end
					for _,a in ipairs(player.turn_actions) do
						if a.pointer_id == "pointer-extra" then a.status = "Done"; break end
					end
					updateDialUI(params.player_color)
				elseif action_id == "quarry" then
					local status = "Done"
					if quarryAction(params.player_color) then
						if GD.env.verbose then printToAll(params.player_color.." moves 2 houses into their Build Pool") end
					else
						if GD.env.verbose then printToAll(params.player_color.." is unable to complete selected Quarry action!") end
						status = "Failed"
					end
					for _,a in ipairs(player.turn_actions) do
						if a.pointer_id == "pointer-extra" then a.status = status; break end
					end
					updateDialUI(params.player_color)
				end
				table.insert(pending_action.undo, action_id)
			end
		end
		table.insert(player.pending_actions, pending_action)
		updateLockStates(params.player_color, false)
		getObjectFromGUID(C.player_pawns[params.player_color]).setLock(false)
	elseif params.action == "cancel" then
		--undo the extra action token use (add one back, delete any 'pointer-extra' turn action(s) that may have been added from dial clicks)
		player.extra_actions = player.extra_actions + 1
		player_board.call("setState",{extra_actions=player.extra_actions, extra_button=true})
		local temp = {}
		for i,a in ipairs(player.turn_actions) do
			if a.pointer_id ~= "pointer-extra" then table.insert(temp,a) end
		end
		player.turn_actions = temp
		for i,a in ipairs(player.turn_actions) do a.index = i end  --fixup index
		updateDialUI(params.player_color)
		updateLockStates(params.player_color, false)
		getObjectFromGUID(C.player_pawns[params.player_color]).setLock(false)
	else
		log("*** ERROR: dialExtraAction() unknown action param "..tostring(params.action))
	end
	if #player.pending_actions > 0 then
		player_board.call("setState",{done=true,undo=true})
	else
		player_board.call("setState",{done=true,undo=false})
	end
end

--[[ ***************************
Called from player dial during player action selection.
Update player's data with selected action on dial.
Enable Done if actions for both pointer 1 and 2 are set.
params:
		player_color: The player color.
		dial_index: The index on the dial of the selected action
			1-9
		pointer_id: the id of the dial pointer
			'pointer-1', 'pointer-2', 'pointer-3'
********************************]]
function addDialAction(params)
	if env.test.trace then log("addDialAction()") end
	assert(params, "***ERROR addDialAction(): missing params")
	if env.test.debug then log(params) end
	local pcol = params.player_color
	assert(pcol,"***ERROR addDialAction(): missing player_color param")
	local dial_index = params.dial_index
	assert(dial_index, "***ERROR addDialAction(): missing dial_index param")
	local pointer_id = params.pointer_id
	assert(pointer_id, "***ERROR addDialAction(): missing pointer_id param")
	local player = GD.game.players[pcol]
	--remove any previous entries for this pointer id
	local temp = simpleDeepCopy(player.turn_actions)
	player.turn_actions = {}
	for i,a in ipairs(temp) do
		if a.pointer_id ~= pointer_id then
			a.index = #player.turn_actions + 1
			table.insert(player.turn_actions, a)
		end
	end
	--add new actions for this dial index
	for _,a in ipairs(C.dial_actions[dial_index].actions) do
		local action = simpleDeepCopy(a)
		action.index = #player.turn_actions + 1
		action.status = ""
		action.pointer_id = pointer_id
		table.insert(player.turn_actions,action)
	end
	player.pointers[pointer_id] = true
	if pointer_id ~= "pointer-extra" then
		if player.pointers["pointer-1"] and player.pointers["pointer-2"] then
			local player_board = getObjectFromGUID(C.player_boards[pcol])
			player_board.call("setState",{done=true})
		end
	end
	updateDialUI(pcol)
end

--[[/////////////// Network stuff  /////////////////////]]

--[[ *****************************
Setup: initialize network data
********************************]]
function setupNetwork()
	if env.test.trace then log("setupNetwork()") end
	GD.network = simpleDeepCopy(NETWORK)
	for i,node in ipairs(GD.network) do
		node.center = CENTERS[i]
		if node.type == "city" then
			node.houses = {}
			for _,pcol in pairs(C.table_colors) do
				node.houses[pcol] = {}
			end
			node.palaces = {}
			node.architects = {}
		elseif node.type == "village" then
			node.houses = {}
		end
	end
	setupPathTable()
end

--[[ *****************************
Setup: initialize path table
********************************]]
function setupPathTable()
	if env.test.trace then log("setupPathTable()") end
	GD.path_table = simpleDeepCopy(PATH_TABLE)
end

--[[ *****************************
Update path table state and associated costs for given player
Path state is "open" if all villages on Path have at least one house.
Path cost is determined by supplied player color and villages on Path.
	Each village is a table of costs to be paid to colors of opponents
		for each matching house color in the village..
	Villages with at least one house of player's color are free.
Closed Path initialized to an empty cost table.
If no player color given, all Path costs will be initialized to empty.
********************************]]
function updatePathTable(pcol)
	if env.test.trace then log("updatePathTable() "..tostring(pcol)) end
	for i,path in ipairs(GD.path_table) do
		path.open = true
		for _,v in ipairs(path.villages) do
			if #GD.network[v].houses == 0 then
				path.open = false
				break
			end
		end
		path.cost = {}
		if path.open and pcol ~= nil then
			for _,v in ipairs(path.villages) do
				local free = false
				local village_cost = {}
				for _,house in ipairs(GD.network[v].houses) do
					if house.c == pcol then
						free = true
						break
					else
						if village_cost[house.c] then
							village_cost[house.c] = village_cost[house.c] + 1
						else
							village_cost[house.c] = 1
						end
					end
				end
				if not(free) then
					for color,cost in pairs(village_cost) do
						if path.cost[color] then
							path.cost[color] = path.cost[color] + cost
						else
							path.cost[color] = cost
						end
					end
				end
			end
		end
	end
end

--[[ *****************************
Build a table of valid routes between start and destination cities.
NOTE: 'start_id' and 'dest_id' are the city IDs from the network table.  This
has to be converted to index into the CITY_CONNECTIONS table.  TODO: May be
able to consolidate this into one table
Returns a table of discovered routes.
********************************]]
function buildRouteTable(start_id, dest_id)
	if env.test.trace then log("buildRouteTable() start: "..tostring(start_id)..", dest: "..tostring(dest_id)) end
	local sub_debug = false
	local start, dest
	local route_table = {}
	--get the city connection table ids for supplied start and dest network node ids HACK:
	for id,conn in ipairs(CITY_CONNECTIONS) do
		if conn.network_id == start_id then start = id end
		if conn.network_id == dest_id then dest = id end
	end
	if env.test.debug then log("connections start: "..tostring(start)..", dest: "..tostring(dest)) end
	--[[///////////////////////////////////////////////////////////
	Recursively crawl the neighbors of a city.
	Ignore loops back to start.
	Ignore paths already seen.
	Return true if dest found, false if not.
	Paths added to route if dest found.
	///////////////////////////////////////////////////////////////]]
	local function addPaths(id, route)
		if sub_debug then log("addPaths() process city id: "..tostring(id)) end
		if #route.seen > 8 or #route.paths > 16 then log("*****ERROR: addPath() safety exceeded"); return end
		if id == route.dest then
			table.insert(route.seen,id)
			table.insert(route_table, simpleDeepCopy(route)) --save a copy of this route
			return
		end
		table.insert(route.seen, id)
		for _,neighbor in ipairs(CITY_CONNECTIONS[id].neighbors) do
			if not(contains(route.seen, neighbor.id)) and GD.path_table[neighbor.path].open then
				local route_to_here = simpleDeepCopy(route)
				table.insert(route_to_here.paths, neighbor.path)
				addPaths(neighbor.id, route_to_here)
			end
		end
	end
	--[[////////////////////
	Start the crawl
	///////////////////////]]
	for _,neighbor in ipairs(CITY_CONNECTIONS[start].neighbors) do
		if GD.path_table[neighbor.path].open then
			local route = {dest=dest, paths={neighbor.path}, seen={start}}
			if neighbor.id == route.dest then
				table.insert(route.seen, neighbor.id)
				table.insert(route_table, route)
			else
				addPaths(neighbor.id, route)
			end
		end
	end
	return route_table
end

--[[/////////////// DEVELOPMENTAL STUFF ///////////////////////]]

function testCityHouses(pcol, city_name)
	log("put selected houses in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(city_name.." center is "..tostring(center))
	local color_indexes = {Yellow = 0,Red = 0,Green = 0,Blue = 0,Purple = 0,}
	for _,o in ipairs(stuff) do
		local color = o.getName()
		color_indexes[color] = color_indexes[color] + 1
		local offset = Vector(C.city_house_offsets[color][color_indexes[color]].o)
		log("placing "..color.." object "..o.getGUID().." with offset "..tostring(color_indexes[color])..": "..tostring(offset))
		local pos = center - offset
		local rot = Vector(C.city_house_offsets[color][color_indexes[color]].r)
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function testCityPalaces(pcol, city_name)
	log("put selected houses in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	if #stuff > 7 then
		log("Only 7 palaces max allowed in a city")
		return
	end
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(center)
	for index,o in ipairs(stuff) do
		local offset = Vector(0,0,0)
		if index < 7 then offset = C.city_palace_offsets[index] end
		log("putting object "..o.getGUID().." in loc "..tostring(index)..", at offset "..tostring(offset))
		local pos = center - offset
		local rot = board.getRotation()
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function testCityPawns(pcol, city_name)
	log("put selected pawns in "..city_name)
	local stuff = Player[pcol].getSelectedObjects()
	log(#stuff.." selected objects to process")
	if #stuff > 5 then
		log("Only 5 pawns max allowed in a city")
		return
	end
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers[city_name]
	log(center)
	for index,o in ipairs(stuff) do
		local offset = Vector(C.city_pawn_offsets[index])
		log("putting object "..o.getGUID().." in loc "..tostring(index)..", at offset "..tostring(offset))
		local pos = center - offset
		local rot = Vector(0,90,0)
		o.setRotationSmooth(rot, false, true)
		o.setPositionSmooth(board.positionToWorld(pos), false, true)
	end
end

function getWorldPos(pcol)
	log("Getting positions of selected objects relative to world")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	local s=""
	for i,o in ipairs(stuff) do
    local p = o.getPosition()
		local t = tostring(i)..': '..o.getGUID()..': '..tostring(p)
		log(t)
		s = s .. t .. '\n'
	end
	if s ~= "" then
    Notes.setNotes(s)
  end
end

function getLTB(pcol)
  log("Getting positions of selected objects relative to board")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	--local board = getObjectFromGUID(C.board_guid)
	local board = getObjectFromGUID(C.board_guid)
  local s = ""
  for i,o in ipairs(stuff) do
    log("Processing object #"..tostring(i)..": "..o.getGUID())
    local p = board.positionToLocal(o.getPosition())
    -- local r = Vector(0,180,0)
		-- City house positions
		-- local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},r={'..r.x..','..r.y..','..r.z..'}},'
		local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},r={0,180,0}},'
    log(t)
    s = s .. t .. '\n'
  end
  if s ~= "" then
    Notes.setNotes(s)
  end
end

function getLTPB(pcol)
	log("Getting positions of selected objects relative to player board")
  local stuff = Player[pcol].getSelectedObjects()
  log(#stuff.." selected objects to process")
	local board = getObjectFromGUID(C.player_boards[pcol].g)
  local s = ""
  for i,o in ipairs(stuff) do
    log("Processing object #"..tostring(i)..": "..o.getGUID())
    local p = board.positionToLocal(o.getPosition())
		local r = board.getRotation()
		local t = '{g="'..o.getGUID()..'",p={'..p.x..','..p.y..','..p.z..'},},'
    log(t)
    s = s .. t .. '\n'
  end
  if s ~= "" then
    Notes.setNotes(s)
  end
end

function getOffsets()
	local board = getObjectFromGUID(C.board_guid)
	local center = C.city_centers.Agra
	center.y = 0
	log(center)
	local s = ""
	for i,loc in ipairs(C.ltb) do
		local pos = Vector(loc.p)
		pos.y = 0
		local o = center - pos
		-- local r = Vector(loc.r)
		-- local t = '{o={'..o.x..','..o.y..','..o.z..'},r={'..r.x..','..r.y..','..r.z..'}},'
		local t = '{o={'..o.x..','..o.y..','..o.z..'},r={0,180,0}}'
		log(t)
		s = s .. t .. '\n'
	end
	if s ~= "" then
		Notes.setNotes(s)
	end
end

require("tts-lib/utils")
require("tts-maharaja/Constants")
require("tts-maharaja/Network")
